<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BIOS ROM Image分析</title>
      <link href="2021/08/01/BIOS_ROM_Image/"/>
      <url>2021/08/01/BIOS_ROM_Image/</url>
      
        <content type="html"><![CDATA[<h1 id="Flash芯片和生成的BIOS-ROM"><a href="#Flash芯片和生成的BIOS-ROM" class="headerlink" title="Flash芯片和生成的BIOS ROM"></a>Flash芯片和生成的BIOS ROM</h1><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/86ed9927664912afa5ce9778ee3f498.jpg" alt="主板上的NorFlash"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604388851409.png" alt="FPT整刷的bin"></p><h1 id="intel闪存映像布局"><a href="#intel闪存映像布局" class="headerlink" title="intel闪存映像布局"></a>intel闪存映像布局</h1><p>英特尔在相应芯片组的数据表页面上讨论了BIOS的结构。对于所有从第六系列开始的芯片组，此格式通常保持不变，该文件分为3-5个区域，可选的是GbE区域和PDR。</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604388929921.png"></p><h1 id="UEFI-Tool解析"><a href="#UEFI-Tool解析" class="headerlink" title="UEFI Tool解析"></a>UEFI Tool解析</h1><p>用<a href="https://github.com/LongSoft/UEFITool">EFITool</a>工具加载了编译生成的bin文件，发现Reset Vector位于BIOS Rom Image的最底部，探索形成这样的Image结构相关的各种文件(.fdf/.fd/.fv等文件)</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604389109072.png"></p><p>组成结构：16MBIOS + 16M ME + 16M 128KB PDR</p><p>BIOS Rom部分，由GenFv工具根据fdf文件生成</p><pre><code>#FD Section[FD.AMIROM]BaseAddress = 0xff000000Size = 0x1000000ErasePolarity = 1BlockSize = 0x1000NumBlocks = 0x1000DEFINE UNCOMPRESSED_PEI_EXECUTABLES_ALIGNMENT =  DEFINE SEC_CORE_EXECUTABLE_ALIGNMENT = Align = 8......0x0|0x20000FV = LNV_OEM_DATA_REGION0x20000|0x50000FV = NVRAM0x70000|0x50000#RAW - NVRAM_BACKUP0xc0000|0x20000FV = LEM_FV_DATA0xe0000|0x870000FV = FV_MAIN_WRAPPER0x950000|0x20000FV = FV_CMP0x970000|0x10000FV = FV_BCP0x980000|0x110000FV = FV_DATA_BACKUP0xa90000|0x110000FV = FV_DATA0xba0000|0xa0000FV = FV_BB_AFTER_MEMORY_BACKUP0xc40000|0x90000FV = FV_FSP_S_BACKUP0xcd0000|0xa0000FV = FV_BB_AFTER_MEMORY0xd70000|0x90000FV = FV_FSP_S0xe00000|0x70000#FV_FSP_BACKUPFILE = Build/Fsp_Rebased_M_T.fd0xe70000|0x90000FV = FV_BB_BACKUP0xf00000|0x70000#FV_FSPFILE = Build/Fsp_Rebased_M_T.fd0xf70000|0x90000FV = FV_BB#FV Section[FV.FV_MAIN]BlockSize = 0x1000NumBlocks = 0x0FvAlignment = 16MEMORY_MAPPED = TRUEFvNameGuid = 5C60F367-A505-419A-859E-2A4FF6CA6FE5APRIORI DXE &#123;    INF AmiModulePkg/AmiStatusCode/StatusCodeDxe.inf    INF AmiModulePkg/AmiStatusCode/StatusCodeSmm.inf    INF MdeModulePkg/Universal/PCD/Dxe/Pcd.inf    ......!include AmiPkg/Configuration/FontFileStatement.txt!include AmiModulePkg/NVRAM/FvMainDefaultsFdfFileStatement.txt!include AmiChipsetModulePkg/LegacyRom/Vbios/VbiosFdfFileStatements.txt......#FV Section[FV.FV_LOGOROMHOLE]BlockSize = 0x1000NumBlocks = 0x20FvAlignment = 1......FvNameGuid = E54D9684-2735-43ef-A379-30F2F592BA10!include AmiTsePkg/Core/em/AMITSE/Logoffs.txt#FV Section[FV.FV_MEFW_CAPSULE]BlockSize = 0x1000NumBlocks = 0x600FvAlignment = 16......FvNameGuid = 9F8B1DEF-B62B-45F3-8282-BFD7EA19801BINF RuleOverride = SubtypeGuidUncompressedNoChecksum Build/MeFwFid.inf......!include AmiModulePkg/Ofbd/Meud/AutoMeud/MeRegionFdfFileStatement.txt#FV Section[FV.LNV_OEM_DATA_REGION]BlockSize = 0x1000NumBlocks = 0x20FvAlignment = 1......#FV Section[FV.NVRAM]BlockSize = 0x1000NumBlocks = 0x50FvAlignment = 16......FvNameGuid = FA4974FC-AF1D-4E5D-BDC5-DACD6D27BAEC!include AmiModulePkg/NVRAM/NvramFdfFileStatement.txt#FV Section[FV.LEM_FV_DATA]BlockSize = 0x1000NumBlocks = 0x20FvAlignment = 16......FvNameGuid = 4f1c52d3-d824-4d2a-a2f0-ec40c23c5916INF RuleOverride = SubtypeGuidUncompressedNoChecksum ......!include AmiTsePkg/Core/em/AMITSE/Romhole.txt#FV Section[FV.FV_CMP]BlockSize = 0x1000NumBlocks = 0x20FvAlignment = 16......FvNameGuid = aea406cf-4fc8-4dc3-9796-1ee03b64c715!include LenovoModulePkg/Universal/ExtendedComputrace/AbsolutePkg/OEMSpecifiedAgentX64ProductionInstaller.txt#FV Section[FV.FV_BCP]BlockSize = 0x1000NumBlocks = 0x10FvAlignment = 16......FvNameGuid = 8649FC2D-C0E6-4262-AD51-0CEABAB6429EINF RuleOverride = Uncompressed PldmPkg/BiosConfigPreserve/BiosConfigPreserveBin/BCPFlashData/BCPFlashData.inf#FV Section[FV.FV_DATA_BACKUP]BlockSize = 0x1000NumBlocks = 0x110FvAlignment = 16......FvNameGuid = E4A068F1-5EF1-4ACE-857C-7935F8A0C708!include CrbPkg/AmiCrbIntelTopSwap/FvDataBackupFdfFileStatement.txt#FV Section[FV.FV_DATA]BlockSize = 0x1000NumBlocks = 0x110FvAlignment = 16......FvNameGuid = AFDD39F1-19D7-4501-A730-CE5A27E1154BINF RuleOverride = UncompressedBinaryNoChecksum AmiChipsetModulePkg/FIT/ReserveBinary/ReserveBootGuardSaveResigndata.inf!include AmiChipsetModulePkg/FIT/FitTable/FitMicrocodeFdfFileStatement.txt#FV Section[FV.FV_BB_AFTER_MEMORY_BACKUP]BlockSize = 0x1000NumBlocks = 0xa0FvAlignment = 16......FvNameGuid = 5b08a058-784f-4938-9a49-1588aa05f4b9......#FV Section[FV.FV_FSP_S_BACKUP]BlockSize = 0x1000NumBlocks = 0x90FvAlignment = 16!include Intel/CometLakeFspBinPkg/FvFspSFdfFileStatement.txt#FV Section[FV.FV_BB_AFTER_MEMORY]BlockSize = 0x1000NumBlocks = 0xa0FvAlignment = 16......#FV Section[FV.FV_FSP_S]BlockSize = 0x1000NumBlocks = 0x90FvAlignment = 16!include Intel/CometLakeFspBinPkg/FvFspSFdfFileStatement.txt......#FV Section[FV.FV_BB_BACKUP]BlockSize = 0x1000NumBlocks = 0x90FvBaseAddress = 0xfff70000......FvNameGuid = 61C0F511-A691-4F54-974F-B9A42172CE53APRIORI PEI &#123;    INF AmiModulePkg/AmiStatusCode/StatusCodePei.inf    INF AmiModulePkg/IO/NCT6686D/NCT6686DPeiInit.inf    ......!include Build/BiosGuardPubKeyhash_FdfFileStatement.txt!include AmiChipsetModulePkg/FIT/FitTable/FitTableFdfFileStatement.txt!include LenovoModulePkg/Universal/BuildNaming/BuildNaming.txt#FV Section[FV.FV_BB]BlockSize = 0x1000NumBlocks = 0x90FvAlignment = 16......FvNameGuid = 61C0F511-A691-4F54-974F-B9A42172CE53APRIORI PEI &#123;    INF AmiModulePkg/AmiStatusCode/StatusCodePei.inf    INF AmiModulePkg/IO/NCT6686D/NCT6686DPeiInit.inf    INF LenovoModulePkg/Universal/AssetID/AssetIDOnRecoveryMode/AssetIDOnRecoveryModePei.inf    ......!include AmiChipsetModulePkg/BiosGuard/Binary/BiosGuardBinary_FdfFileStatement.txt!include Intel/CometLakePlatSamplePkg/Binaries/Pct/PctGpioFdfFileStatements.txt!include ......</code></pre><p>fdf文件的开头部份是关键字[fd]，它表示完整的BIOS Rom Image。还指定了BIOS的加载地址BaseAddress = 0xff00000，大小Size = 0x1000000(16M)，这与UEFITool给出的数据不谋而合：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604389689841.png"></p><p>根据BIOS Rom Image位于4G空间的顶部(0xFFFFFFFF)，减去Rom Image Size就可以推得Bios Rom加载地址(就是Fdf文件中的BaseAddress=0xff000000)<br>接下来形如下列内容:</p><pre><code>Offset|Size[RegionType]</code></pre><p>则是在FD中开辟了一段连续空间，用来存放FV/FILE等内容。其中Offset和Size是这段空间的相对于整个FD的偏移和大小；前面UEFITool图中”BIOS Region”中列出的每一个FFS项都可以对应到Fdf文件[FD]节中RegionType为FV的项(毕竟只有FV才会用到文件系统FFS)。如果仔细比对，可能会发现UEFITool中倒数第二和倒数第三个FFS的Size和Padding相加正好对应[FD]节中的FV_FSP：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604389914494.png"></p><pre><code>0xf00000|0x70000#FV_FSPFILE = Build/Fsp_Rebased_M_T.fd\</code></pre><p>FV_FSP项的RegionType是FILE，可以包含任意内容，自然也可以包含其他的fd文件，就如NCB_LOGO项中包含了开机Logo文件；其次，fd文件又由fv组成，UEFITool又能解析fd文件，因此造成了这种FDF和BIOS Rom image不一致。其实，我们可以用UEFITool加载Fsp_Rebuild_M_T.fd，发现其中包含两个FFS：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604390180438.png"></p><p>如果FV_FSP包含的fd文件是经过压缩操作的，那么FDF文件中RegionType为FV的项应该和UEFITool实际得到的相一致。</p><p>FDF文件[FD]节之后就是大量的[FV]节，FV的主要作用就是包含组件和模块。他们来填充[FD]节中开辟的空间。先来看一个相对简单的FV节：FV.NVRAM，它只包含一个include语句，指向NvramFdfFileStatement.txt文件:</p><pre><code>!include AmiModulePkg/NVRAM/NvramFdfFileStatement.txt</code></pre><p>NvramFdfFileStatement.txt文件通过FILE指令，包含binary file：</p><pre><code>  FILE RAW = CEF5B9A3-476D-497f-9FDC-E98143E0422C &#123;    $(OUTPUT_DIRECTORY)/Nvram.bin  &#125;</code></pre><p>FV的主要作用就是填充[FD]节中开辟的空间，用这个FV节验证一下：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391042176.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391071513.png"></p><p>FDF中，FV.Nvram位于Bios Rom image的开头，Fv guid：FA4974FC-AF1D-4E5D-BDC5-DACD6D27BAEC，NvramFdfFileStatement.txt中指定的File Guid：CEF5B9A3-476D-497f-9FDC-E98143E0422C；用UEFITool加载Bios Rom image，第一个FFS(就是FV.Nvram)的Volume GUID: FA4974FC-AF1D-4E5D-BDC5-DACD6D27BAEC；再展开FFS，其中包含的唯一的文件的File Guid: CEF5B9A3-476D-497F-9FDC-E98143E0422C，这些值和FDF中的Fv Guid以及File Guid是一致的。<br>除了File Guid是一致的，用UEFITool解压后得到的Nvram.bin和原始的Nvram.bin的内容也是一致的：</p><p>以上是简单的FV的情况，有些复杂的FV中可以嵌套其他的FV，如FDF中的FV.FV_MAIN_WRAPPER，我们再来分析一下它：</p><pre><code>#FV Section[FV.FV_MAIN_WRAPPER]BlockSize = 0x1000NumBlocks = 0x870......!include AmiPkg/Configuration/NestedFvMainFdfFileStatement.txt</code></pre><p>FV.FV_MAIN_WRAPPER节中内容不多，仅仅含有若干条!include语句，但是FV.FV_MAIN_WRAPPER节占据BIOS Rom Image很大一块空间：BlockSize<em>NumBlocks=0x1000</em>0x870=0x870000。它占用如此多空间的原因是NestedFvMainFdfFileStatement.txt通过FILE指令包含了一块压缩的FV文件，而该FV文件是Dxe阶段的代码</p><p>NestedFvMainFdfFileStatement.txt的内容如下：</p><pre><code>#Includes FVMAIN FV imageFILE FV_IMAGE = 9E21FD93-9C72-4c15-8C4B-E77F1DB2D792 $(FFS_FILE_CHECKSUM_KEYWORD) &#123;  SECTION $(PEI_COMPRESSION_SECTION) &#123;    SECTION FV_IMAGE = FV_MAIN  &#125;&#125;</code></pre><p>FV_MAIN节内容如下：</p><pre><code>#FV Section[FV.FV_MAIN]BlockSize = 0x1000NumBlocks = 0x0FvAlignment = 16......INF AmiModulePkg/RomLayout/RomLayoutDxe.infINF MdeModulePkg/Core/Dxe/DxeMain.infINF AmiModulePkg/Bds/Bds.inf</code></pre><p>前面找到Dxe阶段的代码，那Sec和Pei阶段的代码在哪？platform.fdf文件[fd]节中设定FV_BB节位于Bios Rom image的尾部，因此，我们可以猜测并验证Sec模块和Pei模块也位于FV_BB中：</p><pre><code>[FV.FV_BB]BlockSize = 0x1000NumBlocks = 0xa0...APRIORI PEI &#123; ;PEI阶段的APRIORI文件    INF AmiModulePkg/AmiStatusCode/StatusCodePei.inf    ...&#125;...INF MdeModulePkg/Core/Pei/PeiMain.inf ;Pei阶段入口...INF UefiCpuPkg/SecCore/SecCore.inf ;Sec阶段入口...INF UefiCpuPkg/CpuIoPei/CpuIoPei.infINF MdeModulePkg/Universal/PcatSingleSegmentPciCfg2Pei/PcatSingleSegmentPciCfg2Pei.inf</code></pre><p>虽然，我们已经确定Sec模块和Pei模块位于FV_BB块中，但是有个问题随之出现：SecCore.inf并不是FV_BB中最后一个模块(夹在其他模块之间)，所以一眼看去感觉开机时执行的第一条指令并不在SecCore模块中，这明显与EFI Spec相悖。更何况SecCore.inf含有ResetVector：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391678324.png" alt="SecCore.inf部分内容"></p><p>另外，UEFITool也明显显示SecCore位于Bios Rom image尾部</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391761934.png"></p><p>fdf的设定和实际现象有差异，那一定是GenFv在生成Bios Rom image时有特殊处理。和GenFv Build Bios相关的只能查看Build.log，它记录了从源码到制成Rom Image的全过程，在Build.log的结尾，记录了各个模块在Bios Rom Image的排列位置，我发现了特殊的一处Firmware Volumon:08 No.049 类型是SECC—-SecCore，属性被标记为VTF，Bios Rom Image中其他FV中任何模块都不具有该属性：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391860137.png"></p><p>在PI spec Vol3中提到：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604392019507.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604392038413.png"></p><p>VTF是Volume Top File的缩写，PI spec规定VTF的File Guid为EFI_FFS_VOLUME_TOP_FILE_GUID（1BA0062E-C779-4582-8566-336AE8F78F09），必须位于firmware volume的最后一个字节。而SecCore.inf的FILE_GUID = 1BA0062E-C779-4582-8566-336AE8F78F09。看来只要某个inf指定自己FILE_GUID为EFI_FFS_VOLUME_TOP_FILE_GUID就有机会被安排在最开始执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flash,Layout,FV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OemWmi Demo</title>
      <link href="2021/08/01/OemWmi%20Demo/"/>
      <url>2021/08/01/OemWmi%20Demo/</url>
      
        <content type="html"><![CDATA[<h1 id="WMI简介"><a href="#WMI简介" class="headerlink" title="WMI简介"></a>WMI简介</h1><h2 id="WMI历史"><a href="#WMI历史" class="headerlink" title="WMI历史"></a>WMI历史</h2><p>Windows Management Instrumentation（WMI）是Microsoft基于Web的企业管理（WBEM）的实现，WBEM是一项行业倡议，旨在开发用于在企业环境中访问管理信息的标准技术。WMI使用通用信息模型（CIM）行业标准来表示系统，应用程序，网络，设备和其他托管组件。CIM由分布式管理任务组（<a href="https://www.dmtf.org/standards/wsman">DMTF</a>）开发和维护。WMI最初于1998年作为Windows NT 4.0 Service Pack 4的附加组件发布，是Windows 2000，Windows XP和Windows Server 2003家族操作系统中内置的支持核心管理的技术。(详情见微软官网<a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/about-wmi">WMI Document</a>)。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在WMI之前，可以通过编程方式访问Windows资源的唯一方法是通过Win32 API。 这种情况使Windows系统管理员无法轻松地使用流行的脚本语言来自动化常见的系统管理任务，因为大多数脚本语言无法直接调用Win32 API。 WMI通过提供一个一致的模型和框架来描述所有Windows资源并将其公开给外界，从而改变了这种状况。 WMI是一种工具和管道，通过它可以访问，配置，管理和监视所有（几乎所有）Windows资源，系统管理员可以使用WMI脚本库创建系统管理脚本，以管理通过WMI公开的任何Windows资源！</p><h2 id="BIOS与WMI的关系"><a href="#BIOS与WMI的关系" class="headerlink" title="BIOS与WMI的关系"></a>BIOS与WMI的关系</h2><p>通常，BIOS不需要为WMI做任何事情，Windows提供了Windows管理所需的所有WMI。 但是有时候，客户想要实现特殊的OEM功能，则需要BIOS通过WMI与AP / Driver配合，例如在CML 7C43&amp;P340 Project中Lenovo Module通过LenovoGameZone.mof和Lenovo.mof作为Provider，声明BIOS提供给OS的WMI接口。<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383419998.png"></p><h2 id="WMI架构图"><a href="#WMI架构图" class="headerlink" title="WMI架构图"></a>WMI架构图</h2><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383435473.png"></p><p>wmi可以使用多种方式进行调用，具体可以参考上图：<br>首先是wm使用者，比如脚本或者其他用到wm接口的应用程序。由wm使用者访问CIM对象管理器WinMgmt(即WMI服务）,后者再访问CIM(公共信息模型Common Information Model)存储库。静态或动态的信息（对象的属性）就保存在CM库中，同时保存对象的方法。比如启动一个服务，通过执行对象的方法实现，实际上是通过COM技术调用各种dll,最后由dll中封装的API完成请求。WMI是事件驱动的，操作系统、服务、应用程序、设备驱动程序等都可以作为事件源，通过COM接口生成事件通知，WinMgmt捕捉到事件，然后刷新CM库中的动态信息。这也是为什么WM服务依赖于EventLog的原因。就像注册表有Key和Value一样，CIM库也有分类，用面向对象的术语描述来说，叫做命名空间（Name Space)。</p><h1 id="OemWmi-ModulePart"><a href="#OemWmi-ModulePart" class="headerlink" title="OemWmi ModulePart"></a>OemWmi ModulePart</h1><h2 id="ModulePart说明"><a href="#ModulePart说明" class="headerlink" title="ModulePart说明"></a>ModulePart说明</h2><p>建立OemWmi ModulePart，简单的封装一个接口注册到OS下，实现向80 Port写值的动作，应用层可以通过通过VB Script或C++调用。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><ul><li>OemWmi.mof</li></ul><pre><code>//****************************************************//filename:MyWmi.mof// MOF(Managed Object File) Sample// 2020.08.05// MOF comment as C++#pragma AUTORECOVER//WMI checks the integrity of the WMI repository when the operating system//starts WMI. If the repository is damaged, WMI automatically rebuilds the //repository and recompiles it.#pragma namespace(&quot;\\root\\wmi&quot;)//specify the namespace when autorecover or register.[WMI, Dynamic, Provider(&quot;WmiProv&quot;), Locale(&quot;MS\\0x409&quot;), Description(&quot;My WMI Sample Class&quot;), guid(&quot;&#123;E2E0B817-EA48-4bad-81A6-FBEB8776A7AF&#125;&quot;)]//WMI Class Qualifiersclass MyClass&#123;    [key, read] string InstanceName;    [read] Boolean Active;    [WmiMethodId(1),     Implemented,     read, write,     Description(&quot;Send to Port 0x80&quot;)    ]void SendTo80([in] uint8 Data);&#125;;//Required Items in WMI Class//*****************************************************</code></pre><ul><li>OemWmi.sdl</li></ul><pre><code> PCIDEVICE    Title  = &quot;OemWmi&quot;    Parent  = &quot;PciHost (Virtual)&quot;    Attribute  = &quot;0x0&quot;      Dev_type  = &quot;Container&quot;    Dev  = 00h    Fun  = 00h    SleepNum  = 01h    ASLfile  = &quot;&#39;OemPkg\OemWmi\OemWmi.asl;After Pci Tree&#39;&quot;    DeviceType = OnBoard    PCIBusSize = 32bit    ROMMain = No    Virtual = YesEndTOKEN    Name  = &quot;OemWmi_INF_SUPPORT&quot;    Value  = &quot;1&quot;    Help  = &quot;Main switch to enable OemWmi support in Project&quot;    TokenType = Boolean    TargetMAK = Yes    Master = YesEndINFComponent    Name  = &quot;OemWmi&quot;    File  = &quot;OemWmi.inf&quot;    Package  = &quot;OemWmi&quot;    Token = &quot;OemWmi_INF_SUPPORT&quot; &quot;=&quot; &quot;1&quot;End</code></pre><ul><li>OemWmi.cif</li></ul><pre><code> PCIDEVICE    Title  = &quot;OemWmi&quot;    Parent  = &quot;PciHost (Virtual)&quot;    Attribute  = &quot;0x0&quot;      Dev_type  = &quot;Container&quot;    Dev  = 00h    Fun  = 00h    SleepNum  = 01h    ASLfile  = &quot;&#39;OemPkg\OemWmi\OemWmi.asl;After Pci Tree&#39;&quot;    DeviceType = OnBoard    PCIBusSize = 32bit    ROMMain = No    Virtual = YesEndTOKEN    Name  = &quot;OemWmi_INF_SUPPORT&quot;    Value  = &quot;1&quot;    Help  = &quot;Main switch to enable OemWmi support in Project&quot;    TokenType = Boolean    TargetMAK = Yes    Master = YesEndINFComponent    Name  = &quot;OemWmi&quot;    File  = &quot;OemWmi.inf&quot;    Package  = &quot;OemWmi&quot;    Token = &quot;OemWmi_INF_SUPPORT&quot; &quot;=&quot; &quot;1&quot;End</code></pre><ul><li>OemWmi.asl</li></ul><pre><code>Scope( \_SB )&#123; Device(WMI2)&#123;        // PNP0C14 is Plug and Play ID assigned to WMI mapper    Name(_HID, EISAID(&quot;PNP0C14&quot;))    Name(_UID, 2)        //        // _WDG evaluates to a data structure that specifies the data        // blocks supported by the ACPI device.        //    Name(_WDG, Buffer() &#123;         //guid&#123;E2E0B817-EA48-4bad-81A6-FBEB8776A7AF&#125;        // -------- Method execution for SendTo80            0x17, 0xb8, 0xe0, 0xe2, 0x48, 0xea, 0xad, 0x4b, 0x81, 0xa6,            0xfb, 0xeb, 0x87, 0x76, 0xa7, 0xaf,            69, 49,     // Object ID (E1)            1,          // Instance Count            0x02,       // Flags WMIACPI_REGFLAG_METHOD             // -------- MOF data            0x21, 0x12, 0x90, 0x05, 0x66, 0xd5, 0xd1, 0x11, 0xb2, 0xf0,            0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10,            66, 65,     // Object ID (BA)            1,          // Instance Count            0x00,       // Flags    &#125;)   OperationRegion (DBG, SystemIO, 0x80, 0x2)   Field (DBG, WordAcc, NoLock, Preserve)   &#123;        P80H, 16   &#125;    Method(WME1, 3) &#123;    If(LEqual(Arg1,1))    &#123;      Store(Arg2,P80H)    &#125;     Return(0)        &#125;    Name(WQBA, Buffer()    &#123;    0x46, 0x4f, 0x4d, 0x42, 0x01, 0x00, 0x00, 0x00, 0x74, 0x02, 0x00, 0x00, 0x80, 0x05, 0x00, 0x00,    0x44, 0x53, 0x00, 0x01, 0x1a, 0x7d, 0xda, 0x54, 0x28, 0xd3, 0x82, 0x00, 0x01, 0x06, 0x18, 0x42,    0x20, 0xc4, 0x01, 0x89, 0xc0, 0xb2, 0x69, 0x24, 0xc2, 0x01, 0x0c, 0x46, 0x03, 0x88, 0xe4, 0x40,    0xc8, 0x05, 0x13, 0x83, 0x0b, 0x21, 0xaf, 0x02, 0x6c, 0x0a, 0x30, 0x09, 0xa2, 0xfe, 0xfd, 0x21,    0x4a, 0x82, 0x43, 0x09, 0x81, 0x90, 0x44, 0x01, 0xe6, 0x05, 0xe8, 0x16, 0x60, 0x58, 0x80, 0x6d,    0x01, 0xa6, 0x05, 0x38, 0x86, 0xa4, 0xd2, 0xc0, 0x29, 0x81, 0xa5, 0x40, 0x48, 0xa8, 0x00, 0xe5,    0x02, 0x7c, 0x0b, 0xd0, 0x8e, 0x28, 0xc9, 0x02, 0x2c, 0xc3, 0x88, 0xc0, 0xa3, 0x88, 0x6c, 0x34,    0x0e, 0x8d, 0x1d, 0x86, 0x65, 0x82, 0x69, 0x10, 0x87, 0x51, 0x36, 0xb2, 0x08, 0x3c, 0xa1, 0x4e,    0x05, 0xc8, 0x15, 0x20, 0x4c, 0x80, 0x78, 0x54, 0x61, 0x34, 0x07, 0x45, 0xf0, 0x43, 0x63, 0xc4,    0x8c, 0x89, 0xc0, 0x76, 0x8e, 0xad, 0x51, 0x9c, 0x46, 0xe1, 0x02, 0xa4, 0x63, 0x68, 0x04, 0xc7,    0x15, 0xde, 0x23, 0x2b, 0x68, 0x86, 0x14, 0xe4, 0x10, 0xce, 0xcd, 0x80, 0xa7, 0x61, 0x9c, 0x0e,    0x41, 0x04, 0x14, 0x3b, 0xc2, 0x01, 0x6b, 0x10, 0x28, 0x19, 0x10, 0xf2, 0x2c, 0xc0, 0xfa, 0xe8,    0x08, 0x81, 0xdd, 0x0b, 0xb0, 0x28, 0x40, 0x19, 0x84, 0xc6, 0x53, 0xe1, 0xf8, 0x0b, 0x30, 0x26,    0xc0, 0x9b, 0x00, 0x5b, 0x38, 0x32, 0x38, 0x27, 0xe1, 0x44, 0x89, 0x51, 0xf1, 0x0c, 0x84, 0x1a,    0x25, 0x9c, 0xb1, 0x6a, 0x43, 0x91, 0x46, 0x54, 0x21, 0xc6, 0x35, 0x6c, 0x84, 0x48, 0xb1, 0x62,    0x84, 0x88, 0xd5, 0xfe, 0x20, 0x48, 0x9c, 0xb3, 0x80, 0x24, 0x80, 0x28, 0xd2, 0x68, 0x50, 0xe3,    0x4f, 0xf0, 0x3c, 0xe0, 0x99, 0x9d, 0xdd, 0x41, 0x1d, 0xe0, 0x49, 0x04, 0x39, 0xc7, 0x33, 0xab,    0x73, 0x72, 0x64, 0xc8, 0x0c, 0x2b, 0xc1, 0xbf, 0x81, 0x4f, 0x06, 0x78, 0xd7, 0x80, 0x9a, 0xe9,    0x03, 0x01, 0x9b, 0x65, 0x38, 0xcc, 0x10, 0xfd, 0xff, 0x1f, 0x74, 0xb8, 0xf3, 0xf2, 0x48, 0x18,    0xc4, 0x11, 0x3e, 0x0b, 0x60, 0x47, 0x7c, 0x32, 0xc7, 0x5d, 0xaa, 0x00, 0xb3, 0x97, 0x00, 0x4d,    0x2e, 0xc1, 0xf1, 0xf8, 0x04, 0xe0, 0xf9, 0x9c, 0x70, 0x02, 0xcb, 0x1f, 0x04, 0x6a, 0x64, 0x86,    0xf6, 0x14, 0x4f, 0xeb, 0x45, 0xc0, 0xe7, 0x83, 0xc3, 0x62, 0x62, 0x21, 0xa4, 0x00, 0x42, 0xe3,    0x01, 0xff, 0xe0, 0x9f, 0x0e, 0x22, 0x3c, 0x17, 0x78, 0xbe, 0x3e, 0x36, 0xc0, 0x18, 0x90, 0xfd,    0x0a, 0x40, 0x08, 0xfe, 0xe2, 0x70, 0x44, 0xcf, 0x08, 0x11, 0x1e, 0x14, 0xd8, 0x11, 0x01, 0x27,    0xf0, 0xd8, 0x80, 0x86, 0xe6, 0x47, 0x80, 0xc8, 0x61, 0xcf, 0x24, 0xf4, 0xb1, 0x44, 0x89, 0x7c,    0x30, 0x3e, 0x50, 0x18, 0xe1, 0x14, 0x9f, 0x23, 0x7a, 0xbf, 0x54, 0x10, 0x02, 0xcb, 0x59, 0xa2,    0x4e, 0x1e, 0x96, 0x02, 0x22, 0x1b, 0x8b, 0xf4, 0x11, 0x83, 0x4a, 0xa1, 0x12, 0xfc, 0x69, 0x1d,    0xd6, 0x41, 0x9e, 0x5c, 0xec, 0xd7, 0x84, 0x73, 0xf4, 0x23, 0x84, 0x1d, 0x43, 0x78, 0x74, 0x08,    0x05, 0x1f, 0x0d, 0x65, 0x73, 0x54, 0x30, 0x0a, 0xe2, 0x81, 0x3b, 0x06, 0x84, 0x8c, 0x9c, 0x01,    0x50, 0x23, 0xf7, 0xf1, 0xe2, 0xf4, 0xde, 0x15, 0x7c, 0x22, 0x21, 0x07, 0x05, 0x68, 0x77, 0x02,    0x9f, 0x00, 0x38, 0x9c, 0x3f, 0x27, 0x14, 0x8e, 0x5c, 0x00, 0x4e, 0x20, 0x01, 0x97, 0x75, 0x10,    0x80, 0xf2, 0xff, 0x3f, 0x08, 0xe0, 0x2e, 0x19, 0x9e, 0xc2, 0xb9, 0x1c, 0xdf, 0xa1, 0x63, 0xcf,    0x01, 0xf0, 0x80, 0x3c, 0x77, 0x2b, 0x1d, 0x3f, 0x9d, 0x42, 0x88, 0x30, 0xd1, 0x0c, 0x8f, 0x89,    0x0d, 0xa1, 0x3f, 0x8c, 0xc7, 0xe3, 0x61, 0xf1, 0xe3, 0x80, 0x4f, 0x2a, 0x0c, 0xfb, 0xe4, 0x0f,    0xa6, 0xe8, 0xc1, 0x6b, 0xf6, 0xc7, 0xf4, 0xca, 0xe0, 0x41, 0x1b, 0xd6, 0x03, 0xe5, 0xb0, 0x46,    0x7b, 0x2a, 0xe1, 0x57, 0x0d, 0x4f, 0xcc, 0x18, 0x61, 0x7d, 0xc8, 0x00, 0x07, 0x20, 0xfe, 0x8a,    0xf0, 0x7e, 0xe1, 0x09, 0x18, 0x90, 0xcd, 0xf1, 0xd1, 0x05, 0x2c, 0xe7, 0x04, 0x3e, 0x88, 0x50,    0x91, 0x62, 0x1c, 0x6e, 0x8c, 0x90, 0x61, 0xa2, 0x3c, 0xce, 0xf8, 0xae, 0xc0, 0x14, 0xda, 0xf4,    0xa9, 0xd1, 0xa8, 0x55, 0x83, 0x32, 0x35, 0xca, 0x34, 0xa8, 0xd5, 0xa7, 0x52, 0x63, 0xc6, 0x4e,    0x28, 0x16, 0xf2, 0x4c, 0xd0, 0x70, 0x1d, 0x03, 0x84, 0x06, 0xa5, 0xd0, 0x49, 0xc1, 0xb1, 0x41,    0x04, 0xe4, 0xff, 0x3f    &#125;)&#125;//End of Device(WMI2)&#125;//End of Scope(\_SB)</code></pre><h2 id="MOF编译为BMF"><a href="#MOF编译为BMF" class="headerlink" title="MOF编译为BMF"></a>MOF编译为BMF</h2><p>Bios\Windows通过WMI相互通信需要借助MOF(经过编译后为BMF)文件，MOF描述了BIOS导出的WMI接口名字。按<a href="https://docs.microsoft.com/en-us/previous-versions/windows/hardware/design/dn614028(v=vs.85)">Windows Instrumentation: WMI and ACPI</a>的描述，MOF可能存在于2处：</p><ul><li>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WmiAcpi的MofImagePath指定；不过我在CML 7C43 Project MB中没有找到这样的设定，应该是应用层编写WMI Provider，生成dll会采取这种方式Register，所以不做讨论。</li><li>作为Buffer资源，将编译的MOF文件二进制BMF资源包进ASL Source  Code，嵌入到ACPI命名空间下。</li></ul><p>一个MOF描述文件，它经过mofcomp编译后，会生成二进制MOF资源文件。OEM厂商提取MOF资源文件中的字节流，嵌入到ACPI命名对象中。另外，WDK工具集中还提供wmimofck工具，该工具以MOF资源文件为输入，生成MOF所描述的WMI接口的测试脚本。下面两行命令将依次生成bmf文件(即MOF资源文件)和vbs接口测试脚本：<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383756674.png"></p><h2 id="ASL-Code部分逻辑"><a href="#ASL-Code部分逻辑" class="headerlink" title="ASL Code部分逻辑"></a>ASL Code部分逻辑</h2><p>BIOS在ASL Source Code中需要向WMI mapper声明设备:PNP0C14和_WDG对象。另外，OEM厂商或者IBV会在声明_WDG对象时，顺带声明嵌入式MOF对象。ACPI spec没有规定嵌入式MOF对象的名字，所以各家OEM会有不同的对象名。但是这并不是问题，它是有迹可循的：</p><ul><li>嵌入式MOF对象位于_WDG对象附近，并且具有形如”Name (WQxy, Buffer()){…”的ACPI对象定义，(其含义为：定义一个包含MOF资源的Buffer，并将该Buffer命名为WQxy。前缀WQ代表这是WMI查询接口，xy是2个16进制数值，用于标识WMI查询接口);</li><li>最重要的，该ACPI对象定义中包含了大量的16进制Byte，即BMF文件的字节流，并且开头4Byte是一个魔术字:”FOMB”，如下：<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383810323.png"><h1 id="OS下调用"><a href="#OS下调用" class="headerlink" title="OS下调用"></a>OS下调用</h1><h2 id="Related-Tool"><a href="#Related-Tool" class="headerlink" title="Related Tool"></a>Related Tool</h2>为了验证WMI功能，我们可以使用WMICodeCreator，它是Microsoft的免费工具。 下载：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=8572">WMI Code Creator v1.0</a>，使用WMI Code Creator工具可以生成VBScript，C＃和VB .NET代码，这些代码使用WMI完成管理任务，例如查询管理数据，从WMI类执行方法或使用WMI接收事件通知。<br>或者也可用第三方开源软件<a href="https://github.com/vinaypamnani/wmie2/releases">WMI Explorer</a>来对WMI进行管理查询。<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383882848.png"><h2 id="指定method调用"><a href="#指定method调用" class="headerlink" title="指定method调用"></a>指定method调用</h2>以管理员身份运行WMICodeCreator.exe，来验证和执行BIOS提供的WMI接口，先执行Query for data from a WMI class，再执行Excute a method，Namespace选择root\WMI，Classes选择MyClass。<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383902165.png"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383920078.png"><h2 id="VB-Script调用"><a href="#VB-Script调用" class="headerlink" title="VB Script调用"></a>VB Script调用</h2><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383950989.png"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383964733.png"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> WMI,CIM,MOF,ASL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StatusCode分析</title>
      <link href="2021/08/01/StatusCode/"/>
      <url>2021/08/01/StatusCode/</url>
      
        <content type="html"><![CDATA[<h1 id="StatusCode是什么"><a href="#StatusCode是什么" class="headerlink" title="StatusCode是什么"></a>StatusCode是什么</h1><blockquote><p>StatusCode即状态码，它能让系统组件报告它们的当前状态,比如当前正在进行CPU初始化、内存初始化等，你将很清楚系统何时运行在哪，出现何种错误，这样将极利于我们调试</p></blockquote><h1 id="为什么需要StatusCode"><a href="#为什么需要StatusCode" class="headerlink" title="为什么需要StatusCode"></a>为什么需要StatusCode</h1><blockquote><p>由于BIOS涉及规范与组件极多，我们无法了解BIOS所有内容，同时，大量的组件导致后期维护极为困难，若没有状态码，我们很难清除到底是哪个组件的哪类Bug导致这个问题，若对应组件会报告它的状态码，无疑对我们维护带来极大的便利</p></blockquote><blockquote><p>没有状态码，当前出现了一个错误导致系统直接hang机了，此时要想调试这个错误极其困难（考虑一种情况，你的主板没有蜂鸣器，同时没有80卡，此时由于一些系统错误导致整个系统开不了机，请问怎么办。此时，估计你的想法是，我怎么知道怎么办，我还想问别人呢。），当存在状态码时，系统出现一个错误导致系统直接hang机，状态码指示内存报告了一个错误状态，这样，我们一下就能定位错误，对于我们调试是有极大帮助的</p></blockquote><h1 id="怎样使用StatusCode"><a href="#怎样使用StatusCode" class="headerlink" title="怎样使用StatusCode"></a>怎样使用StatusCode</h1><blockquote><p>报告状态码的函数是 ReportStatusCode()，ReportStatusCode()主要的参数有5个，另外一个参数是This指针，This指针对于DXE阶段的ReportStatusCode()不存在。<br>分为：PEI阶段的ReportStatusCode，DXE阶段的ReportStatusCode，Runtime阶段的ReportStatusCode</p></blockquote><ul><li><p>PEI阶段通过Locate EFI_PEI_REPORT_PROGRESS_CODE_PPI_GUID获得句柄handle,在通过handle-&gt;ReportStatusCode()调用。或通过PeiService-&gt;ReportStatusCode()来调用。 </p></li><li><p>DXE阶段通过Locate EFI_STATUS_CODE_RUNTIME_PROTOCOL_GUID获得句柄handle，再通过handle-&gt;ReportStatusCode()调用。</p></li><li><p>Runtime阶段是通过Locate EFI_SMM_STATUS_CODE_PROTOCOL_GUID获得句柄handle，再通过handle-&gt;ReportStatusCode()调用。</p></li></ul><h2 id="ReportStatusCode"><a href="#ReportStatusCode" class="headerlink" title="ReportStatusCode()"></a>ReportStatusCode()</h2><ul><li>pPEI-&gt;ReportStatusCode()或PeiServices-&gt;ReportStatusCode() </li><li>pDXE-&gt;ReportStatusCode() </li><li>pSMM-&gt;ReportStatusCode() </li></ul><h2 id="ReportStatusCode-主要参数"><a href="#ReportStatusCode-主要参数" class="headerlink" title="ReportStatusCode()主要参数"></a>ReportStatusCode()主要参数</h2><ul><li><p>EFI_STATUS_CDOE_TYPE     Type </p></li><li><p>EFI_STATAS_CODE_VALUE    Value </p></li><li><p>UINT32                                      Instance </p></li><li><p>EFI_GUID                                  *CallerrId </p></li><li><p>EFI_STATUS_CODE_DATA      *Data </p><h2 id="EFI-STATUS-CODE-TYPE-Type"><a href="#EFI-STATUS-CODE-TYPE-Type" class="headerlink" title="EFI_STATUS_CODE_TYPE Type"></a>EFI_STATUS_CODE_TYPE Type</h2><blockquote><p>这个参数指明 Status Code 的类型，它是4字节变量，由3部分组成，分别是：StatusCode类别、StatusCode严重性、StatusCode保留部分</p></blockquote></li><li><p>类别占最低8位，当前有效的类别是EFI_PROGRESS_CODE(进程码)、EFI_ERROR_CODE(错误码)、EFI_DEBUG_CODE(调试码)。</p><ul><li>  进程码(EFI_PROGRESS_CODE)用于说明当前处在某一过程中，如在跑 PEIM 或在跑 DXE 。 </li><li>  错误码(EFI_ERROR_CODE)用于说明某一组件出现了错误，如内存错误等。 </li><li>  调试码(EFI_DEBUG_CODE)是为调试目的而认为添加，非调试状态，屏蔽。 </li></ul></li><li><p>严重性占最高8位，当前有效的严重性是EFI_ERROR_MINOR(小错误)、EFI_ERROR_MAJOR(主错误)、EFI_ERROR_UNRECOVERED(未恢复)、EFI_ERROR_UNCONTAINED(未包含)。 </p></li><li><p>保留占中间16位，暂时未使用</p></li></ul><pre><code> ////// Status Code Type Definition.///typedef UINT32  EFI_STATUS_CODE_TYPE;////// A Status Code Type is made up of the code type and severity./// All values masked by EFI_STATUS_CODE_RESERVED_MASK are/// reserved for use by this specification.//////@&#123;#define EFI_STATUS_CODE_TYPE_MASK     0x000000FF#define EFI_STATUS_CODE_SEVERITY_MASK 0xFF000000#define EFI_STATUS_CODE_RESERVED_MASK 0x00FFFF00///@&#125;////// Definition of code types. All other values masked by/// EFI_STATUS_CODE_TYPE_MASK are reserved for use by/// this specification.//////@&#123;#define EFI_PROGRESS_CODE             0x00000001#define EFI_ERROR_CODE                0x00000002#define EFI_DEBUG_CODE                0x00000003///@&#125;////// Definitions of severities, all other values masked by/// EFI_STATUS_CODE_SEVERITY_MASK are reserved for use by/// this specification./// Uncontained errors are major errors that could not contained/// to the specific component that is reporting the error./// For example, if a memory error was not detected early enough,/// the bad data could be consumed by other drivers.//////@&#123;#define EFI_ERROR_MINOR               0x40000000#define EFI_ERROR_MAJOR               0x80000000#define EFI_ERROR_UNRECOVERED         0x90000000#define EFI_ERROR_UNCONTAINED         0xa0000000///@&#125;</code></pre><h2 id="EFI-STATUS-CODE-VALUE-Value"><a href="#EFI-STATUS-CODE-VALUE-Value" class="headerlink" title="EFI_STATUS_CODE_VALUE Value"></a>EFI_STATUS_CODE_VALUE Value</h2><blockquote><p>这个参数是StatusCode的值，它是4字节变量，由3部分组成，分别是：类别(最高8位)、子类(次高8位)、操作(最低16位)。</p></blockquote><blockquote><p>类型分为四个大类：电脑单元、用户可读写外设、IO总线、软件。前三者为硬件类，最后一个为软件类。</p></blockquote><blockquote><p>具体组合可参考PI规范卷3,第6小结</p></blockquote><pre><code>#define EFI_STATUS_CODE_CLASS_MASK          0xFF000000 #define EFI_STATUS_CODE_SUBCLASS_MASK       0x00FF0000 #define EFI_STATUS_CODE_OPERATION_MASK      0x0000FFFF </code></pre><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604384875690.png" alt="StatusCode"></p><h2 id="UINT32-Instance"><a href="#UINT32-Instance" class="headerlink" title="UINT32 Instance"></a>UINT32 Instance</h2><blockquote><p>这个是用来指明状态码的实例，有些组件可能有相同的Type和Value，例如PEI Code，可能会都Report正在运行PEI Code的StatusCode，此时可通过Instance来区分具体哪个PEI Code Report了Status。</p></blockquote><blockquote><p>当存在多处理器时，它可以指明具体哪个处理器，哪个组件报告的状态码。</p></blockquote><h2 id="EFI-GUID-CallerId"><a href="#EFI-GUID-CallerId" class="headerlink" title="EFI_GUID *CallerId"></a>EFI_GUID *CallerId</h2><blockquote><p>指明谁报告了状态码，比如程序员A和程序员B，此参数对不同调用者调用不同的状态码驱动。例如，此参数我们可以这样运用：当此参数为NULL或不为我指定的Guid，跳过我们的状态码函数。</p></blockquote><h2 id="EFI-STATUS-CODE-DATA-Data"><a href="#EFI-STATUS-CODE-DATA-Data" class="headerlink" title="EFI_STATUS_CODE_DATA *Data"></a>EFI_STATUS_CODE_DATA *Data</h2><blockquote><p>这个参数附带一些附加的状态数据，如字符串调试信息，时间等，以让我们更详细的了解当前状态</p></blockquote><blockquote><p>这里主要讲解 EFI_STATUS_CODE_DATA_TYPE_STRING，系统使用的丢字符串信息的 Debug 函数都是利用这个结构来丢字符串</p></blockquote><blockquote><p>具体的数据可参考PI规范卷3，第6小结</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604384875667.png"></p><h1 id="Code中关于StatusCode的实现"><a href="#Code中关于StatusCode的实现" class="headerlink" title="Code中关于StatusCode的实现"></a>Code中关于StatusCode的实现</h1><blockquote><p>AptioV的Code中StatusCode是作为一个ModulePart包含在Core Module中，完整的名字是AmiStatusCode。StatusCode需要做初始化，初始化之后StatusCode才能正常使用。</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604384875679.png" alt="AmiStatusCode"></p><h2 id="StatusCode初始化"><a href="#StatusCode初始化" class="headerlink" title="StatusCode初始化"></a>StatusCode初始化</h2><blockquote><p>StatusCode初始化是通过PeiStatusCodeInitialize和DxeStatusCodeInitialize完成的。这两个函数是Elink，我们可以根据需要挂着我们所需的初始化函数。</p></blockquote><ul><li>PeiStatusCodeInitialize</li><li>DxeStatusCodeInitialize</li></ul><h2 id="AmiStatusCode组成"><a href="#AmiStatusCode组成" class="headerlink" title="AmiStatusCode组成"></a>AmiStatusCode组成</h2><blockquote><p>AmiStatusCode主要由3部分组成，分别是StatusCodePei，StatusCodeDxe，StatusCodeSmm</p></blockquote><ul><li><p>StatusCodePei通过调用StatusCodePei.c中的PeiInitStatusCode()完成Install PEI StatusCode Protocol。</p></li><li><p>StatusCodeDxe通过调用StatusCodeDxe.c中的DxeRuntimeInitStatusCode()完成Install DXE StatusCode Protocol。 </p></li><li><p>StatusCodeSmm通过调用StatusCodeSmm.c中的SmmInitStatusCode()完成Install SMM StatusCode Protocol。</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604384875680.png"></p><h2 id="ReportStatusCode-最终实现函数"><a href="#ReportStatusCode-最终实现函数" class="headerlink" title="ReportStatusCode()最终实现函数"></a>ReportStatusCode()最终实现函数</h2><blockquote><p>ReportStatusCode()最终的实现函数是StatusCodeCommon.c中的AmiReportStatusCode()函数。AmiReportStatusCode()主要由三种ReportStatusCode()的方式，分别是SimpleStatusReport()、StringStatusReport()、MiscStatusReport()。另加一个错误处理，PerformErrorCodeAction()。StatusCode是通过Elink方式来进行实际操作的，因此具有很强的扩展性。</p></blockquote></li></ul><pre><code> /**    Top level status code reporting routine exposed by the status code protocol/PPI.    Calls the various types of status code handlers    (SimpleStatusReport, StringStatusReport, MiscStatusReport, PerformErrorCodeAction)    Generates string from the status code data to pass to StringStatusReport function.    @param PeiServices pointer to the PEI Boot Services table    @param Type the type and severity of the error that occurred    @param Value the Class, subclass and Operation that caused the error    @param Instance     @param CallerId OPTIONAL - The GUID of the caller function    @param Data OPTIONAL - the extended data field that contains additional info    @retval EFI_STATUS**/EFI_STATUS AmiReportStatusCode (    IN VOID *PeiServices,    IN EFI_STATUS_CODE_TYPE Type, IN EFI_STATUS_CODE_VALUE Value,    IN UINT32 Instance, IN  EFI_GUID *CallerId OPTIONAL,    IN EFI_STATUS_CODE_DATA *Data OPTIONAL, UINT8 *String)&#123;    SimpleStatusReport(PeiServices,Type,Value);//#if STRING_STATUS_SUPPORT    String[0] = &#39;\0&#39;;    CreateString(Type, Value, Data, String);    // step through the useable data and display information as needed    // Serial data    if (String[0] != &#39;\0&#39;) StringStatusReport(PeiServices,(CHAR8*)String);//#endif    MiscStatusReport(PeiServices,Type,Value,Instance,CallerId,Data);    if (STATUS_CODE_TYPE(Type)==EFI_ERROR_CODE)    PerformErrorCodeAction(PeiServices,Type,Value);    return EFI_SUCCESS;&#125;</code></pre><h2 id="SimpleStatusReport"><a href="#SimpleStatusReport" class="headerlink" title="SimpleStatusReport()"></a>SimpleStatusReport()</h2><blockquote><p>SimpleStatusReport()即简单状态报告，它只能报告StatusCode的类型和值，报告简单状态的方式分为两大种，1）Checkpoint，通过80 port报告状态码。2）Beep，通过蜂鸣器报告状态码。SimpleStatusCode存在一个StatusCodeMap，它列出所有简单状态码，包括Checkpoint与Beep，可以查看StatusCodeMap.c。</p></blockquote><ul><li>PeiReportSimpleStatus</li><li>DxeReportSimpleStatus</li><li>RtReportSimpleStatus</li><li>SmmReportSimpleStatus</li></ul><h2 id="StringStatusReport"><a href="#StringStatusReport" class="headerlink" title="StringStatusReport()"></a>StringStatusReport()</h2><blockquote><p>StringStatusReport()即字符串状态报告，串口丢出的字符串调试信息就是通过这个函数丢出的，Debug相关的丢字符串的函数也是通过这个函数丢出的。<br>这里我们需要注意的是：在我们通过Debug函数丢字符串信息时，Debug函数会使用EFI_STATUS_CODE_STRING_DATA结构对字符串进行打包处理。这也是我们使用一些自定义的丢字符串函数不能丢出的原因。</p></blockquote><ul><li>PeiReportStringStatus</li><li>DxeReportStringStatus</li><li>RtReportStringStatus</li><li>SmmReportStringStatus</li></ul><h2 id="MiscStatusReport"><a href="#MiscStatusReport" class="headerlink" title="MiscStatusReport()"></a>MiscStatusReport()</h2><blockquote><p>MiscStatusReport()即混合状态码，它包含ReportStatusCode()的全部5个参数，因此可以报告最详细的状态。当前DXE阶段使用它保存完整StatusCode信息到DataHub结构中。</p></blockquote><ul><li>PeiReportMiscStatus</li><li>DxeReportMiscStatus</li><li>RtReportMiscStatus</li><li>SmmReportMiscStatus</li></ul><h2 id="PerformErrorCodeAction"><a href="#PerformErrorCodeAction" class="headerlink" title="PerformErrorCodeAction()"></a>PerformErrorCodeAction()</h2><blockquote><p>PerformErrorCodeAction()即执行错误码动作，它包含ReportStatusCode()参数的类型和值，根据错误类型和值执行相应错误处理动作。</p></blockquote><ul><li>PeiErrorCodeActions</li><li>RtErrorCodeActions</li><li>SmmErrorCodeActions</li><li>DxeErrorCodeActions</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows Firmware Update Guide</title>
      <link href="2021/08/01/WFU/"/>
      <url>2021/08/01/WFU/</url>
      
        <content type="html"><![CDATA[<h1 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h1><ul><li>CometLake 7C43 Project:M80T MB with UEFI Windows 10 System .</li></ul><p>- Product: Aptio 5.x.</p><h1 id="Test-Objective"><a href="#Test-Objective" class="headerlink" title="Test Objective:"></a>Test Objective:</h1><ul><li>Confirm that Firmware can be updated using Windows architecture.</li></ul><h1 id="Test-Procedures"><a href="#Test-Procedures" class="headerlink" title="Test Procedures:"></a>Test Procedures:</h1><ul><li>System With SDK and WINDDK Installed</li></ul><blockquote><p>下载并安装最新WDK和SDK到测试机</p></blockquote><p>WDK：该驱动程序开发工具包（WDK）是从软件工具集微软，使开发设备驱动程序针对微软的Windows平台。它包括用于驱动程序开发人员的文档，样本，构建环境和工具。用于驱动程序开发的完整工具集还需要以下内容：编译器Visual Studio，Windows SDK和Windows HLK。</p><p>SDK：Microsoft Windows SDK及其先前的Platform SDK和.NET Framework SDK是Microsoft的软件开发工具包（SDK），其中包含开发Microsoft Windows和.NET Framework应用程序所需的文档，头文件，库，示例和工具。Platform SDK专门开发用于Windows 2000，XP和Windows Server 2003的应用程序。.NET Framework SDK专门用于开发用于 .NET Framework 1.1和.NET Framework 2.0。Windows SDK是这两者的继承者，并支持为Windows XP和更高版本以及.NET Framework 3.0和更高版本开发应用程序。</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369144037.png"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369151637.png"></p><ul><li>Create a folder C:\WFU and place *.inf and <em>.cap file in it(</em>.cap file built from project source)</li></ul><blockquote><p>*.inf文件示例如下，具体参考微软官网INF相关说明</p></blockquote><pre><code>[Version]Signature   = &quot;$WINDOWS NT$&quot;Provider    = %Provider%Class       = FirmwareClassGuid   = &#123;f2e7dd72-6468-4e36-b6f1-6488f42c1b52&#125;DriverVer   = 07/28/2020,1.0.0.43CatalogFile = M2TKT2CA.catPnpLockdown = 1[Manufacturer]%MfgName% = Firmware,NTamd64[Firmware.NTamd64]%FirmwareDesc% = Firmware_Install,UEFI\RES_&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;[Firmware_Install.NT]CopyFiles = Firmware_CopyFiles[Firmware_CopyFiles]M2TKT2CA.cap[Firmware_Install.NT.Hw]AddReg = Firmware_AddReg[Firmware_AddReg]HKR,,FirmwareId,,&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;HKR,,FirmwareVersion,%REG_DWORD%,0x0001002CHKR,,FirmwareFilename,,&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;\M2TKT2CA.cap[SourceDisksNames]1 = %DiskName%[SourceDisksFiles]M2TKT2CA.cap = 1[DestinationDirs]DefaultDestDir = %DIRID_WINDOWS%,Firmware\&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;[Strings]; localizableProvider     = &quot;Lenovo Ltd.&quot;MfgName      = &quot;Lenovo Ltd.&quot;FirmwareDesc = &quot;ThinkCentre M90t/s, M80t/s, M70t/s, M993t, M930t/s, M737t, QT M630, YT P780 System Firmware 1.0.0.43&quot;DiskName     = &quot;Firmware Update&quot;; non-localizableDIRID_WINDOWS = 10REG_DWORD     = 0x00010001</code></pre><ul><li><p>Change related cap and cat file name  in *.inf file, make these match the prefix of your cap file name, example M2TKT2CA.cat  and M2TKT2CA.cap （如下图2、4、8、9处）<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369166799.png"></p></li><li><p>将M2TKT2CA.inf文件的GUID替换为BIOS Source Code里对应的需要更新Firmware GUID（如上图3、5、7、10处）<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369174098.png"></p></li><li><p>Edit M2TKT2CA.inf file, find string “DriverVer=07/10/2020,1.0.0.42” and increase last two digits to 43, must increment for each flash（如上图1、11处）</p></li><li><p>Edit M2TKT2CA.inf, find string “HKR,,FirmwareVersion,%REG_DWORD%,0x0001002B and increase to 0x0001002C”， must increment for each flash.（如上图6处）<br>(Note: 0x2C is hex values of BIOS version, ex: BIOS version is 043, the hex values is 0x2C)</p></li><li><p>以管理员身份运行PowerShell，切换目录到C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x86</p></li><li><p>Run .\makecert.exe -r -pe -a sha256 -eku 1.3.6.1.5.5.7.3.3 -n CN=Foo -sv fwu.pvk fwu.cer</p></li><li><p>Password window will appear, set and verify this password: wfutest123<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370942326.png"></p></li></ul><ul><li><p>In powershell run .\pvk2pfx.exe -pvk fwu.pvk -spc fwu.cer -pi wfutest123 -spc fwu.cer -pfx fwu.pfx</p></li><li><p>If a .cat with your BIOS name, example m2tkt2ca.cat exists in the Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x86 folder delete it.</p></li><li><p>In powershell run .\Inf2Cat.exe /driver:c:\WFU /os:10_x64</p></li><li><p>In powershell run .\signtool sign /fd sha256 /f fwu.pfx /p wfutest123 C:\WFU\M2TKT2CA.cat</p></li><li><p>In powershell run .\fwu.cer<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370915317.png"></p></li></ul><ul><li><p>A Window should be displayed. Install certificate, local machine, next, browse, select Trusted Root Certification Authorities<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370903085.png"></p></li><li><p>In powershell run bcdedit.exe /set testsigning on</p></li><li><p>Right click My computer -&gt; Manage -&gt; Device Manager -&gt; Firmware -&gt; Update Driver Software -&gt; Browse -&gt; Let me Pick -&gt; Hard Disk -&gt; Select inf -&gt; restart<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370891225.png"></p></li></ul><ul><li>Firmware update should complete without errors.</li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370868293.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370603974.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> WFU,cab,证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ventoy</title>
      <link href="2021/08/01/Ventoy/"/>
      <url>2021/08/01/Ventoy/</url>
      
        <content type="html"><![CDATA[<h1 id="Ventoy简介"><a href="#Ventoy简介" class="headerlink" title="Ventoy简介"></a>Ventoy简介</h1><p> Ventoy是一个制作可启动U盘的开源工具。有了Ventoy你就无需反复地格式化U盘，你只需要把ISO文件拷贝到U盘里面就可以启动了，无需其他操作。 你可以一次性拷贝很多个不同类型的ISO文件，在启动时Ventoy会显示一个菜单来选择(<a href="https://www.ventoy.net/cn/screenshot.html">截图</a>)。 无差异支持Legacy BIOS和UEFI模式。目前已经测试了各类超过260+ 个ISO文件(<a href="https://www.ventoy.net/cn/isolist.html">列表</a>). 同时提出了”Ventoy Compatible”的概念，若被支持则理论上可以启动任何ISO文件.</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><ul><li><p><a href="https://github.com/ventoy/Ventoy">Github开源地址</a></p><ul><li> <a href="https://www.ventoy.net/cn/download.html">下载地址</a></li></ul></li><li><p> 安装到启动盘</p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967090645.png" alt="安装到U盘"></p><h1 id="放置ISO镜像文件"><a href="#放置ISO镜像文件" class="headerlink" title="放置ISO镜像文件"></a>放置ISO镜像文件</h1><h2 id="镜像下载站点"><a href="#镜像下载站点" class="headerlink" title="镜像下载站点"></a>镜像下载站点</h2><ul><li>  <a href="https://next.itellyou.cn/">MSDN</a></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531519.png"></p><ul><li>  <a href="https://developer.aliyun.com/mirror/">阿里云镜像站</a></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531520.png"></p><h2 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h2><blockquote><p>镜像可放在根目录，也可建立文件夹管理，可按需求分类</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967174941.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967207747.png"></p><h1 id="配置json文件和主题（可忽略）"><a href="#配置json文件和主题（可忽略）" class="headerlink" title="配置json文件和主题（可忽略）"></a>配置json文件和主题（可忽略）</h1><ul><li><p>  <a href="https://www.ventoy.net/cn/plugin_entry.html">官方教程</a></p></li><li><p>  个人示例</p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967274942.png"></p><ul><li>ventoy.json<pre><code>&#123;   &quot;theme&quot;: &#123;      &quot;file&quot;: &quot;/ventoy/theme/theme.txt&quot;,      &quot;gfxmode&quot;: &quot;1024x768&quot;,      &quot;ventoy_left&quot;: &quot;42%&quot;,      &quot;ventoy_top&quot;: &quot;100%&quot;,      &quot;ventoy_color&quot;: &quot;#000000&quot;  &#125; ,&quot;menu_alias&quot; :   [      &#123;          &quot;image&quot;: &quot;/ISO/18363.418.191007-0143.19h2_release_svc_refresh_CLIENT_CONSUMER_x64FRE_en-us.iso&quot;,          &quot;alias&quot;: &quot;Win10 19H2英文版&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/19041.208.200420-2019.vb_release_svc_refresh_CLIENT_BUSINESS_VOL_x64FRE_en-us.iso&quot;,          &quot;alias&quot;: &quot;Win10 20H1英文版&quot;      &#125;,              &#123;          &quot;image&quot;: &quot;/ISO/cn_windows_10_business_editions_version_1909_updated_jan_2020_x64_dvd_b3e1f3a6.iso&quot;,          &quot;alias&quot;: &quot;Win10 1909中文版&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/rhel-8.1-x86_64-dvd.iso&quot;,          &quot;alias&quot;: &quot;ReaHat 8.1&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/ubuntu-18.04.3-desktop-amd64.iso&quot;,          &quot;alias&quot;: &quot;Ubuntu 18.04.03&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/ubuntu-20.04-desktop-amd64.iso&quot;,          &quot;alias&quot;: &quot;Ubuntu 20.04&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/wepe_64.iso&quot;,          &quot;alias&quot;: &quot;微PE&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/EasyU_v3.3.iso&quot;,          &quot;alias&quot;: &quot;优启通PE&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/19H2_Bak.wim&quot;,          &quot;alias&quot;: &quot;Win10 19H2英文系统备份&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/1909_Zh_Cn_Backup.wim&quot;,          &quot;alias&quot;: &quot;Win10 19H2中文系统备份&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/en_windows_server_2016_x64_dvd_9718492.iso&quot;,          &quot;alias&quot;: &quot;Win10 Server 2016&quot;      &#125;                  ]     &#125;</code></pre></li><li>  <a href="https://www.gnome-look.org/p/1009236/">主题地址</a></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531602.png"></p><h1 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h1><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531607.png"></p><blockquote><p>通过主板快捷键可以从制作的VentoyU盘启动，选择可启动镜像即可进入OS安装或PE等维护工具</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HOB</title>
      <link href="2021/08/01/HOB/"/>
      <url>2021/08/01/HOB/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="HOB简介"><a href="#HOB简介" class="headerlink" title="HOB简介"></a>HOB简介</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>HOB是Hand-Off Block的缩写。是PEI阶段向DXE传递系统信息的手段。PEI阶段构建一些HOB结构，然后将其作为参数传给DXE阶段函数，DXE Core会根据其使用平台相关资源。</p><p>HOB是系列的连续的内存结构体，可以认为其由三部分构成：第一部分，是PHIT头，它描述了HOB的起始地址以及总的内存使用；第二部分是各个Hob列表，DXE阶段会根据这一部分获取相关资源；第三部分是结束部分。</p><hr><p>   <img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603960797897.png"></p><p>  <img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603960797878.png" alt="HOB List"></p><hr><h2 id="相关Spec"><a href="#相关Spec" class="headerlink" title="相关Spec"></a>相关Spec</h2><ul><li>PI Spec(卷一 4.4 HOB Services小节，规范HOB PeiService相关的方法,Pi卷三4/5章节)</li><li><a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/unified-extensible-firmware-interface/efi-specifications-general-technology.html">EFI Spec</a>（规范HOB的数据结构）</li></ul><h1 id="HOB的数据结构表征-PiHob-h"><a href="#HOB的数据结构表征-PiHob-h" class="headerlink" title="HOB的数据结构表征(PiHob.h)"></a>HOB的数据结构表征(PiHob.h)</h1><h2 id="EFI-HOB-GENERIC-HEADER"><a href="#EFI-HOB-GENERIC-HEADER" class="headerlink" title="EFI_HOB_GENERIC_HEADER"></a>EFI_HOB_GENERIC_HEADER</h2><blockquote><p>描述HOB内部数据的格式和大小,所有HOB都必须包含此通用HOB标头,以便可以找到下一个HOB</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">////// Describes the format and size of the data inside the HOB./// All HOBs must contain this generic HOB header.///typedef struct &#123;  ///  /// Identifies the HOB data structure type.  ///  UINT16    HobType;  ///  /// The length in bytes of the HOB.  ///  UINT16    HobLength;  ///  /// This field must always be set to zero.  ///  UINT32    Reserved;&#125; EFI_HOB_GENERIC_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HobType"><a href="#HobType" class="headerlink" title="HobType"></a>HobType</h2><pre class="line-numbers language-c++"><code class="language-c++">//// HobType of EFI_HOB_GENERIC_HEADER.//#define EFI_HOB_TYPE_HANDOFF              0x0001#define EFI_HOB_TYPE_MEMORY_ALLOCATION    0x0002#define EFI_HOB_TYPE_RESOURCE_DESCRIPTOR  0x0003#define EFI_HOB_TYPE_GUID_EXTENSION       0x0004#define EFI_HOB_TYPE_FV                   0x0005#define EFI_HOB_TYPE_CPU                  0x0006#define EFI_HOB_TYPE_MEMORY_POOL          0x0007#define EFI_HOB_TYPE_FV2                  0x0009#define EFI_HOB_TYPE_LOAD_PEIM_UNUSED     0x000A#define EFI_HOB_TYPE_UEFI_CAPSULE         0x000B#define EFI_HOB_TYPE_FV3                  0x000C#define EFI_HOB_TYPE_UNUSED               0xFFFE#define EFI_HOB_TYPE_END_OF_HOB_LIST      0xFFFF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="PHIT-HOB"><a href="#PHIT-HOB" class="headerlink" title="PHIT HOB"></a>PHIT HOB</h2><pre><code>////// Contains general state information used by the HOB producer phase./// This HOB must be the first one in the HOB list.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_HANDOFF.  ///  EFI_HOB_GENERIC_HEADER  Header;  ///  /// The version number pertaining to the PHIT HOB definition.  /// This value is four bytes in length to provide an 8-byte aligned entry  /// when it is combined with the 4-byte BootMode.  ///  UINT32                  Version;  ///  /// The system boot mode as determined during the HOB producer phase.  ///  EFI_BOOT_MODE           BootMode;  ///  /// The highest address location of memory that is allocated for use by the HOB producer  /// phase. This address must be 4-KB aligned to meet page restrictions of UEFI.  ///  EFI_PHYSICAL_ADDRESS    EfiMemoryTop;  ///  /// The lowest address location of memory that is allocated for use by the HOB producer phase.  ///  EFI_PHYSICAL_ADDRESS    EfiMemoryBottom;  ///  /// The highest address location of free memory that is currently available  /// for use by the HOB producer phase.  ///  EFI_PHYSICAL_ADDRESS    EfiFreeMemoryTop;  ///  /// The lowest address location of free memory that is available for use by the HOB producer phase.  ///  EFI_PHYSICAL_ADDRESS    EfiFreeMemoryBottom;  ///  /// The end of the HOB list.  ///  EFI_PHYSICAL_ADDRESS    EfiEndOfHobList;&#125; EFI_HOB_HANDOFF_INFO_TABLE;</code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-HEADER"><a href="#EFI-HOB-MEMORY-ALLOCATION-HEADER" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_HEADER"></a>EFI_HOB_MEMORY_ALLOCATION_HEADER</h2><pre class="line-numbers language-C"><code class="language-C">////// EFI_HOB_MEMORY_ALLOCATION_HEADER describes the/// various attributes of the logical memory allocation. The type field will be used for/// subsequent inclusion in the UEFI memory map.///typedef struct &#123;  ///  /// A GUID that defines the memory allocation region's type and purpose, as well as  /// other fields within the memory allocation HOB. This GUID is used to define the  /// additional data within the HOB that may be present for the memory allocation HOB.  /// Type EFI_GUID is defined in InstallProtocolInterface() in the UEFI 2.0  /// specification.  ///  EFI_GUID              Name;  ///  /// The base address of memory allocated by this HOB. Type  /// EFI_PHYSICAL_ADDRESS is defined in AllocatePages() in the UEFI 2.0  /// specification.  ///  EFI_PHYSICAL_ADDRESS  MemoryBaseAddress;  ///  /// The length in bytes of memory allocated by this HOB.  ///  UINT64                MemoryLength;  ///  /// Defines the type of memory allocated by this HOB. The memory type definition  /// follows the EFI_MEMORY_TYPE definition. Type EFI_MEMORY_TYPE is defined  /// in AllocatePages() in the UEFI 2.0 specification.  ///  EFI_MEMORY_TYPE       MemoryType;  ///  /// Padding for Itanium processor family  ///  UINT8                 Reserved[4];&#125; EFI_HOB_MEMORY_ALLOCATION_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION"><a href="#EFI-HOB-MEMORY-ALLOCATION" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION"></a>EFI_HOB_MEMORY_ALLOCATION</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Describes all memory ranges used during the HOB producer</span><span class="token comment" spellcheck="true">/// phase that exist outside the HOB list. This HOB type</span><span class="token comment" spellcheck="true">/// describes how memory is used, not the physical attributes of memory.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER            Header<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the</span>  <span class="token comment" spellcheck="true">/// various attributes of the logical memory allocation.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//</span>  <span class="token comment" spellcheck="true">// Additional data pertaining to the "Name" Guid memory</span>  <span class="token comment" spellcheck="true">// may go here.</span>  <span class="token comment" spellcheck="true">//</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_MEMORY_ALLOCATION<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-STACK"><a href="#EFI-HOB-MEMORY-ALLOCATION-STACK" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_STACK"></a>EFI_HOB_MEMORY_ALLOCATION_STACK</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Describes the memory stack that is produced by the HOB producer</span><span class="token comment" spellcheck="true">/// phase and upon which all post-memory-installed executable</span><span class="token comment" spellcheck="true">/// content in the HOB producer phase is executing.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER            Header<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the</span>  <span class="token comment" spellcheck="true">/// various attributes of the logical memory allocation.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_MEMORY_ALLOCATION_STACK<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-BSP-STORE"><a href="#EFI-HOB-MEMORY-ALLOCATION-BSP-STORE" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_BSP_STORE"></a>EFI_HOB_MEMORY_ALLOCATION_BSP_STORE</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Defines the location of the boot-strap</span><span class="token comment" spellcheck="true">/// processor (BSP) BSPStore ("Backing Store Pointer Store").</span><span class="token comment" spellcheck="true">/// This HOB is valid for the Itanium processor family only</span><span class="token comment" spellcheck="true">/// register overflow store.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER            Header<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the</span>  <span class="token comment" spellcheck="true">/// various attributes of the logical memory allocation.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_MEMORY_ALLOCATION_BSP_STORE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-MODULE"><a href="#EFI-HOB-MEMORY-ALLOCATION-MODULE" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_MODULE"></a>EFI_HOB_MEMORY_ALLOCATION_MODULE</h2><pre><code>////// Defines the location and entry point of the HOB consumer phase.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.  ///  EFI_HOB_GENERIC_HEADER            Header;  ///  /// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the  /// various attributes of the logical memory allocation.  ///  EFI_HOB_MEMORY_ALLOCATION_HEADER  MemoryAllocationHeader;  ///  /// The GUID specifying the values of the firmware file system name  /// that contains the HOB consumer phase component.  ///  EFI_GUID                          ModuleName;  ///  /// The address of the memory-mapped firmware volume  /// that contains the HOB consumer phase firmware file.  ///  EFI_PHYSICAL_ADDRESS              EntryPoint;&#125; EFI_HOB_MEMORY_ALLOCATION_MODULE;</code></pre><h2 id="EFI-HOB-RESOURCE-DESCRIPTOR"><a href="#EFI-HOB-RESOURCE-DESCRIPTOR" class="headerlink" title="EFI_HOB_RESOURCE_DESCRIPTOR"></a>EFI_HOB_RESOURCE_DESCRIPTOR</h2><pre><code>////// Describes the resource properties of all fixed,/// nonrelocatable resource ranges found on the processor/// host bus during the HOB producer phase.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_RESOURCE_DESCRIPTOR.  ///  EFI_HOB_GENERIC_HEADER      Header;  ///  /// A GUID representing the owner of the resource. This GUID is used by HOB  /// consumer phase components to correlate device ownership of a resource.  ///  EFI_GUID                    Owner;  ///  /// The resource type enumeration as defined by EFI_RESOURCE_TYPE.  ///  EFI_RESOURCE_TYPE           ResourceType;  ///  /// Resource attributes as defined by EFI_RESOURCE_ATTRIBUTE_TYPE.  ///  EFI_RESOURCE_ATTRIBUTE_TYPE ResourceAttribute;  ///  /// The physical start address of the resource region.  ///  EFI_PHYSICAL_ADDRESS        PhysicalStart;  ///  /// The number of bytes of the resource region.  ///  UINT64                      ResourceLength;&#125; EFI_HOB_RESOURCE_DESCRIPTOR;</code></pre><h2 id="EFI-HOB-GUID-TYPE"><a href="#EFI-HOB-GUID-TYPE" class="headerlink" title="EFI_HOB_GUID_TYPE"></a>EFI_HOB_GUID_TYPE</h2><pre><code>////// Allows writers of executable content in the HOB producer phase to/// maintain and manage HOBs with specific GUID.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_GUID_EXTENSION.  ///  EFI_HOB_GENERIC_HEADER      Header;  ///  /// A GUID that defines the contents of this HOB.  ///  EFI_GUID                    Name;  //  // Guid specific data goes here  //&#125; EFI_HOB_GUID_TYPE;</code></pre><h2 id="EFI-HOB-FIRMWARE-VOLUME"><a href="#EFI-HOB-FIRMWARE-VOLUME" class="headerlink" title="EFI_HOB_FIRMWARE_VOLUME"></a>EFI_HOB_FIRMWARE_VOLUME</h2><pre><code>////// Details the location of firmware volumes that contain firmware files.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV.  ///  EFI_HOB_GENERIC_HEADER Header;  ///  /// The physical memory-mapped base address of the firmware volume.  ///  EFI_PHYSICAL_ADDRESS   BaseAddress;  ///  /// The length in bytes of the firmware volume.  ///  UINT64                 Length;&#125; EFI_HOB_FIRMWARE_VOLUME;</code></pre><h2 id="EFI-HOB-FIRMWARE-VOLUME2"><a href="#EFI-HOB-FIRMWARE-VOLUME2" class="headerlink" title="EFI_HOB_FIRMWARE_VOLUME2"></a>EFI_HOB_FIRMWARE_VOLUME2</h2><pre><code>////// Details the location of a firmware volume that was extracted/// from a file within another firmware volume.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV2.  ///  EFI_HOB_GENERIC_HEADER  Header;  ///  /// The physical memory-mapped base address of the firmware volume.  ///  EFI_PHYSICAL_ADDRESS    BaseAddress;  ///  /// The length in bytes of the firmware volume.  ///  UINT64                  Length;  ///  /// The name of the firmware volume.  ///  EFI_GUID                FvName;  ///  /// The name of the firmware file that contained this firmware volume.  ///  EFI_GUID                FileName;&#125; EFI_HOB_FIRMWARE_VOLUME2;</code></pre><h2 id="EFI-HOB-FIRMWARE-VOLUME3"><a href="#EFI-HOB-FIRMWARE-VOLUME3" class="headerlink" title="EFI_HOB_FIRMWARE_VOLUME3"></a>EFI_HOB_FIRMWARE_VOLUME3</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Details the location of a firmware volume that was extracted</span><span class="token comment" spellcheck="true">/// from a file within another firmware volume.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV3.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER  Header<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The physical memory-mapped base address of the firmware volume.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_PHYSICAL_ADDRESS    BaseAddress<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The length in bytes of the firmware volume.</span>  <span class="token comment" spellcheck="true">///</span>  UINT64                  Length<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The authentication status.</span>  <span class="token comment" spellcheck="true">///</span>  UINT32                  AuthenticationStatus<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// TRUE if the FV was extracted as a file within another firmware volume.</span>  <span class="token comment" spellcheck="true">/// FALSE otherwise.</span>  <span class="token comment" spellcheck="true">///</span>  BOOLEAN                 ExtractedFv<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The name of the firmware volume.</span>  <span class="token comment" spellcheck="true">/// Valid only if IsExtractedFv is TRUE.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_GUID                FvName<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The name of the firmware file that contained this firmware volume.</span>  <span class="token comment" spellcheck="true">/// Valid only if IsExtractedFv is TRUE.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_GUID                FileName<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_FIRMWARE_VOLUME3<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-CPU"><a href="#EFI-HOB-CPU" class="headerlink" title="EFI_HOB_CPU"></a>EFI_HOB_CPU</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Describes processor information, such as address space and I/O space capabilities.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_CPU.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER  Header<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// Identifies the maximum physical memory addressability of the processor.</span>  <span class="token comment" spellcheck="true">///</span>  UINT8                   SizeOfMemorySpace<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// Identifies the maximum physical I/O addressability of the processor.</span>  <span class="token comment" spellcheck="true">///</span>  UINT8                   SizeOfIoSpace<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// This field will always be set to zero.</span>  <span class="token comment" spellcheck="true">///</span>  UINT8                   Reserved<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_CPU<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-POOL"><a href="#EFI-HOB-MEMORY-POOL" class="headerlink" title="EFI_HOB_MEMORY_POOL"></a>EFI_HOB_MEMORY_POOL</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Describes pool memory allocations.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_POOL.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER  Header<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_MEMORY_POOL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-UEFI-CAPSULE"><a href="#EFI-HOB-UEFI-CAPSULE" class="headerlink" title="EFI_HOB_UEFI_CAPSULE"></a>EFI_HOB_UEFI_CAPSULE</h2><pre class="line-numbers language-c///"><code class="language-c///">/// Each UEFI capsule HOB details the location of a UEFI capsule. It includes a base address and length/// which is based upon memory blocks with a EFI_CAPSULE_HEADER and the associated/// CapsuleImageSize-based payloads. These HOB's shall be created by the PEI PI firmware/// sometime after the UEFI UpdateCapsule service invocation with the/// CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE flag set in the EFI_CAPSULE_HEADER.///typedef struct &#123;  ///  /// The HOB generic header where Header.HobType = EFI_HOB_TYPE_UEFI_CAPSULE.  ///  EFI_HOB_GENERIC_HEADER Header;  ///  /// The physical memory-mapped base address of an UEFI capsule. This value is set to  /// point to the base of the contiguous memory of the UEFI capsule.  /// The length of the contiguous memory in bytes.  ///  EFI_PHYSICAL_ADDRESS   BaseAddress;  UINT64                 Length;&#125; EFI_HOB_UEFI_CAPSULE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-PEI-HOB-POINTERS"><a href="#EFI-PEI-HOB-POINTERS" class="headerlink" title="EFI_PEI_HOB_POINTERS"></a>EFI_PEI_HOB_POINTERS</h2><blockquote><p>使用union最大的好处是提高源码的可读性和间接性。利用该类型中所有域的取值均一样的特点，在不同的使用方法下，可以使用不同的变量名字，一方面可以省去强制类型转换的麻烦，另一方面可以直接体现出当前的使用需求。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Union of all the possible HOB Types.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">union</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  EFI_HOB_GENERIC_HEADER              <span class="token operator">*</span>Header<span class="token punctuation">;</span>  EFI_HOB_HANDOFF_INFO_TABLE          <span class="token operator">*</span>HandoffInformationTable<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION           <span class="token operator">*</span>MemoryAllocation<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION_BSP_STORE <span class="token operator">*</span>MemoryAllocationBspStore<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION_STACK     <span class="token operator">*</span>MemoryAllocationStack<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION_MODULE    <span class="token operator">*</span>MemoryAllocationModule<span class="token punctuation">;</span>  EFI_HOB_RESOURCE_DESCRIPTOR         <span class="token operator">*</span>ResourceDescriptor<span class="token punctuation">;</span>  EFI_HOB_GUID_TYPE                   <span class="token operator">*</span>Guid<span class="token punctuation">;</span>  EFI_HOB_FIRMWARE_VOLUME             <span class="token operator">*</span>FirmwareVolume<span class="token punctuation">;</span>  EFI_HOB_FIRMWARE_VOLUME2            <span class="token operator">*</span>FirmwareVolume2<span class="token punctuation">;</span>  EFI_HOB_FIRMWARE_VOLUME3            <span class="token operator">*</span>FirmwareVolume3<span class="token punctuation">;</span>  EFI_HOB_CPU                         <span class="token operator">*</span>Cpu<span class="token punctuation">;</span>  EFI_HOB_MEMORY_POOL                 <span class="token operator">*</span>Pool<span class="token punctuation">;</span>  EFI_HOB_UEFI_CAPSULE                <span class="token operator">*</span>Capsule<span class="token punctuation">;</span>  UINT8                               <span class="token operator">*</span>Raw<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_PEI_HOB_POINTERS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="HOB相关方法的声明（HobLib-h）"><a href="#HOB相关方法的声明（HobLib-h）" class="headerlink" title="HOB相关方法的声明（HobLib.h）"></a>HOB相关方法的声明（HobLib.h）</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><ul><li>BuildModuleHob</li><li>BuildResourceDescriptorWithOwnerHob</li><li>BuildResourceDescriptorHob</li><li>BuildGuidHob</li><li>BuildGuidDataHob</li><li>BuildFvHob</li><li>BuildFv2Hob</li><li>BuildFv3Hob</li><li>BuildCvHob</li><li>BuildCpuHob</li><li>BuildStackHob</li><li>BuildBspStoreHob</li><li>BuildMemoryAllocationHob</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**  Builds a HOB for a loaded PE32 module.  This function builds a HOB for a loaded PE32 module.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If ModuleName is NULL, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  @param  ModuleName              The GUID File Name of the module.  @param  MemoryAllocationModule  The 64 bit physical address of the module.  @param  ModuleLength            The length of the module in bytes.  @param  EntryPoint              The 64 bit physical address of the module entry point.**/</span>VOIDEFIAPI<span class="token function">BuildModuleHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID         <span class="token operator">*</span>ModuleName<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS   MemoryAllocationModule<span class="token punctuation">,</span>  IN UINT64                 ModuleLength<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS   EntryPoint  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB that describes a chunk of system memory with Owner GUID.  This function builds a HOB that describes a chunk of system memory.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  ResourceType        The type of resource described by this HOB.  @param  ResourceAttribute   The resource attributes of the memory described by this HOB.  @param  PhysicalStart       The 64 bit physical address of memory described by this HOB.  @param  NumberOfBytes       The length of the memory described by this HOB in bytes.  @param  OwnerGUID           GUID for the owner of this resource.**/</span>VOIDEFIAPI<span class="token function">BuildResourceDescriptorWithOwnerHob</span> <span class="token punctuation">(</span>  IN EFI_RESOURCE_TYPE            ResourceType<span class="token punctuation">,</span>  IN EFI_RESOURCE_ATTRIBUTE_TYPE  ResourceAttribute<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS         PhysicalStart<span class="token punctuation">,</span>  IN UINT64                       NumberOfBytes<span class="token punctuation">,</span>  IN EFI_GUID                     <span class="token operator">*</span>OwnerGUID  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB that describes a chunk of system memory.  This function builds a HOB that describes a chunk of system memory.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  ResourceType        The type of resource described by this HOB.  @param  ResourceAttribute   The resource attributes of the memory described by this HOB.  @param  PhysicalStart       The 64 bit physical address of memory described by this HOB.  @param  NumberOfBytes       The length of the memory described by this HOB in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildResourceDescriptorHob</span> <span class="token punctuation">(</span>  IN EFI_RESOURCE_TYPE            ResourceType<span class="token punctuation">,</span>  IN EFI_RESOURCE_ATTRIBUTE_TYPE  ResourceAttribute<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS         PhysicalStart<span class="token punctuation">,</span>  IN UINT64                       NumberOfBytes  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a customized HOB tagged with a GUID for identification and returns  the start address of GUID HOB data.  This function builds a customized HOB tagged with a GUID for identification  and returns the start address of GUID HOB data so that caller can fill the customized data.  The HOB Header and Name field is already stripped.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If Guid is NULL, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  If DataLength > (0xFFF8 - sizeof (EFI_HOB_GUID_TYPE)), then ASSERT().  HobLength is UINT16 and multiples of 8 bytes, so the max HobLength is 0xFFF8.  @param  Guid          The GUID to tag the customized HOB.  @param  DataLength    The size of the data payload for the GUID HOB.  @retval  NULL         The GUID HOB could not be allocated.  @retval  others       The start address of GUID HOB data.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">BuildGuidHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID              <span class="token operator">*</span>Guid<span class="token punctuation">,</span>  IN UINTN                       DataLength  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a customized HOB tagged with a GUID for identification, copies the input data to the HOB  data field, and returns the start address of the GUID HOB data.  This function builds a customized HOB tagged with a GUID for identification and copies the input  data to the HOB data field and returns the start address of the GUID HOB data.  It can only be  invoked during PEI phase; for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  The HOB Header and Name field is already stripped.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If Guid is NULL, then ASSERT().  If Data is NULL and DataLength > 0, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  If DataLength > (0xFFF8 - sizeof (EFI_HOB_GUID_TYPE)), then ASSERT().  HobLength is UINT16 and multiples of 8 bytes, so the max HobLength is 0xFFF8.  @param  Guid          The GUID to tag the customized HOB.  @param  Data          The data to be copied into the data field of the GUID HOB.  @param  DataLength    The size of the data payload for the GUID HOB.  @retval  NULL         The GUID HOB could not be allocated.  @retval  others       The start address of GUID HOB data.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">BuildGuidDataHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID              <span class="token operator">*</span>Guid<span class="token punctuation">,</span>  IN VOID                        <span class="token operator">*</span>Data<span class="token punctuation">,</span>  IN UINTN                       DataLength  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a Firmware Volume HOB.  This function builds a Firmware Volume HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  If the FvImage buffer is not at its required alignment, then ASSERT().  @param  BaseAddress   The base address of the Firmware Volume.  @param  Length        The size of the Firmware Volume in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildFvHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a EFI_HOB_TYPE_FV2 HOB.  This function builds a EFI_HOB_TYPE_FV2 HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  If the FvImage buffer is not at its required alignment, then ASSERT().  @param  BaseAddress   The base address of the Firmware Volume.  @param  Length        The size of the Firmware Volume in bytes.  @param  FvName        The name of the Firmware Volume.  @param  FileName      The name of the file.**/</span>VOIDEFIAPI<span class="token function">BuildFv2Hob</span> <span class="token punctuation">(</span>  IN          EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN          UINT64                      Length<span class="token punctuation">,</span>  IN CONST    EFI_GUID                    <span class="token operator">*</span>FvName<span class="token punctuation">,</span>  IN CONST    EFI_GUID                    <span class="token operator">*</span>FileName  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a EFI_HOB_TYPE_FV3 HOB.  This function builds a EFI_HOB_TYPE_FV3 HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  If the FvImage buffer is not at its required alignment, then ASSERT().  @param BaseAddress            The base address of the Firmware Volume.  @param Length                 The size of the Firmware Volume in bytes.  @param AuthenticationStatus   The authentication status.  @param ExtractedFv            TRUE if the FV was extracted as a file within                                another firmware volume. FALSE otherwise.  @param FvName                 The name of the Firmware Volume.                                Valid only if IsExtractedFv is TRUE.  @param FileName               The name of the file.                                Valid only if IsExtractedFv is TRUE.**/</span>VOIDEFIAPI<span class="token function">BuildFv3Hob</span> <span class="token punctuation">(</span>  IN          EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN          UINT64                      Length<span class="token punctuation">,</span>  IN          UINT32                      AuthenticationStatus<span class="token punctuation">,</span>  IN          BOOLEAN                     ExtractedFv<span class="token punctuation">,</span>  IN CONST    EFI_GUID                    <span class="token operator">*</span>FvName<span class="token punctuation">,</span> OPTIONAL  IN CONST    EFI_GUID                    <span class="token operator">*</span>FileName OPTIONAL  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a Capsule Volume HOB.  This function builds a Capsule Volume HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If the platform does not support Capsule Volume HOBs, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The base address of the Capsule Volume.  @param  Length        The size of the Capsule Volume in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildCvHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB for the CPU.  This function builds a HOB for the CPU.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  SizeOfMemorySpace   The maximum physical memory addressability of the processor.  @param  SizeOfIoSpace       The maximum physical I/O addressability of the processor.**/</span>VOIDEFIAPI<span class="token function">BuildCpuHob</span> <span class="token punctuation">(</span>  IN UINT8                       SizeOfMemorySpace<span class="token punctuation">,</span>  IN UINT8                       SizeOfIoSpace  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB for the Stack.  This function builds a HOB for the stack.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The 64 bit physical address of the Stack.  @param  Length        The length of the stack in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildStackHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB for the BSP store.  This function builds a HOB for BSP store.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The 64 bit physical address of the BSP.  @param  Length        The length of the BSP store in bytes.  @param  MemoryType    Type of memory allocated by this HOB.**/</span>VOIDEFIAPI<span class="token function">BuildBspStoreHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length<span class="token punctuation">,</span>  IN EFI_MEMORY_TYPE             MemoryType  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB for the memory allocation.  This function builds a HOB for the memory allocation.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The 64 bit physical address of the memory.  @param  Length        The length of the memory allocation in bytes.  @param  MemoryType    Type of memory allocated by this HOB.**/</span>VOIDEFIAPI<span class="token function">BuildMemoryAllocationHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length<span class="token punctuation">,</span>  IN EFI_MEMORY_TYPE             MemoryType  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><blockquote><p>无此方法</p></blockquote><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><ul><li>GetHobList</li><li>GetNextHob</li><li>GetFirstHob</li><li>GetFirstGuidHob</li><li>GetNextGuidHob</li><li>GetBootModeHob</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**  Returns the pointer to the HOB list.  This function returns the pointer to first HOB in the list.  For PEI phase, the PEI service GetHobList() can be used to retrieve the pointer  to the HOB list.  For the DXE phase, the HOB list pointer can be retrieved through  the EFI System Table by looking up theHOB list GUID in the System Configuration Table.  Since the System Configuration Table does not exist that the time the DXE Core is  launched, the DXE Core uses a global variable from the DXE Core Entry Point Library  to manage the pointer to the HOB list.  If the pointer to the HOB list is NULL, then ASSERT().  @return The pointer to the HOB list.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetHobList</span> <span class="token punctuation">(</span>  VOID  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Returns the next instance of a HOB type from the starting HOB.  This function searches the first instance of a HOB type from the starting HOB pointer.  If there does not exist such HOB type from the starting HOB pointer, it will return NULL.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.  If HobStart is NULL, then ASSERT().  @param  Type          The HOB type to return.  @param  HobStart      The starting HOB pointer to search from.  @return The next instance of a HOB type from the starting HOB.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetNextHob</span> <span class="token punctuation">(</span>  IN UINT16                 Type<span class="token punctuation">,</span>  IN CONST VOID             <span class="token operator">*</span>HobStart  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Returns the first instance of a HOB type among the whole HOB list.  This function searches the first instance of a HOB type among the whole HOB list.  If there does not exist such HOB type in the HOB list, it will return NULL.  If the pointer to the HOB list is NULL, then ASSERT().  @param  Type          The HOB type to return.  @return The next instance of a HOB type from the starting HOB.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetFirstHob</span> <span class="token punctuation">(</span>  IN UINT16                 Type  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Returns the next instance of the matched GUID HOB from the starting HOB.  This function searches the first instance of a HOB from the starting HOB pointer.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size info respectively.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.  If Guid is NULL, then ASSERT().  If HobStart is NULL, then ASSERT().  @param  Guid          The GUID to match with in the HOB list.  @param  HobStart      A pointer to a Guid.  @return The next instance of the matched GUID HOB from the starting HOB.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetNextGuidHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID         <span class="token operator">*</span>Guid<span class="token punctuation">,</span>  IN CONST VOID             <span class="token operator">*</span>HobStart  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Returns the first instance of the matched GUID HOB among the whole HOB list.  This function searches the first instance of a HOB among the whole HOB list.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size info respectively.  If the pointer to the HOB list is NULL, then ASSERT().  If Guid is NULL, then ASSERT().  @param  Guid          The GUID to match with in the HOB list.  @return The first instance of the matched GUID HOB among the whole HOB list.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetFirstGuidHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID         <span class="token operator">*</span>Guid  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Get the system boot mode from the HOB list.  This function returns the system boot mode information from the  PHIT HOB in HOB list.  If the pointer to the HOB list is NULL, then ASSERT().  @param  VOID  @return The Boot Mode.**/</span>EFI_BOOT_MODEEFIAPI<span class="token function">GetBootModeHob</span> <span class="token punctuation">(</span>  VOID  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><blockquote><p>未提供方法，一般是先找到感兴趣的Hob，再修改Block中的数据</p></blockquote><hr><h1 id="HOB相关接口的实现"><a href="#HOB相关接口的实现" class="headerlink" title="HOB相关接口的实现"></a>HOB相关接口的实现</h1><ul><li>HobLib.h </li><li>MdePkg\Library\PeiHobLib\HobLib.c </li><li>MdePkg\Library\DxeHobLib\HobLib.c </li><li>MdePkg\Library\DxeCoreHobLib\HobLib.c </li><li>IntelFrameworkPkg\Library\PeiHobLibFramework\HobLib.c </li></ul><h2 id="相关宏函数"><a href="#相关宏函数" class="headerlink" title="相关宏函数"></a>相关宏函数</h2><ul><li>GET_HOB_TYPE</li><li>GET_HOB_LENGTH</li><li>GET_NEXT_HOB</li><li>END_OF_HOB_LIST</li><li>GET_GUID_HOB_DATAET_GUID_HOB_DATA</li><li>GET_GUID_HOB_DATA_SIZE</li></ul><pre><code>/**  Returns the type of a HOB.  This macro returns the HobType field from the HOB header for the  HOB specified by HobStart.  @param  HobStart   A pointer to a HOB.  @return HobType.**/#define GET_HOB_TYPE(HobStart) \  ((*(EFI_HOB_GENERIC_HEADER **)&amp;(HobStart))-&gt;HobType)/**  Returns the length, in bytes, of a HOB.  This macro returns the HobLength field from the HOB header for the  HOB specified by HobStart.  @param  HobStart   A pointer to a HOB.  @return HobLength.**/#define GET_HOB_LENGTH(HobStart) \  ((*(EFI_HOB_GENERIC_HEADER **)&amp;(HobStart))-&gt;HobLength)/**  Returns a pointer to the next HOB in the HOB list.  This macro returns a pointer to HOB that follows the  HOB specified by HobStart in the HOB List.  @param  HobStart   A pointer to a HOB.  @return A pointer to the next HOB in the HOB list.**/#define GET_NEXT_HOB(HobStart) \  (VOID *)(*(UINT8 **)&amp;(HobStart) + GET_HOB_LENGTH (HobStart))/**  Determines if a HOB is the last HOB in the HOB list.  This macro determine if the HOB specified by HobStart is the  last HOB in the HOB list.  If HobStart is last HOB in the HOB list,  then TRUE is returned.  Otherwise, FALSE is returned.  @param  HobStart   A pointer to a HOB.  @retval TRUE       The HOB specified by HobStart is the last HOB in the HOB list.  @retval FALSE      The HOB specified by HobStart is not the last HOB in the HOB list.**/#define END_OF_HOB_LIST(HobStart)  (GET_HOB_TYPE (HobStart) == (UINT16)EFI_HOB_TYPE_END_OF_HOB_LIST)/**  Returns a pointer to data buffer from a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  This macro returns a pointer to the data buffer in a HOB specified by HobStart.  HobStart is assumed to be a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  @param   GuidHob   A pointer to a HOB.  @return  A pointer to the data buffer in a HOB.**/#define GET_GUID_HOB_DATA(HobStart) \  (VOID *)(*(UINT8 **)&amp;(HobStart) + sizeof (EFI_HOB_GUID_TYPE))/**  Returns the size of the data buffer from a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  This macro returns the size, in bytes, of the data buffer in a HOB specified by HobStart.  HobStart is assumed to be a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  @param   GuidHob   A pointer to a HOB.  @return  The size of the data buffer.**/#define GET_GUID_HOB_DATA_SIZE(HobStart) \  (UINT16)(GET_HOB_LENGTH (HobStart) - sizeof (EFI_HOB_GUID_TYPE))</code></pre><h2 id="CreateHob-仅PEI阶段有效"><a href="#CreateHob-仅PEI阶段有效" class="headerlink" title="CreateHob(仅PEI阶段有效)"></a>CreateHob(仅PEI阶段有效)</h2><ul><li>MdeModulePkg\Core\Pei\PeiMain.h</li></ul><pre><code>/**  Add a new HOB to the HOB List.  @param PeiServices        An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param Type               Type of the new HOB.  @param Length             Length of the new HOB to allocate.  @param Hob                Pointer to the new HOB.  @return  EFI_SUCCESS           Success to create hob.  @retval  EFI_INVALID_PARAMETER if Hob is NULL  @retval  EFI_NOT_AVAILABLE_YET if HobList is still not available.  @retval  EFI_OUT_OF_RESOURCES  if there is no more memory to grow the Hoblist.**/EFI_STATUSEFIAPIPeiCreateHob (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN UINT16            Type,  IN UINT16            Length,  IN OUT VOID          **Hob  );</code></pre><ul><li>MdeModulePkg\Core\Pei\Hob\Hob.c</li></ul><pre><code>/**  Add a new HOB to the HOB List.  @param PeiServices      An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param Type             Type of the new HOB.  @param Length           Length of the new HOB to allocate.  @param Hob              Pointer to the new HOB.  @return  EFI_SUCCESS           Success to create hob.  @retval  EFI_INVALID_PARAMETER if Hob is NULL  @retval  EFI_NOT_AVAILABLE_YET if HobList is still not available.  @retval  EFI_OUT_OF_RESOURCES  if there is no more memory to grow the Hoblist.**/EFI_STATUSEFIAPIPeiCreateHob (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN UINT16            Type,  IN UINT16            Length,  IN OUT VOID          **Hob  )&#123;  EFI_STATUS                           Status;  EFI_HOB_HANDOFF_INFO_TABLE           *HandOffHob;  EFI_HOB_GENERIC_HEADER               *HobEnd;  EFI_PHYSICAL_ADDRESS                 FreeMemory;  Status = PeiGetHobList (PeiServices, Hob);  if (EFI_ERROR(Status)) &#123;    return Status;  &#125;  HandOffHob = *Hob;  //  // Check Length to avoid data overflow.  //  if (0x10000 - Length &lt;= 0x7) &#123;    return EFI_INVALID_PARAMETER;  &#125;  Length     = (UINT16)((Length + 0x7) &amp; (~0x7));  FreeMemory = HandOffHob-&gt;EfiFreeMemoryTop -               HandOffHob-&gt;EfiFreeMemoryBottom;  if (FreeMemory &lt; Length) &#123;    DEBUG ((EFI_D_ERROR, &quot;PeiCreateHob fail: Length - 0x%08x\n&quot;, (UINTN)Length));    DEBUG ((EFI_D_ERROR, &quot;  FreeMemoryTop    - 0x%08x\n&quot;, (UINTN)HandOffHob-&gt;EfiFreeMemoryTop));    DEBUG ((EFI_D_ERROR, &quot;  FreeMemoryBottom - 0x%08x\n&quot;, (UINTN)HandOffHob-&gt;EfiFreeMemoryBottom));    return EFI_OUT_OF_RESOURCES;  &#125;  *Hob = (VOID*) (UINTN) HandOffHob-&gt;EfiEndOfHobList;  ((EFI_HOB_GENERIC_HEADER*) *Hob)-&gt;HobType   = Type;  ((EFI_HOB_GENERIC_HEADER*) *Hob)-&gt;HobLength = Length;  ((EFI_HOB_GENERIC_HEADER*) *Hob)-&gt;Reserved  = 0;  HobEnd = (EFI_HOB_GENERIC_HEADER*) ((UINTN) *Hob + Length);  HandOffHob-&gt;EfiEndOfHobList = (EFI_PHYSICAL_ADDRESS) (UINTN) HobEnd;  HobEnd-&gt;HobType   = EFI_HOB_TYPE_END_OF_HOB_LIST;  HobEnd-&gt;HobLength = (UINT16) sizeof (EFI_HOB_GENERIC_HEADER);  HobEnd-&gt;Reserved  = 0;  HobEnd++;  HandOffHob-&gt;EfiFreeMemoryBottom = (EFI_PHYSICAL_ADDRESS) (UINTN) HobEnd;  return EFI_SUCCESS;&#125; </code></pre><ul><li>MdePkg\Include\Pi\PiPeiCis.h</li></ul><pre><code>/**  This service, published by the PEI Foundation, abstracts the creation of a Hand-Off Block&#39;s (HOB&#39;s) headers.  @param  PeiServices      An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param  Type             The type of HOB to be installed.  @param  Length           The length of the HOB to be added.  @param  Hob              The address of a pointer that will contain the HOB header.  @retval EFI_SUCCESS           The HOB was successfully created.  @retval EFI_OUT_OF_RESOURCES  There is no additional space for HOB creation.**/typedefEFI_STATUS(EFIAPI *EFI_PEI_CREATE_HOB)(  IN CONST EFI_PEI_SERVICES            **PeiServices,  IN UINT16                            Type,  IN UINT16                            Length,  IN OUT VOID                          **Hob  );/// EFI_PEI_SERVICES is a collection of functions whose implementation is provided by the PEI/// Foundation. These services fall into various classes, including the following:/// - Managing the boot mode/// - Allocating both early and permanent memory/// - Supporting the Firmware File System (FFS)/// - Abstracting the PPI database abstraction/// - Creating Hand-Off Blocks (HOBs).///struct _EFI_PEI_SERVICES &#123;  ///  /// The table header for the PEI Services Table.  ///  EFI_TABLE_HEADER                Hdr;  //  // PPI Functions  //  EFI_PEI_INSTALL_PPI             InstallPpi;  EFI_PEI_REINSTALL_PPI           ReInstallPpi;  EFI_PEI_LOCATE_PPI              LocatePpi;  EFI_PEI_NOTIFY_PPI              NotifyPpi;  //  // Boot Mode Functions  //  EFI_PEI_GET_BOOT_MODE           GetBootMode;  EFI_PEI_SET_BOOT_MODE           SetBootMode;  //  // HOB Functions  //  EFI_PEI_GET_HOB_LIST            GetHobList;  EFI_PEI_CREATE_HOB              CreateHob;  //  // Firmware Volume Functions  //  EFI_PEI_FFS_FIND_NEXT_VOLUME2   FfsFindNextVolume;  EFI_PEI_FFS_FIND_NEXT_FILE2     FfsFindNextFile;  EFI_PEI_FFS_FIND_SECTION_DATA2  FfsFindSectionData;  //  // PEI Memory Functions  //  EFI_PEI_INSTALL_PEI_MEMORY      InstallPeiMemory;  EFI_PEI_ALLOCATE_PAGES          AllocatePages;  EFI_PEI_ALLOCATE_POOL           AllocatePool;  EFI_PEI_COPY_MEM                CopyMem;  EFI_PEI_SET_MEM                 SetMem;  //  // Status Code  //  EFI_PEI_REPORT_STATUS_CODE      ReportStatusCode;  //  // Reset  //  EFI_PEI_RESET_SYSTEM            ResetSystem;  //  // (the following interfaces are installed by publishing PEIM)  // I/O Abstractions  //  EFI_PEI_CPU_IO_PPI              *CpuIo;  EFI_PEI_PCI_CFG2_PPI            *PciCfg;  //  // Future Installed Services  //  EFI_PEI_FFS_FIND_BY_NAME        FfsFindFileByName;  EFI_PEI_FFS_GET_FILE_INFO       FfsGetFileInfo;  EFI_PEI_FFS_GET_VOLUME_INFO     FfsGetVolumeInfo;  EFI_PEI_REGISTER_FOR_SHADOW     RegisterForShadow;  EFI_PEI_FFS_FIND_SECTION_DATA3  FindSectionData3;  EFI_PEI_FFS_GET_FILE_INFO2      FfsGetFileInfo2;  EFI_PEI_RESET2_SYSTEM           ResetSystem2;  EFI_PEI_FREE_PAGES              FreePages;&#125;;</code></pre><ul><li>MdeModulePkg\Core\Pei\PeiMain\PeiMain.c</li></ul><pre><code>/// Pei service instance///EFI_PEI_SERVICES  gPs = &#123;  &#123;    PEI_SERVICES_SIGNATURE,    PEI_SERVICES_REVISION,    sizeof (EFI_PEI_SERVICES),    0,    0  &#125;,  PeiInstallPpi,  PeiReInstallPpi,  PeiLocatePpi,  PeiNotifyPpi,  PeiGetBootMode,  PeiSetBootMode,  PeiGetHobList,  PeiCreateHob,  PeiFfsFindNextVolume,  PeiFfsFindNextFile,  PeiFfsFindSectionData,  PeiInstallPeiMemory,  PeiAllocatePages,  PeiAllocatePool,  (EFI_PEI_COPY_MEM)CopyMem,  (EFI_PEI_SET_MEM)SetMem,  PeiReportStatusCode,  PeiResetSystem,  &amp;gPeiDefaultCpuIoPpi,  &amp;gPeiDefaultPciCfg2Ppi,  PeiFfsFindFileByName,  PeiFfsGetFileInfo,  PeiFfsGetVolumeInfo,  PeiRegisterForShadow,  PeiFfsFindSectionData3,  PeiFfsGetFileInfo2,  PeiResetSystem2,  PeiFreePages,&#125;;</code></pre><h2 id="GetHobList-PEI阶段实现"><a href="#GetHobList-PEI阶段实现" class="headerlink" title="GetHobList(PEI阶段实现)"></a>GetHobList(PEI阶段实现)</h2><ul><li>MdeModulePkg\Core\Pei\PeiMain.h</li></ul><pre><code>/**  Gets the pointer to the HOB List.  @param PeiServices                   An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param HobList                       Pointer to the HOB List.  @retval EFI_SUCCESS                  Get the pointer of HOB List  @retval EFI_NOT_AVAILABLE_YET        the HOB List is not yet published  @retval EFI_INVALID_PARAMETER        HobList is NULL (in debug mode)**/EFI_STATUSEFIAPIPeiGetHobList (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN OUT VOID          **HobList  );</code></pre><ul><li>MdeModulePkg\Core\Pei\Hob\Hob.c</li></ul><pre><code>/**   Gets the pointer to the HOB List.  @param PeiServices                   An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param HobList                       Pointer to the HOB List.  @retval EFI_SUCCESS                  Get the pointer of HOB List  @retval EFI_NOT_AVAILABLE_YET        the HOB List is not yet published  @retval EFI_INVALID_PARAMETER        HobList is NULL (in debug mode) **/EFI_STATUSEFIAPIPeiGetHobList (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN OUT VOID          **HobList  )&#123;  PEI_CORE_INSTANCE *PrivateData;  //  // Only check this parameter in debug mode  //  DEBUG_CODE_BEGIN ();    if (HobList == NULL) &#123;      return EFI_INVALID_PARAMETER;    &#125;  DEBUG_CODE_END ();  PrivateData = PEI_CORE_INSTANCE_FROM_PS_THIS(PeiServices);  *HobList    = PrivateData-&gt;HobList.Raw;  return EFI_SUCCESS;&#125;</code></pre><ul><li>PeiMain.h</li></ul><blockquote><p>这个宏的作用是根据一个结构体成员变量的的地址获得该结构体基地址</p></blockquote><p>定义形式：<br>#define _CR(Record, TYPE, Field) <br>((TYPE *) ((CHAR8 *) (Record) - (CHAR8 *) &amp;(((TYPE *) 0)-&gt;Field)))<br>功能是：找出TYPE类型结构体成员Field所在结构体的地址,Record是Field的地址。</p><p>具体实现：<br>1.(CHAR8 *) (Record)：Field的地址以CHAR8 *类型进行运算。</p><p>2.(CHAR8 *) &amp;(((TYPE *) 0)-&gt;Field))：重点就是(TYPE *) 0)了，ANSI C标准允许值为0的常量被强制转换成任何一种类型的指针，并且转换结果是一个NULL指针，因此((type *)0)的结果就是一个类型为type *的NULL指针。如果利用这NULL指针来访问type的成员当然是非法的，但&amp;( ((type *)0)-&gt;field )的意图仅仅是计算field字段的地址。聪明的编译器根本就不生成访问type的代码，而仅仅是根据type的内存布局和结构体实例首址在编译期计算这个（常量）地址，这样就完全避免了通过NULL指针访问内存的问题。又因为首址为0，所以这个地址的值就是字段相对于结构体基址的偏移。以上方法避免了实例化一个type对象，并且求值在编译期进行，没有运行期负担。这样，就得到了Field在它的结构体中的偏移地址并同样以CHAR8 *类型进行运算。</p><p>3.((TYPE *) ：最后求得的地址转成原有结构体类型。<br>用1得到的变量地址减去2得到的变量偏移地址，得到的基地址通过3转换回原来的类型。大功告成！<br>重点就是  ((TYPE *) 0)-&gt;Field)。</p><pre><code> ////// Pei Core Instance Data Macros///#define PEI_CORE_INSTANCE_FROM_PS_THIS(a) \  CR(a, PEI_CORE_INSTANCE, Ps, PEI_CORE_HANDLE_SIGNATURE)</code></pre><h2 id="GetHobList-DXE阶段实现"><a href="#GetHobList-DXE阶段实现" class="headerlink" title="GetHobList(DXE阶段实现)"></a>GetHobList(DXE阶段实现)</h2><ul><li>MdePkg\Library\DxeHobLib\HobLib.c</li></ul><pre><code>VOID  *mHobList = NULL;/**  Returns the pointer to the HOB list.  This function returns the pointer to first HOB in the list.  For PEI phase, the PEI service GetHobList() can be used to retrieve the pointer  to the HOB list.  For the DXE phase, the HOB list pointer can be retrieved through  the EFI System Table by looking up theHOB list GUID in the System Configuration Table.  Since the System Configuration Table does not exist that the time the DXE Core is  launched, the DXE Core uses a global variable from the DXE Core Entry Point Library  to manage the pointer to the HOB list.  If the pointer to the HOB list is NULL, then ASSERT().  This function also caches the pointer to the HOB list retrieved.  @return The pointer to the HOB list.**/VOID *EFIAPIGetHobList (  VOID  )&#123;  EFI_STATUS  Status;  if (mHobList == NULL) &#123;    Status = EfiGetSystemConfigurationTable (&amp;gEfiHobListGuid, &amp;mHobList);    ASSERT_EFI_ERROR (Status);    ASSERT (mHobList != NULL);  &#125;  return mHobList;&#125;</code></pre><pre><code>/**  Retrieves a pointer to the system configuration table from the EFI System Table  based on a specified GUID.  This function searches the list of configuration tables stored in the EFI System Table  for a table with a GUID that matches TableGuid.  If a match is found, then a pointer to  the configuration table is returned in Table., and EFI_SUCCESS is returned. If a matching GUID  is not found, then EFI_NOT_FOUND is returned.  If TableGuid is NULL, then ASSERT().  If Table is NULL, then ASSERT().  @param  TableGuid       The pointer to table&#39;s GUID type.  @param  Table           The pointer to the table associated with TableGuid in the EFI System Table.  @retval EFI_SUCCESS     A configuration table matching TableGuid was found.  @retval EFI_NOT_FOUND   A configuration table matching TableGuid could not be found.**/EFI_STATUSEFIAPIEfiGetSystemConfigurationTable (  IN  EFI_GUID  *TableGuid,  OUT VOID      **Table  )&#123;  EFI_SYSTEM_TABLE  *SystemTable;  UINTN             Index;  ASSERT (TableGuid != NULL);  ASSERT (Table != NULL);  SystemTable = gST;  *Table = NULL;  for (Index = 0; Index &lt; SystemTable-&gt;NumberOfTableEntries; Index++) &#123;    if (CompareGuid (TableGuid, &amp;(SystemTable-&gt;ConfigurationTable[Index].VendorGuid))) &#123;      *Table = SystemTable-&gt;ConfigurationTable[Index].VendorTable;      return EFI_SUCCESS;    &#125;  &#125;  return EFI_NOT_FOUND;&#125;</code></pre><h2 id="GetNextHob"><a href="#GetNextHob" class="headerlink" title="GetNextHob"></a>GetNextHob</h2><pre><code>/**  Returns the next instance of a HOB type from the starting HOB.  This function searches the first instance of a HOB type from the starting HOB pointer.  If there does not exist such HOB type from the starting HOB pointer, it will return NULL.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.  If HobStart is NULL, then ASSERT().  @param  Type          The HOB type to return.  @param  HobStart      The starting HOB pointer to search from.  @return The next instance of a HOB type from the starting HOB.**/VOID *EFIAPIGetNextHob (  IN UINT16                 Type,  IN CONST VOID             *HobStart  )&#123;  EFI_PEI_HOB_POINTERS  Hob;  ASSERT (HobStart != NULL);  Hob.Raw = (UINT8 *) HobStart;  //  // Parse the HOB list until end of list or matching type is found.  //  while (!END_OF_HOB_LIST (Hob)) &#123;    if (Hob.Header-&gt;HobType == Type) &#123;      return Hob.Raw;    &#125;    Hob.Raw = GET_NEXT_HOB (Hob);  &#125;  return NULL;&#125;</code></pre><h2 id="GetFirstHob"><a href="#GetFirstHob" class="headerlink" title="GetFirstHob"></a>GetFirstHob</h2><pre><code>/**  Returns the first instance of a HOB type among the whole HOB list.  This function searches the first instance of a HOB type among the whole HOB list.  If there does not exist such HOB type in the HOB list, it will return NULL.  If the pointer to the HOB list is NULL, then ASSERT().  @param  Type          The HOB type to return.  @return The next instance of a HOB type from the starting HOB.**/VOID *EFIAPIGetFirstHob (  IN UINT16                 Type  )&#123;  VOID      *HobList;  HobList = GetHobList ();  return GetNextHob (Type, HobList);&#125;</code></pre><h2 id="GetNextGuidHob"><a href="#GetNextGuidHob" class="headerlink" title="GetNextGuidHob"></a>GetNextGuidHob</h2><pre><code>/**  Returns the next instance of the matched GUID HOB from the starting HOB.  This function searches the first instance of a HOB from the starting HOB pointer.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size information, respectively.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.  If Guid is NULL, then ASSERT().  If HobStart is NULL, then ASSERT().  @param  Guid          The GUID to match with in the HOB list.  @param  HobStart      A pointer to a Guid.  @return The next instance of the matched GUID HOB from the starting HOB.**/VOID *EFIAPIGetNextGuidHob (  IN CONST EFI_GUID         *Guid,  IN CONST VOID             *HobStart  )&#123;  EFI_PEI_HOB_POINTERS  GuidHob;  GuidHob.Raw = (UINT8 *) HobStart;  while ((GuidHob.Raw = GetNextHob (EFI_HOB_TYPE_GUID_EXTENSION, GuidHob.Raw)) != NULL) &#123;    if (CompareGuid (Guid, &amp;GuidHob.Guid-&gt;Name)) &#123;      break;    &#125;    GuidHob.Raw = GET_NEXT_HOB (GuidHob);  &#125;  return GuidHob.Raw;&#125;</code></pre><h2 id="GetFirstGuidHob"><a href="#GetFirstGuidHob" class="headerlink" title="GetFirstGuidHob"></a>GetFirstGuidHob</h2><pre><code>/**  Returns the first instance of the matched GUID HOB among the whole HOB list.  This function searches the first instance of a HOB among the whole HOB list.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size information, respectively.  If the pointer to the HOB list is NULL, then ASSERT().  If Guid is NULL, then ASSERT().  @param  Guid          The GUID to match with in the HOB list.  @return The first instance of the matched GUID HOB among the whole HOB list.**/VOID *EFIAPIGetFirstGuidHob (  IN CONST EFI_GUID         *Guid  )&#123;  VOID      *HobList;  HobList = GetHobList ();  return GetNextGuidHob (Guid, HobList);&#125;</code></pre><hr><h1 id="HOB生产消费流程"><a href="#HOB生产消费流程" class="headerlink" title="HOB生产消费流程"></a>HOB生产消费流程</h1><h2 id="PHIT-HOB的建立"><a href="#PHIT-HOB的建立" class="headerlink" title="PHIT HOB的建立"></a>PHIT HOB的建立</h2><ul><li> MdeModulePkg\Core\Pei\Hob\Hob.c</li></ul><pre><code>/**  Builds a Handoff Information Table HOB  @param BootMode        - Current Bootmode  @param MemoryBegin     - Start Memory Address.  @param MemoryLength    - Length of Memory.  @return EFI_SUCCESS Always success to initialize HOB.**/EFI_STATUSPeiCoreBuildHobHandoffInfoTable (  IN EFI_BOOT_MODE         BootMode,  IN EFI_PHYSICAL_ADDRESS  MemoryBegin,  IN UINT64                MemoryLength  )&#123;  EFI_HOB_HANDOFF_INFO_TABLE   *Hob;  EFI_HOB_GENERIC_HEADER       *HobEnd;  Hob                      = (VOID *)(UINTN)MemoryBegin;  HobEnd                   = (EFI_HOB_GENERIC_HEADER*) (Hob+1);  Hob-&gt;Header.HobType      = EFI_HOB_TYPE_HANDOFF;  Hob-&gt;Header.HobLength    = (UINT16) sizeof (EFI_HOB_HANDOFF_INFO_TABLE);  Hob-&gt;Header.Reserved     = 0;  HobEnd-&gt;HobType          = EFI_HOB_TYPE_END_OF_HOB_LIST;  HobEnd-&gt;HobLength        = (UINT16) sizeof (EFI_HOB_GENERIC_HEADER);  HobEnd-&gt;Reserved         = 0;  Hob-&gt;Version             = EFI_HOB_HANDOFF_TABLE_VERSION;  Hob-&gt;BootMode            = BootMode;  Hob-&gt;EfiMemoryTop        = MemoryBegin + MemoryLength;  Hob-&gt;EfiMemoryBottom     = MemoryBegin;  Hob-&gt;EfiFreeMemoryTop    = MemoryBegin + MemoryLength;  Hob-&gt;EfiFreeMemoryBottom = (EFI_PHYSICAL_ADDRESS) (UINTN) (HobEnd + 1);  Hob-&gt;EfiEndOfHobList     = (EFI_PHYSICAL_ADDRESS) (UINTN) HobEnd;  return EFI_SUCCESS;&#125;</code></pre><blockquote><p>头和尾HOB建立后，CreateHob会覆盖尾HOB，再将尾HOB后移，此时PEI阶段的模块会相继创建各种类型的HOB，我们可以在PEI阶段自己创建HOB传递一些数据，也可以在PEI和DXE阶段找到感兴趣的HOB块，对其BLOCK数据块进行操作，但是理论上在DXE阶段使用Get方法，不建议在PEI阶段使用，是因为不确定Get的HOB是否已经建立，即无法判断两个Pei ModulePart的执行顺序，当然也可以通过Deepx来限定ModulePart跑的顺序</p></blockquote><h1 id="作业Demo"><a href="#作业Demo" class="headerlink" title="作业Demo"></a>作业Demo</h1><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603960797904.png" alt="HOB Homework"></p><ul><li>OemHob.h</li></ul><pre><code>#ifndef __OEM_HOB_H__#define __OEM_HOB_H__#ifdef __cplusplusextern &quot;C&quot; &#123;#endif#define OEM_HOB_GUID \    &#123;0xe73e6c2b, 0xaa9a, 0x4b51, 0x94, 0x56, 0x50, 0xd2, 0x8b, 0xcc, 0x57, 0xf3&#125;typedef struct _OEM_HOB&#123;       EFI_HOB_GUID_TYPE GuidExtension;    CHAR8 OemString[10];    UINT16 MemorySpace;  &#125; OEM_HOB;/****** DO NOT WRITE BELOW THIS LINE *******/#ifdef __cplusplus&#125;#endif#endif</code></pre><ul><li>PeiCreateHob.c</li></ul><pre><code>#include &lt;AmiPeiLib.h&gt;#include &lt;Library/PeiServicesLib.h&gt;#include &lt;Library/HobLib.h&gt;#include &lt;OemHob.h&gt;#include &lt;MemInfoHob.h&gt;extern EFI_GUID gSiMemoryInfoDataGuid;EFI_STATUS PeiCreateHobEntryPoint(   IN EFI_PEI_FILE_HANDLE   FileHandle,   IN CONST EFI_PEI_SERVICES  **PeiServices)&#123;    EFI_STATUS    Status = EFI_SUCCESS;    OEM_HOB       *pHob     = NULL;    VOID          *Memory_Hob  = NULL;    EFI_GUID      OemHobGuid = OEM_HOB_GUID;    EFI_GUID      MemoryInfoDataGuid = gSiMemoryInfoDataGuid;    //CHAR8         BIOSVersion[] = CONVERT_TO_STRING(PLATFORM_NAME);    CHAR8         BIOSVersion[10]=&quot;kabylake&quot;;    UINT16        MemorySize = 0;    // Get physical address bits supported.    Memory_Hob = GetFirstGuidHob(&amp;MemoryInfoDataGuid);    if (Memory_Hob != NULL) &#123;        MemorySize = ((MEMORY_INFO_DATA_HOB *) Memory_Hob)-&gt;TotalPhysicalMemorySize;        DEBUG((-1,&quot;\nElder has been got MemoryInfoDataHob in Pei Phase!&quot;));        DEBUG((-1,&quot;\nMemoryInfoDataHob Address : %p&quot;,Memory_Hob));      &#125;     //create HOB for DXE    Status = (*PeiServices)-&gt;CreateHob (PeiServices,                                        EFI_HOB_TYPE_GUID_EXTENSION,                                         sizeof(OEM_HOB),                                         &amp;pHob);    if (!EFI_ERROR(Status))&#123;           pHob-&gt;GuidExtension.Name = OemHobGuid;           Strcpy(pHob-&gt;OemString,BIOSVersion);           pHob-&gt;MemorySpace = MemorySize;                      DEBUG((-1,&quot;\nElder has been Created OemHob Success in Pei Phase!&quot;));                  &#125;    return EFI_SUCCESS;&#125;</code></pre><ul><li>DxeFindHob.c</li></ul><pre><code>#include &lt;AmiDxeLib.h&gt;#include &lt;Library/HobLib.h&gt;#include &lt;OemHob.h&gt;EFI_STATUS DxeFindHobEntryPoint(    IN EFI_HANDLE ImageHandle,    IN EFI_SYSTEM_TABLE *SystemTable)&#123;    EFI_STATUS      Status = EFI_SUCCESS;    EFI_GUID        OemHobGuid = OEM_HOB_GUID;    OEM_HOB         *pHob = NULL;    InitAmiLib (ImageHandle , SystemTable) ;    pHob = (OEM_HOB*)GetFirstGuidHob (&amp;OemHobGuid);    if (pHob == NULL)        &#123;            DEBUG((-1,&quot;\n Elder Dxe Phase return OemHob Data Error!\n&quot;));        &#125;    else        &#123;            DEBUG((-1,&quot;\n Elder OemHob Address = %p\n&quot;,pHob));                DEBUG((-1,&quot;\n Elder Dxe Phase has been got HobData OemString = %s\n&quot;,pHob-&gt;OemString));            DEBUG((-1,&quot;\n Elder Dxe Phase has been got HobData MemorySpace = %d MB\n&quot;,pHob-&gt;MemorySpace));        &#125;    return EFI_SUCCESS;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 概念,code,数据结构,使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
