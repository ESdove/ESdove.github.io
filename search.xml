<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/08/03/UEFI%20BIOS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>2021/08/03/UEFI%20BIOS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="UEFI-BIOS启动流程"><a href="#UEFI-BIOS启动流程" class="headerlink" title="UEFI BIOS启动流程"></a>UEFI BIOS启动流程</h1><blockquote><p>EFI系统表是UEFI 规范定义的最重要的数据结构，它的指针会被当作入口参数传递给每个驱动和应用程序， 进而驱动和应用程序就可以从这个数据结构得到系统的配置信息和丰富的系统服务</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// EFI System Table</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The table header for the EFI System Table.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_TABLE_HEADER                  Hdr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// A pointer to a null terminated string that identifies the vendor</span>  <span class="token comment" spellcheck="true">/// that produces the system firmware for the platform.</span>  <span class="token comment" spellcheck="true">///</span>  CHAR16                            <span class="token operator">*</span>FirmwareVendor<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// A firmware vendor specific value that identifies the revision</span>  <span class="token comment" spellcheck="true">/// of the system firmware for the platform.</span>  <span class="token comment" spellcheck="true">///</span>  UINT32                            FirmwareRevision<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The handle for the active console input device. This handle must support</span>  <span class="token comment" spellcheck="true">/// EFI_SIMPLE_TEXT_INPUT_PROTOCOL and EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HANDLE                        ConsoleInHandle<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// A pointer to the EFI_SIMPLE_TEXT_INPUT_PROTOCOL interface that is</span>  <span class="token comment" spellcheck="true">/// associated with ConsoleInHandle.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_SIMPLE_TEXT_INPUT_PROTOCOL    <span class="token operator">*</span>ConIn<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The handle for the active console output device.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HANDLE                        ConsoleOutHandle<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// A pointer to the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL interface</span>  <span class="token comment" spellcheck="true">/// that is associated with ConsoleOutHandle.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL   <span class="token operator">*</span>ConOut<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The handle for the active standard error console device.</span>  <span class="token comment" spellcheck="true">/// This handle must support the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HANDLE                        StandardErrorHandle<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// A pointer to the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL interface</span>  <span class="token comment" spellcheck="true">/// that is associated with StandardErrorHandle.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL   <span class="token operator">*</span>StdErr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// A pointer to the EFI Runtime Services Table.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_RUNTIME_SERVICES              <span class="token operator">*</span>RuntimeServices<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// A pointer to the EFI Boot Services Table.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_BOOT_SERVICES                 <span class="token operator">*</span>BootServices<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The number of system configuration tables in the buffer ConfigurationTable.</span>  <span class="token comment" spellcheck="true">///</span>  UINTN                             NumberOfTableEntries<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// A pointer to the system configuration tables.</span>  <span class="token comment" spellcheck="true">/// The number of entries in the table is NumberOfTableEntries.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_CONFIGURATION_TABLE           <span class="token operator">*</span>ConfigurationTable<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_SYSTEM_TABLE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/image-20210620011215626.png" alt="image-20210620011215626"></p><ul><li><p>EFI 系统表中的启动时服务只在操作系统运行时之前是可用的， 而运行时服务则在操作系统运行时之前和操作系统运行时都是可用的</p></li><li><p>UEFI 规范定义的Handle 数据库是UEFI 需要维护的最重要的对象库，由Handle 和协议(Protocol)组成。 这个Handle 数据库是所有的UEFI Handle 的列表， 每个Handle 上可以挂载一个或者多个协议</p></li><li><p> 协议是GUID（Globally Unique Identifier， 全局唯一标识符）来命名并唯一标识的结构体， 可能包含一些函数指针和数据结构体，即用面向对象的C Struct模拟Class实现OOP，最小的协议可以只定义GUID，而不包含任何函数指针或者数据结构体。 换句话说， GUID 是一个协议必须要定义的</p></li><li><p>协议通过挂载在Handle 上来进行使用， 跟Handle 一起存放在Handle 数据库中。 系统中的其他函数通过GUID 在Handle 数据库中查找对应的协议</p></li><li><p>Handle和Protocol的数据结构实质表征是双向环链表， UEFI 的可扩展特性很大程度上就体现在协议上</p></li></ul><p><strong>基于UEFI和PI规范实现的UEFI BIOS启动流程如下：</strong></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/image-20210620011020584.png" alt="image-20210620011020584"></p><p>按照启动先后顺序， 该流程分为以下7个阶段：</p><ul><li>1） 安全检测(SEC， Security)阶段</li><li>2） EFI初始化准备(PEI， Pre-EFI Initialization)阶段</li><li>3） 驱动程序执行环境(DXE， Driver Execution Environment)阶段</li><li>4） 启动设备选择(BDS， Boot Device Selection)阶段</li><li>5） 瞬时系统加载(TSL， Transient System Load)阶段</li><li>6） 运行时(RT， Run Tim e)阶段</li><li>7） 生命周期后(AL， After Life)阶段</li></ul><h2 id="安全检测-SEC-阶段"><a href="#安全检测-SEC-阶段" class="headerlink" title="安全检测(SEC)阶段"></a>安全检测(SEC)阶段</h2><ul><li><p>在X86的计算机系统上， 系统开机，硬件电路重置寄存器的值(ResetVector) ，CPU从4GB的最高端地址FFFFFFF0h开始执行指令(映射到Nor Flash上的BIOS芯片)</p></li><li><p>ResetVector组件会被打包成一个固件文件系统(FFS， Firmware File System)高文件卷文件(VTF， Volume Top File)，它负责找到和执行SecCore(SECURITY CORE)模块 </p></li><li><p>SecCore模块会进行基本的系统初始化、 为CPU打微码补丁、 初始化CAR(Cache As RAM)、 切换到保护模式、 获取启动固件卷(BFV， Boot Firmware Volume)的地址和找到PeiCore(PEI_CORE)及其入口地址以准备进入PEI阶段</p></li><li><p>在CAR被初始化好之前， 系统没有内存来作为堆栈使用， ResetVector组件和SecCore模块的代码采用汇编实现； 在CAR被初始化好之后， 一小块CPU cache空间将被当作临时内存(temporary memory)来使用， SecCore模块会进入C语言执行环境 </p></li><li><p>SecCore 模块利用获取的启动固件卷地址和初始化了的CAR 来给EFI_SEC_PEI_HAND_OFF中的启动固件卷地址和大小、 临时内存地址和大小、PEI 临时内存地址和大小以及栈地址和大小域赋值， 最后把EFI_SEC_PEI_HAND_OFF与SEC阶段提供的PpiList一起传递给PeiCore， 从而进入PEI阶段</p></li><li><p>SEC阶段提供的PpiList 可能会包含安全或者验证服务， 如TCG(Trusted Computing Group)访问服务， 因为在一个遵循TCG的系统中， SEC就是可信度量根的核心(CRTM， Core Root-of-Trust Measurement)</p></li></ul><h2 id="EFI-初始化准备-PEI-阶段"><a href="#EFI-初始化准备-PEI-阶段" class="headerlink" title="EFI 初始化准备(PEI)阶段"></a>EFI 初始化准备(PEI)阶段</h2><blockquote><p>PEI阶段的主要任务是决定系统的启动路径（正常启动、 S3唤醒或者Recovery等)，初始化各种平台硬件， 包括CPU和芯片组等，检测和初始化系统内存，报告和处理DXE固件卷，最后找到DxeCore(DXE_CORE)及其入口地址以进入DXE阶段</p></blockquote><ul><li><p>PeiCore(PEI_CORE)首先会对PEI的基础服务（如内存、 HOB、 PPI和FV服务等）进行初始化</p></li><li><p>接着PEI调度器开始利用FV服务根据固件文件系统的格式从启动固件卷查找PEI模块， 检查它们的依赖关系(dependency expression)是否已经满足， 进而执行PEI模块， PEI模块可能会产生PPI为其它PEI模块提供服务， DxeIpl PEI模块会产生DxeIpl PPI</p></li><li><p>内存初始化模块在检测和初始化系统内存之后会通过PEI的基础服务InstallPeiMemory来向PeiCore报告PEI阶段可用的常驻内存(permanent memory)和建立Resource HOB来报告系统内存</p></li><li><p>接着PeiCore将会迁移PEI正在使用的临时内存（包括栈(stack)和堆(heap)， HOB列表就在堆中）里面的所有数据到常驻内存中去， 以及产生MemoryDiscovered PPI来通知其它所有依赖于系统内存的PEI模块， 让它们知道系统内存可以使用了</p></li><li><p>然后其它PEI模块通过PEI基础服务NotifyPpi注册的MemoryDiscovered PPI回调函数(callback)就会被执行， 如平台PEI模块注册的MemoryDiscovered PPI回调函数可能会设置系统内存的缓存属性和通过产生FvInfo PPI来报告DXE固件卷</p><p><strong>PEI阶段的内存映射和使用如下：</strong></p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/image-20210620012406859.png" alt="image-20210620012406859"></p><ul><li><p>PEI调度器在执行完所有的PEI模块之后会调用DxeIpl PPI， 接着DxeIpl PPI就会从DXE固件卷中找到DxeCore及其入口地址， 最后把PEI阶段建立的HOB列表传递给DxeCore， 从而进入DXE阶段</p></li><li><p>在X86的计算机系统上， 如果DXE阶段为64位， DxeIpl PPI在执行DxeCore之前还需要建立页表(page table)和切换CPU到IA32e模式(long mode)</p></li><li><p>PEI阶段建立的HOB列表如下图所示， 开始的一个HOB必须是PHIT(Phase Handoff Information Table) HOB， 最后一个HOB必须是end of list HOB</p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/image-20210620011130677.png" alt="image-20210620011130677"></p><h2 id="驱动程序执行环境-DXE-阶段"><a href="#驱动程序执行环境-DXE-阶段" class="headerlink" title="驱动程序执行环境(DXE)阶段"></a>驱动程序执行环境(DXE)阶段</h2><ul><li><p>DXE阶段包含的组件： DXE Foundation、 DXE调度器和DXE驱动程序，DXE阶段的主要任务是生成一套完整的UEFI接口， 和后续的BDS阶段一起工作， 建立控制台并尝试启动操作系统</p></li><li><p>DXE阶段是UEFI BIOS最重要的阶段DxeCore(DXE_CORE)首先会初始化启动时服务表、 运行时服务表和DXE服务表， 利用PEI阶段传递过来的HOB列表中的Resource HOB初始化DXE服务表中的GCD(Global Coherency Domain)服务以及启动时服务表中的内存服务，基于HOB列表中的FV HOB产生FVB协议及FV协议 </p></li><li><p>DxeCore还会把DXE服务表和HOB列表安装到EFI系统表的配置表(ConfigurationTable)中。接着DXE调度器会开始利用FV协议根据固件文件系统的格式从DXE固件卷查找DXE驱动，检查它们的依赖关系是否已经满足， 进而执行DXE驱动</p></li><li><p>DXE驱动有两类： 较早执行的DXE驱动和UEFI驱动（符合UEFI驱动模型的DXE驱动）。 较早执行的DXE驱动程序会初始化平台硬件， 包括CPU和芯片组等， 安装配置表（如ACPI Table和SMBIOS Table就会被相应的DXE驱动安装到配置表中）和产生架构协议（例如DXE Variable驱动就会产生Variable架构协议和Variable Write架构协议， BDS驱动会产生BDS架构协议）等 </p></li><li><p>如下图所示DXE阶段产生的架构协议， 架构协议基本上与EFI系统表中的启动时服务和运行时服务相对应。 UEFI驱动在所有的架构协议产生之后才会被执行， 它们会产生Driver Binding协议， 这些Driver Binding协议在BDS阶段连接控制器（利用启动时服务表中的ConnectController接口）的时候会被连接， 进而为控制台和启动设备提供软件抽象</p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/image-20210620011449280.png" alt="image-20210620011449280"></p><ul><li>DXE阶段会生成一套完整的UEFI接口， DXE调度器在执行完所有的DXE驱动之后会调用BDS架构协议， 从而进入BDS阶段， DXE阶段和BDS阶段一起工作来建立可供操作系统启动的平台。 注意， 只有EFI系统表中的运行时服务和由运行时DXE驱动程序提供的服务在操作系统运行阶段还继续存在</li></ul><h2 id="启动设备选择-BDS-阶段"><a href="#启动设备选择-BDS-阶段" class="headerlink" title="启动设备选择(BDS)阶段"></a>启动设备选择(BDS)阶段</h2><ul><li><p>BDS阶段的主要功能就是为平台选择一个合适的启动设备， 并尝试加载它</p></li><li><p>BDS架构协议是DXE阶段的BDS驱动产生的， DXE调度器在执行完所有的DXE驱动之后会调用BDS架构协议， 从而进入BDS阶段</p></li><li><p>在BDS阶段， BDS架构协议在连接控制器（利用启动时服务表中的ConnectController接口）的时候连接DXE阶段UEFI驱动产生的Driver Binding协议， 进而为控制台和启动设备提供软件抽象。 </p></li><li><p>BDS阶段是一个独特的启动管理阶段， 根据平台的启动策略，UEFI规范定义的全局启动选项Variable L”Boot####”和启动选项顺序VariableL “BootOrder”会被建立</p></li><li><p>一个启动选项对应于相应启动设备中的一个UEFI应用程序(APPLICATION)， 如UEFI BIOS的SETUP、 启动菜单、 扩展的诊断工具和操作系统加载器等等</p></li><li><p>UEFI启动管理器会按照启动顺序来引导启动选项， 启动选项对应的UEFI应用程序会被加载和执行 </p></li><li><p>如果是操作系统加载器被加载和执行， 操作系统加载器就会获得控制权， 然后进入接下来的TSL阶段来加载操作系统</p></li></ul><h2 id="瞬时系统加载-TSL-阶段"><a href="#瞬时系统加载-TSL-阶段" class="headerlink" title="瞬时系统加载(TSL)阶段"></a>瞬时系统加载(TSL)阶段</h2><ul><li><p>操作系统加载器在BDS 阶段被加载和执行， EFI 系统表的指针会被当作入口参数传递给操作系统加载器 </p></li><li><p>在TSL 阶段， 操作系统加载器会使用UEFI接口加载操作系统</p></li><li><p>TSL 阶段结束及操作系统运行时阶段开始的标志是操作系统加载器调用启动时服务表中的ExitBootServices 接口</p></li><li><p>ExitBootServices 接口会触发ExitBootServices 事件来通知其它模块启动时服务将要被终止了</p></li></ul><h2 id="运行时-RT-阶段"><a href="#运行时-RT-阶段" class="headerlink" title="运行时(RT)阶段"></a>运行时(RT)阶段</h2><ul><li>操作系统加载器在TSL 阶段调用启动时服务表中的ExitBootServices 接口而进入操作系统运行时阶段</li><li> 启动时服务表中的ExitBootServices 接口一旦被调用， EFI 系统表中所有的启动时服务都会被终止， 结果就只有EFI 系统表中的配置表和运行时服务在操作系统运行时阶段可用 </li><li>操作系统可以从操作系统加载器得到EFI 系统表的指针， 通过这个指针， 操作系统可以获得各种平台配置信息（如从配置表得到ACPI 表和SMBIOS 表等）和访问运行时服务</li></ul><h2 id="生命周期后-AL-阶段"><a href="#生命周期后-AL-阶段" class="headerlink" title="生命周期后(AL)阶段"></a>生命周期后(AL)阶段</h2><ul><li><p>生命周期后阶段代表的是平台的控制权从操作系统端重新回到了UEFI BIOS 端</p></li><li><p>这个阶段可以说是操作系统运行时阶段的延续， 可能是重启系统（如操作系统调用运行时服务表ResetSystem 接口）、 进入到ACPI 睡眠状态（如进入到S3， S5）或者进入SMM（在X86 CPU 检查到一种特殊的系统中断SMI的时候， 处理器会进入一种特殊的操作模式， 这种操作模式叫做SMM， 它对于OS 来说是完全透明的)等</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/08/03/Source%20%20Level%20%20Debugger/"/>
      <url>2021/08/03/Source%20%20Level%20%20Debugger/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><div style="page-break-after:always"></div><h2 id="Debug-VS-Trace"><a href="#Debug-VS-Trace" class="headerlink" title="Debug VS Trace"></a>Debug VS Trace</h2><h3 id="Debug-Static"><a href="#Debug-Static" class="headerlink" title="Debug(Static)"></a>Debug(Static)</h3><ul><li>Run - Control(Break,Halt,Go)</li><li>Code Walking(stepping and running to a break)</li></ul><h3 id="Trace-Dynamic"><a href="#Trace-Dynamic" class="headerlink" title="Trace(Dynamic)"></a>Trace(Dynamic)</h3><ul><li>Root causing more obscure(hard to find) bugs</li><li>These are the few bugs that really blow up the schedule</li><li>Finding these bugs is where Trace shines</li></ul><h2 id="Requirements-for-Hardware"><a href="#Requirements-for-Hardware" class="headerlink" title="Requirements for Hardware"></a>Requirements for Hardware</h2><blockquote><p><a href="https://designintools.intel.com/Debug_Tools_s/1862.htm">Intel Debug Tools</a> </p></blockquote><blockquote><p>现在的X86变得日益复杂，如何进行有效的Debug 也日渐成为一个难题。为此 Intel 在芯片组或者 CPU 上预留了一个称作<strong>DCI （Intel® Direct Connect Interface）</strong>的Debug 接口。这个接口使用 USB 3.0一模一样的外部连接。CPU 内部有切换器，当Chipset 发现外部有设备和他握手，就将原本的USB信号切换为DCI 的信号。这样无需额外的预留就能实现Debug</p></blockquote><blockquote><p>在DCI 出现之前，Intel 使用JTAG 接口。当时的 Debug 盒子叫做 <strong>In-Target Proble</strong>，简称 ITP。为了Debug，主板上同时必须预留JTAG接口。显而易见，说服HW工程师在主板上预留这样的接口需要花费极大的口舌，至于在量产板子上焊接这样的接口几乎是不可能的事情。因此，串口一直是BIOS工程师的最爱</p></blockquote><blockquote><p>现在的Debug 盒子全称是<strong>“Intel SVT Closed Chassis Adapter”，缩写 “CCA”</strong>（Intel Silicon View Technology Closed Chassis Adapter）, 更通俗称<strong>DCI 蓝盒子</strong></p></blockquote><blockquote><p>除此之外还有长得类似 WinDBG 线的 <strong>DbC</strong>（ debug class 线），同样是插在 USB 3.0 口上就能进行Debug</p></blockquote><h2 id="Requirements-For-Software"><a href="#Requirements-For-Software" class="headerlink" title="Requirements For Software"></a>Requirements For Software</h2><blockquote><p>基本开发运行环境</p></blockquote><ul><li>Python</li><li>GIT</li><li>C/C++运行环境</li><li>JRE</li></ul><h2 id="Source-Level-Debugger应用场景"><a href="#Source-Level-Debugger应用场景" class="headerlink" title="Source Level Debugger应用场景"></a>Source Level Debugger应用场景</h2><ul><li>实际硬件支持的CRB或OEM BOARD Project（侧重解bug）</li></ul><blockquote><p>AMI VEB  OR Intel System Debugger</p></blockquote><ul><li>edk2内核Source（侧重追内核实现code，测试开发Tools）</li></ul><blockquote><p>EmulatorPkg(VSCode + Visual Studio)</p></blockquote><blockquote><p>OvmfPkg(QEMU + udk_debugger_tool + windbg)</p></blockquote><div style="page-break-after:always"></div><h2 id="Demo-For-AMI-Veb-Trace-Hub-Debugger"><a href="#Demo-For-AMI-Veb-Trace-Hub-Debugger" class="headerlink" title="Demo For AMI Veb Trace Hub Debugger"></a>Demo For AMI Veb Trace Hub Debugger</h2><h3 id="Connect-Target和Host"><a href="#Connect-Target和Host" class="headerlink" title="Connect Target和Host"></a>Connect Target和Host</h3><blockquote><p> <strong>(Intel)Comet Lake Platform</strong> ，Target端连上USB2.0或者3.0的Port，不一定都可以，可以看调试器DCI CONNECT指示灯来判定</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210520142815249.png" alt="image-20210520142815249"></p><p><img src="http://tc.holychen.cn/image/image-20210522211723225.png" alt="image-20210522211723225"></p><p><img src="http://tc.holychen.cn/image/image-20210522215057481.png" alt="image-20210522215644885"></p><h3 id="SVN导入相关Modules"><a href="#SVN导入相关Modules" class="headerlink" title="SVN导入相关Modules"></a>SVN导入相关Modules</h3><blockquote><p> Release Project Code一般会拿掉Debug相关的Modules，要支持Veb Trace Hub Function，Source Code要导入Debugger和DebuggerCollaterals Module，可以查看相关CHM文件，注意两个Module Version之间的Dependency，查看AMI_Debug_for_Trace_Hub_User_Manual_NDA.pdf知道是否Support对应Platform的DEBUG和Trace以及Guide.</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210524125730073.png" alt="image-20210524125730073"></p><h3 id="NDACollaterals配置"><a href="#NDACollaterals配置" class="headerlink" title="NDACollaterals配置"></a>NDACollaterals配置</h3><blockquote><p>安装CCA Debug Driver和Install.exe导入Trace Hub相关scripts到对应版本的Veb目录下，注意目前只Support JRE8，如果安装其它版本的JDK或者JRE并设置了环境变量，有遇到过Debug_loader报错的情况，可以用VisualeBiosWithJRE目录下的veb</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210522215057481.png" alt="image-20210522215057481"></p><p><img src="http://tc.holychen.cn/image/image-20210524125857568.png" alt="image-20210524125857568"></p><div style="page-break-after:always"></div><h3 id="BIOS-Setup-Settings"><a href="#BIOS-Setup-Settings" class="headerlink" title="BIOS Setup Settings"></a>BIOS Setup Settings</h3><blockquote><p>Target需要修改如下items setting，或者Host build source code时直接修改debugsetup.hfr，避免调Target端item settings，因为有的Project会隐藏CRB默认的items，需要Tool set bit位来调出</p></blockquote><ul><li><p><strong>Trace Hub Enable Mode : Advanced -&gt; Debug Settings -&gt; Advanced Debug Settings -&gt; PCH Trace Hub Enable Mode（Host Debugger）</strong></p></li><li><p><strong>Platform Debug Consent : Advanced -&gt; Debug Settings -&gt; Platform Debug Consent(Enabled(DCI OOB + [Dbc]))</strong></p></li></ul><pre class="line-numbers language-c"><code class="language-c">``` oneof varid  <span class="token operator">=</span> PCH_SETUP<span class="token punctuation">.</span>PchTraceHubMode<span class="token punctuation">,</span>    prompt   <span class="token operator">=</span> <span class="token function">STRING_TOKEN</span><span class="token punctuation">(</span>STR_PCH_TRACE_HUB_PROMPT<span class="token punctuation">)</span><span class="token punctuation">,</span>    help     <span class="token operator">=</span> <span class="token function">STRING_TOKEN</span><span class="token punctuation">(</span>STR_TRACE_HUB_MODE_HELP<span class="token punctuation">)</span><span class="token punctuation">,</span>    option text <span class="token operator">=</span> <span class="token function">STRING_TOKEN</span><span class="token punctuation">(</span>STR_DISABLED<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> flags <span class="token operator">=</span> RESET_REQUIRED<span class="token punctuation">;</span>    option text <span class="token operator">=</span> <span class="token function">STRING_TOKEN</span><span class="token punctuation">(</span>STR_TRACE_HUB_TARGET_DEBUGGER<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> flags <span class="token operator">=</span> RESET_REQUIRED<span class="token punctuation">;</span>    option text <span class="token operator">=</span> <span class="token function">STRING_TOKEN</span><span class="token punctuation">(</span>STR_TRACE_HUB_HOST_DEBUGGER<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> flags <span class="token operator">=</span> DEFAULT <span class="token operator">|</span> MANUFACTURING <span class="token operator">|</span> RESET_REQUIRED<span class="token punctuation">;</span>    endoneof<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c">TOKEN    Name  <span class="token operator">=</span> <span class="token string">"PLATFORM_DEBUG_CONSENT_DEFAULT"</span>    Value  <span class="token operator">=</span> <span class="token string">"1"</span>    Help  <span class="token operator">=</span> <span class="token string">"Default value of Platform Debug Consent for Trace Hub. 0:Disabled / 1:DCI OOB+[DbC] / 2:DCI OOB / 3:USB3 DbC / 4:XDP/MIPI60 / 5:USB2 DbC"</span>    TokenType <span class="token operator">=</span> Integer    TargetMAK <span class="token operator">=</span> Yes    TargetH <span class="token operator">=</span> YesEnd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Build-Token-Settings"><a href="#Build-Token-Settings" class="headerlink" title="Build Token Settings"></a>Build Token Settings</h3><ul><li><p><strong>“DEBUG_MODE”                                         Enabled</strong></p></li><li><p>**”AmiTraceHubDebugger_Support “           Enabled **</p></li><li><p><strong>“PLATFORM_DEBUG_CONSENT_DEFAULT”    1</strong></p></li></ul><div style="page-break-after:always"></div><h3 id="导入证书"><a href="#导入证书" class="headerlink" title="导入证书"></a>导入证书</h3><blockquote><p>对应路径Help -&gt; Mange  Debugger License，证书需要获得AMI授权</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210522215320246.png" alt="image-20210522215320246"></p><h3 id="配置Trace-Hub-Options"><a href="#配置Trace-Hub-Options" class="headerlink" title="配置Trace Hub Options"></a>配置Trace Hub Options</h3><blockquote><p>需要根据硬件调试工具连接方式选取对应 Hardware Probe，Platform Processor和Platform PCH也都需要对应上，如果列表没有合适的选项可以对应，会出现Target端Detected不到的情况，可以尝试更新DebuggerCollaterals Module获取最新Support的Lists或者与Module Owner确认</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210522215818919.png" alt="image-20210522215818919"></p><h3 id="配置Xml"><a href="#配置Xml" class="headerlink" title="配置Xml"></a>配置Xml</h3><blockquote><p>对应Board 的XML需要Enabled如下设置</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210522220105783.png" alt="image-20210522220105783"></p><p><img src="http://tc.holychen.cn/image/image-20210522220219638.png" alt="image-20210522220219638"></p><div style="page-break-after:always"></div><h3 id="Trace-Hub-Debugging"><a href="#Trace-Hub-Debugging" class="headerlink" title="Trace Hub Debugging"></a>Trace Hub Debugging</h3><blockquote><p>Flash Full Bin to Target and Start Trace Hub Debugging，Loaded Driver View视图中可以看到依次加载的Module，此时寻找感兴趣的Module或者可疑的点，可以下断点调试，View call stack、Memory、Variable、Expression、Disassembly、Register、Console Log and so on.</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210523202215441.png" alt="image-20210523202215441"></p><div style="page-break-after:always"></div><h2 id="Demo-for-Intel-system-debugger"><a href="#Demo-for-Intel-system-debugger" class="headerlink" title="Demo for Intel system debugger"></a>Demo for Intel system debugger</h2><blockquote><p>会遇到有些平台AMI VEB还不支持，但Intel System Debuger可以跟进源码，软件调试时使用上大同小异，可以参照Help文档或者寻求Intel的Support</p></blockquote><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p><img src="http://tc.holychen.cn/image/image-20210524131438876.png" alt="image-20210524131438876"></p><p><img src="http://tc.holychen.cn/image/image-20210524131500224.png" alt="image-20210524131500224"></p><h3 id="Debug-Configuration"><a href="#Debug-Configuration" class="headerlink" title="Debug Configuration"></a>Debug Configuration</h3><blockquote><p>设为单线程方便Halt，加入需要Debug的Source的路径</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210524131700261.png" alt="image-20210524131700261"></p><p><img src="http://tc.holychen.cn/image/image-20210524131755466.png" alt="image-20210524131755466"></p><h3 id="Launch-and-Debugging"><a href="#Launch-and-Debugging" class="headerlink" title="Launch and Debugging"></a>Launch and Debugging</h3><p><img src="http://tc.holychen.cn/image/image-20210524130519652.png" alt="image-20210524130519652"></p><div style="page-break-after:always"></div><h2 id="Demo-for-edk2内核源码"><a href="#Demo-for-edk2内核源码" class="headerlink" title="Demo for edk2内核源码"></a>Demo for edk2内核源码</h2><h3 id="代码部署"><a href="#代码部署" class="headerlink" title="代码部署"></a>代码部署</h3><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619517129215.png"></p><blockquote><p>github下载较慢，通过代理挂在美国的节点会快点，也可通过gitee平台，备份edk2和submoulde仓库再进行update</p></blockquote><ul><li>此时需要修改根目录下.gitmodules为对应路径<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619517342071.png"></li></ul><h3 id="编译相关Tool部署"><a href="#编译相关Tool部署" class="headerlink" title="编译相关Tool部署"></a>编译相关Tool部署</h3><ul><li><a href="https://www.nasm.us/">NASM</a></li><li><a href="https://acpica.org/downloads/binary-tools">IASL编译器</a></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619517917113.png"></p><div style="page-break-after:always"></div><blockquote><p>推荐都放在C盘根目录，并设置环境变量，不然需要修改tools_def.txt，edksetup.bat的Tool路径</p></blockquote><ul><li>不设置环境变量，修改Tool路径做法</li></ul><ul><li><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619518038304.png"></li></ul><h3 id="编译edk2-EmulatorPkg"><a href="#编译edk2-EmulatorPkg" class="headerlink" title="编译edk2 EmulatorPkg"></a>编译edk2 EmulatorPkg</h3><ul><li>edksetup.bat rebuild  //重新获取配置的环境变量,会在Conf目录下建立target.txt,Tools_def.txt等文件</li><li>build -t VS2017 -a IA32 -y Report.txt //-t 指定ToolChain -a 指定TargetArch -y 生成格式化的Report.txt<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619518234669.png"></li></ul><div style="page-break-after:always"></div><h3 id="调试edk2-执行Winhost-exe"><a href="#调试edk2-执行Winhost-exe" class="headerlink" title="调试edk2(执行Winhost.exe)"></a>调试edk2(执行Winhost.exe)</h3><ul><li>在需要调试代码处加上CpuBreakpoint(),并修改注册表如下,触发异常会调出Visual Studio作为调试器</li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619518365699.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619519544086.png"></p><h3 id="Start-Debugging"><a href="#Start-Debugging" class="headerlink" title="Start Debugging"></a>Start Debugging</h3><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619520470753.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/08/03/Git%E4%BD%BF%E7%94%A8/"/>
      <url>2021/08/03/Git%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><h2 id="配置和和查看用户信息"><a href="#配置和和查看用户信息" class="headerlink" title="配置和和查看用户信息"></a>配置和和查看用户信息</h2><p>查看git版本信息</p><pre class="line-numbers language-c"><code class="language-c">git config <span class="token operator">--</span>version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置user.name和user.email</p><pre class="line-numbers language-c"><code class="language-c">git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"yourname"</span>git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"your_email@domain.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>检查当前配置</p><pre class="line-numbers language-c"><code class="language-c">git config <span class="token operator">--</span>list <span class="token operator">--</span>local <span class="token comment" spellcheck="true">//local只对某个仓库有效</span>git config <span class="token operator">--</span>list <span class="token operator">--</span>global<span class="token comment" spellcheck="true">//global对当前用户所有仓库有效</span>git config <span class="token operator">--</span>list <span class="token operator">--</span>system<span class="token comment" spellcheck="true">//system对系统所有登录的用户有效</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看更多help信息</p><pre class="line-numbers language-c"><code class="language-c">git <span class="token operator">--</span>help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Git常规操作"><a href="#Git常规操作" class="headerlink" title="Git常规操作"></a>Git常规操作</h2><h3 id="把已有的项目代码纳入Git管理"><a href="#把已有的项目代码纳入Git管理" class="headerlink" title="把已有的项目代码纳入Git管理"></a>把已有的项目代码纳入Git管理</h3><pre class="line-numbers language-c"><code class="language-c">cd 项目代码所在的文件夹git init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看版本演变历史</p><pre class="line-numbers language-c"><code class="language-c">git log    <span class="token comment" spellcheck="true">//默认查看当前分支</span>git log <span class="token operator">--</span>oneline <span class="token comment" spellcheck="true">//精简信息查看</span>git log <span class="token operator">-</span>n10 <span class="token operator">--</span>oneline <span class="token comment" spellcheck="true">//查看最近10条</span>git log <span class="token operator">--</span>all <span class="token operator">--</span>oneline <span class="token comment" spellcheck="true">//查看所有分支信息</span>git log <span class="token operator">--</span>all <span class="token operator">--</span>graph <span class="token comment" spellcheck="true">//所有分支图形化查看</span>git log <span class="token operator">--</span>oneline <span class="token operator">--</span>all <span class="token operator">-</span>n10 <span class="token operator">--</span>graphgitk  <span class="token comment" spellcheck="true">//查看分支通过GUI，不过第三方GUI更好使</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="给文件重命名的简便方法"><a href="#给文件重命名的简便方法" class="headerlink" title="给文件重命名的简便方法"></a>给文件重命名的简便方法</h3><blockquote><p>情形：readme属于当前分支的一支文件，想rename成readme.md</p></blockquote><pre class="line-numbers language-c"><code class="language-c">git mv readme readme<span class="token punctuation">.</span>md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这时通过git status确认下，然后即可git commit提交</p></blockquote><h3 id="commit、tree-和blob三个对象之间的关系"><a href="#commit、tree-和blob三个对象之间的关系" class="headerlink" title="commit、tree 和blob三个对象之间的关系"></a>commit、tree 和blob三个对象之间的关系</h3><pre><code>git cat-file -p hash值</code></pre><blockquote><p>一个commit对应一个tree，tree里面有可能包含tree和blob，tree可以粗略理解为文件夹，blob对应文件，blob内容没变，rename也不会重新记录</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210620220157272.png" alt="image-20210620220157272"></p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><pre class="line-numbers language-c"><code class="language-c">git branch <span class="token operator">-</span>v <span class="token comment" spellcheck="true">//查看本地所有分支</span>git branch <span class="token operator">-</span>av <span class="token comment" spellcheck="true">//查看本地和远端所有分支</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h3><blockquote><p>切到一个分支之前的commit，但没有创建新的分支，做了改动</p></blockquote><blockquote><p>如果HEAD指代当前分支的commit，HEAD~1，则指代前一个commit</p></blockquote><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><pre class="line-numbers language-c"><code class="language-c">git branch <span class="token operator">-</span>D  分支名 <span class="token comment" spellcheck="true">//需先切到别的分支</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改某分支最新的commit-message"><a href="#修改某分支最新的commit-message" class="headerlink" title="修改某分支最新的commit message"></a>修改某分支最新的commit message</h3><pre class="line-numbers language-c"><code class="language-c">git commit <span class="token operator">--</span>amend <span class="token comment" spellcheck="true">//会改变提交的 SHA-1 校验和,HEAD必须处于当前分支最后一次commit上，之前的修改commit message会处于分离头指针状态</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Edit-Notes"><a href="#Edit-Notes" class="headerlink" title="Edit Notes"></a>Edit Notes</h3><blockquote><p>可以用小乌龟Edit Notes功能说明正在开发测试的分支的改动，Pull时不会被传到远端仓库，要传到远端的话比较复杂</p></blockquote><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre class="line-numbers language-c"><code class="language-c">git checkout <span class="token operator">-</span>b M4GKT03A<span class="token operator">/</span>HolyChen<span class="token operator">/</span><span class="token number">657897</span> M4GKT02H <span class="token comment" spellcheck="true">//创建新分支可以指定基于哪个分支创建</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><pre class="line-numbers language-c"><code class="language-c">git remote add name URL <span class="token comment" spellcheck="true">//一般默认远端仓库名是origin,git clone远端仓库默认情况下本地仓库名是origin，即使远端仓库是别的name </span>git remote add temptest URL或者文件夹路径 <span class="token comment" spellcheck="true">//这样推送的话会看到远端是remotes/temptest而不是默认的origin</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>小乌龟推送master或者其它分支到另一个仓库</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210621011453815.png" alt="image-20210621011453815"></p><h3 id="已有仓库clone成裸仓库备份"><a href="#已有仓库clone成裸仓库备份" class="headerlink" title="已有仓库clone成裸仓库备份"></a>已有仓库clone成裸仓库备份</h3><blockquote><p>裸仓库并不是没有源文件，而是没有工作区的源文件。 源文件以压缩包的形式存在.git里（bare就是整个.git文件夹里的文件）。所以不需要操作的远程仓库，设成bare是明智的。 所以github等不需要特别大的空间，另：裸仓库一般加上.git后缀，所以示例可以改成Remote_test.git</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210621021150831.png" alt="image-20210621021150831"></p><h3 id="小乌龟Git-Sync功能"><a href="#小乌龟Git-Sync功能" class="headerlink" title="小乌龟Git Sync功能"></a>小乌龟Git Sync功能</h3><p><img src="http://tc.holychen.cn/image/image-20210621012343843.png" alt="image-20210621012343843"></p><blockquote><p>从中也可以看出默认push不会push tags和notes，需要手动切换</p></blockquote><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><blockquote><p>在一个测试分支中选择中间的commit，作为base，其后续的commit提交的文件和commit message都可以被修改，当然未直接pick过来的hash值也会发生变化</p></blockquote><p>cherry pick别人的分支会保留Author</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/08/03/PCIE%E8%BD%AF%E7%A1%AC%E4%BB%B6%E7%AF%87/"/>
      <url>2021/08/03/PCIE%E8%BD%AF%E7%A1%AC%E4%BB%B6%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="PCIE软硬件篇"><a href="#PCIE软硬件篇" class="headerlink" title="PCIE软硬件篇"></a>PCIE软硬件篇</h1><h2 id="PCIE映射MMIO"><a href="#PCIE映射MMIO" class="headerlink" title="PCIE映射MMIO"></a>PCIE映射MMIO</h2><blockquote><p>MMIO这段空间有256MB，因为按照PCIe规范，支持最多256个buses，每个Bus支持最多32个PCI devices，每个device支持最多8个function,也就是说：占用内存的最大值为：256 * 32 * 8 * 4K = 256MB。在台式机上我们很多时候觉得占用256MB空间太浪费（造成4G以下memory可用空间变少，虽然实际memory可以映射到4G以上，但对32位OS影响很大），PCI Bus也没有那么多，所以可以设置成最低64MB，即最多64个Bus</p></blockquote><blockquote><p>其中PCIEXBAR就是MMIO的起始位置，在4G下面占据64MB/128MB/256MB空间（4G以上部分暂不考虑），其具体位置可以由平台进行设置，设置寄存器一般在Root complex（简称RC）中</p></blockquote><h2 id="对应Platform-PCIEX-BASE-ADDRESS的获取"><a href="#对应Platform-PCIEX-BASE-ADDRESS的获取" class="headerlink" title="对应Platform PCIEX_BASE_ADDRESS的获取"></a>对应Platform PCIEX_BASE_ADDRESS的获取</h2><p>以AlderLake平台为例，Processor eds卷二Host Bridge B:0 D:0 F:0 Offset 60的位置对应PCIEX_BASE_ADDRESS</p><p><img src="http://tc.holychen.cn/image/image-20210618152305126.png" alt="image-20210618152305126"></p><p>![f02acd3f5d8bffcb969cfea8ee21abb]<br>(<a href="http://tc.holychen.cn/image/f02acd3f5d8bffcb969cfea8ee21abb.png">http://tc.holychen.cn/image/f02acd3f5d8bffcb969cfea8ee21abb.png</a>)</p><blockquote><p>通过搜索build bios生成的文件也可获得这个值</p></blockquote><h2 id="访问PCIe设备配置空间："><a href="#访问PCIe设备配置空间：" class="headerlink" title="访问PCIe设备配置空间："></a>访问PCIe设备配置空间：</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> PCIE_CFG_ADDR(bus,dev,func,reg) \  ((VOID*) (UINTN)(PCIEX_BASE_ADDRESS + ((bus) &lt;&lt; 20) + ((dev) &lt;&lt; 15) + ((func) &lt;&lt; 12) + reg))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根据这个宏定义可以访问多数PCIe设备(除了P2SB/PMC controller这种隐藏设备)的配置空间，比如VGA Controller:B:0 D:2 F:0，经过计算其配置空间起始地址:C0010000，对比从RW PCIe device获得的配置空间，两者内容相同：</p><p><img src="http://tc.holychen.cn/image/ba208a73e33dfd7eeadbcf8266ad197.png" alt="ba208a73e33dfd7eeadbcf8266ad197"></p><h2 id="获得PCIe-BAR1-BAR2…"><a href="#获得PCIe-BAR1-BAR2…" class="headerlink" title="获得PCIe BAR1\BAR2…"></a>获得PCIe BAR1\BAR2…</h2><p>PCIe超过256B以外的配置空间以Mem方式访问，该配置空间起始地址存放于BAR1\BAR2，其Register offset分别为0x10\0x14，我们看下XHCI 配置空间为C00A0000/XHCI Bar Address为0x6001100000：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> PCI_BUS_NUMBER_PCH_XHCI             0</span><span class="token macro property">#<span class="token directive keyword">define</span> PCI_DEVICE_NUMBER_PCH_XHCI          20</span><span class="token macro property">#<span class="token directive keyword">define</span> PCI_FUNCTION_NUMBER_PCH_XHCI        0</span>    XhciPciMmBase   <span class="token operator">=</span> <span class="token function">MmPciBase</span> <span class="token punctuation">(</span>                      DEFAULT_PCI_BUS_NUMBER_PCH<span class="token punctuation">,</span>                      PCI_DEVICE_NUMBER_PCH_XHCI<span class="token punctuation">,</span>                      PCI_FUNCTION_NUMBER_PCH_XHCI                      <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获得XHci BAR Address</span>    UsbBase <span class="token operator">=</span> <span class="token function">MmioRead32</span> <span class="token punctuation">(</span>XhciPciMmBase <span class="token operator">+</span> PCI_BASE_ADDRESSREG_OFFSET <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                UsbBase <span class="token operator">=</span> <span class="token punctuation">(</span>UsbBase <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                UsbBase <span class="token operator">|</span><span class="token operator">=</span> <span class="token function">MmioRead32</span> <span class="token punctuation">(</span>XhciPciMmBase <span class="token operator">+</span> PCI_BASE_ADDRESSREG_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>                UsbBase <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0xFFFFFFFFFFFF0000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="神秘的P2SB接口"><a href="#神秘的P2SB接口" class="headerlink" title="神秘的P2SB接口"></a>神秘的P2SB接口</h2><p>PCH EDS Vol2中规定，Intel PCH通过P2SB(Primary to Sideband Bridge)接口，以下列公式访问GPIO Pad：</p><p><img src="http://tc.holychen.cn/image/image-20210618174049497.png" alt="image-20210618174049497"></p><p><img src="http://tc.holychen.cn/image/image-20210618174158451.png" alt="image-20210618174158451"></p><p>而P2SB接口是PCH上的PCIe设备，在AlderLake平台上，它位于B:0/D:31/F:1。但是通过计算P2SB的配置空间地址，然后通过MMIO方式无法获得SBREG_BAR。因为P2SB和PMC Controller（B:0/D:31/F:2）一样神秘：即使已知Bus\Device\Function Number，也无法访问该PCIe设备的配置空间：</p><p><img src="http://tc.holychen.cn/image/6a824d72d28bbd31c35fa0713d94821.png" alt="6a824d72d28bbd31c35fa0713d94821"></p><p>这是需要从code里找到该宏定义的值</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> PCH_PCR_BASE_ADDRESS            0xE0000000     </span><span class="token comment" spellcheck="true">///&lt; SBREG MMIO base address</span><span class="token macro property">#<span class="token directive keyword">define</span> PCH_PCR_ADDRESS(Pid, Offset)    (PCH_PCR_BASE_ADDRESS | (UINT32) (((Offset) &amp; 0x0F0000) &lt;&lt; 8) | ((UINT8)(Pid) &lt;&lt; 16) | (UINT16) ((Offset) &amp; 0xFFFF))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="PortID"><a href="#PortID" class="headerlink" title="PortID"></a>PortID</h3><p>不同于51单片机访问GPIO Port，Intel PCH视GPIO为GPIO Pad(可以将GPIO Pad理解为主板上的焊点，当然Pad本身也有焊盘的意思。焊点GPIO Pad到真正的GPIO Port之间还有不为人知的回路)。同时，Intel PCH将若干物理内存上相近的GPIO Pad划到同一个GPIO Community(GPIO组)，以便于访问，并赋予各个GPIO Community平台唯一的Port ID。各个平台定义的Port ID不同，需要查询PCH EDS Vol1，下图为AlderLake定义的Port ID：</p><p><img src="http://tc.holychen.cn/image/image-20210621104021802.png" alt="image-20210621104021802"></p><h2 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a>GPIO配置</h2><h3 id="如何表征一个GPIO"><a href="#如何表征一个GPIO" class="headerlink" title="如何表征一个GPIO"></a>如何表征一个GPIO</h3><blockquote><p>应该有一个数据结构描述GPIO的引脚和配置寄存器</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  GPIO_PAD           GpioPad<span class="token punctuation">;</span>  GPIO_CONFIG        GpioConfig<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> GPIO_INIT_CONFIG<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置寄存器"><a href="#配置寄存器" class="headerlink" title="配置寄存器"></a>配置寄存器</h3><p>Pad Configuration DW0 寄存器设置来控制GPIO pin的触发方式以及中断触发类型（SCI/SMI/NMI/IOxACPI）等属性</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>以读取GPIO_VER4_S_GPP_C23 为例</p><p>//GPIO_VER4_S_GPP_C23 // MMIO : 0xE06B0A00</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**  Pad Mode  Pad can be set as GPIO or one of its native functions.  When in native mode setting Direction (except Inversion), OutputState,  InterruptConfig, Host Software Pad Ownership and OutputStateLock are unnecessary.  Refer to definition of GPIO_PAD_MODE.  Refer to EDS for each native mode according to the pad.  **/</span>  UINT32 PadMode            <span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**  Host Software Pad Ownership  Set pad to ACPI mode or GPIO Driver Mode.  Refer to definition of GPIO_HOSTSW_OWN.  **/</span>  UINT32 HostSoftPadOwn     <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**  GPIO Direction  Can choose between In, In with inversion, Out, both In and Out, both In with inversion and out or disabling both.  Refer to definition of GPIO_DIRECTION for supported settings.  **/</span>  UINT32 Direction           <span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**  Output State  Set Pad output value.  Refer to definition of GPIO_OUTPUT_STATE for supported settings.  This setting takes place when output is enabled.  **/</span>  UINT32 OutputState         <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**  GPIO Interrupt Configuration  Set Pad to cause one of interrupts (IOxAPIC/SCI/SMI/NMI).  This setting is applicable only if GPIO is in GpioMode with input enabled.  Refer to definition of GPIO_INT_CONFIG for supported settings.  **/</span>  UINT32 InterruptConfig     <span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**  GPIO Power Configuration.  This setting controls Pad Reset Configuration.  Refer to definition of GPIO_RESET_CONFIG for supported settings.  **/</span>  UINT32 PowerConfig        <span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**  GPIO Electrical Configuration  This setting controls pads termination and voltage tolerance.  Refer to definition of GPIO_ELECTRICAL_CONFIG for supported settings.  **/</span>  UINT32 ElectricalConfig   <span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**  GPIO Lock Configuration  This setting controls pads lock.  Refer to definition of GPIO_LOCK_CONFIG for supported settings.  **/</span>  UINT32 LockConfig         <span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**  Additional GPIO configuration  Refer to definition of GPIO_OTHER_CONFIG for supported settings.  **/</span>  UINT32 OtherSettings     <span class="token punctuation">:</span>  <span class="token number">2</span><span class="token punctuation">;</span>  UINT32 RsvdBits          <span class="token punctuation">:</span> <span class="token number">17</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">///&lt; Reserved bits for future extension</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> GPIO_CONFIG<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Pad Configuration DW0 寄存器设置来控制GPIO pin的触发方式以及中断触发类型（SCI/SMI/NMI/IOxACPI）等属性</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/08/03/C%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>2021/08/03/C%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="软件开发概览"><a href="#软件开发概览" class="headerlink" title="软件开发概览"></a>软件开发概览</h2><h3 id="学习的标准"><a href="#学习的标准" class="headerlink" title="学习的标准"></a>学习的标准</h3><blockquote><p>思维缜密 逻辑清晰 知识点能够通俗易懂的复述和编码</p></blockquote><h3 id="软件开发的分类"><a href="#软件开发的分类" class="headerlink" title="软件开发的分类"></a>软件开发的分类</h3><blockquote><p>按照职责的不同，需求量比较大的常见的软件开发类型有：</p></blockquote><ul><li><p>移动开发(Andriod、IOS、Harmony)</p><ul><li>Andriod：Java、Kotlin</li><li>IOS：Objective-C、Swift</li></ul></li><li><p>前端开发(HTML、CSS、JavaScript、TypeScript)</p></li><li><p>后台开发(Java、C++、PHP、.NET、Python、Go)</p></li><li><p>嵌入式开发(C、C++、汇编)</p></li><li><p>……</p></li></ul><h3 id="软件开发的职责分工"><a href="#软件开发的职责分工" class="headerlink" title="软件开发的职责分工"></a>软件开发的职责分工</h3><p><img src="http://tc.holychen.cn/image/image-20210609222456589.png" alt="image-20210609222456589"></p><h2 id="C语言简介"><a href="#C语言简介" class="headerlink" title="C语言简介"></a>C语言简介</h2><h3 id="电子计算机的发展史"><a href="#电子计算机的发展史" class="headerlink" title="电子计算机的发展史"></a>电子计算机的发展史</h3><blockquote><p>第1代：电子管数字机(1946 - 1958年)</p></blockquote><blockquote><p>第2代：晶体管数字机(1958 - 1964年)</p></blockquote><blockquote><p>第3代：集成电路数字机(1946 - 1970年)</p></blockquote><blockquote><p>第4代：大规模集成电路机(1970年至今)</p></blockquote><p><img src="../Image/image-20210612214944935.png" alt="image-20210612214944935"></p><blockquote><p>电路的逻辑状态只有0和1两个状态，0表示低电平，1表示低电平</p></blockquote><blockquote><p>因此，当代的电子计算机只能识别0和1</p></blockquote><blockquote><p>注意：计算机除了电子计算机，还有光子计算机、量子计算机、生物计算机、纳米计算机等</p></blockquote><h3 id="C语言的发展简史"><a href="#C语言的发展简史" class="headerlink" title="C语言的发展简史"></a>C语言的发展简史</h3><blockquote><p>C语言于1972年诞生于美国AT&amp;T公司的贝尔实验室    </p></blockquote><ul><li>由Dennis MacAlistair Ritchie(丹尼斯.里奇)发明，被称为是C语言之父</li><li>C语言之所以命名为C，是因为它以B语言为基础发展而来</li><li>B语言由Kenneth Thompson(肯.汤普森)发明</li></ul><blockquote><p>Thompson和Ritchie用C语言完全重写了UNIX操作系统(以前是用汇编语言)</p></blockquote><ul><li>随着UNIX的发展，C语言也得到了不断的完善</li></ul><h3 id="C语言的标准"><a href="#C语言的标准" class="headerlink" title="C语言的标准"></a>C语言的标准</h3><blockquote><p>为了利于C语言的全面推广，许多专家学者和硬件厂商联合组成了C语言标准委员会(美国国家标准协会，ANSI)</p></blockquote><ul><li>1989年，诞生了第一个完备的C标准，简称C89，也就是ANSI C</li></ul><blockquote><p>1990年，ANSI C被国际标准化组织ISO采纳，C语言在ISO有了一个官方名称<strong>ISO/IEC 9889:1990</strong></p></blockquote><ul><li>9899是C语言在ISO标准中的代号，C++在ISO标准中的代号是14882</li><li>冒号后面的1990表示当前修订好的版本是在1990年发布的</li><li>对于<strong>ISO/IEC 9889:1990</strong>，有人称为C90或C89，是最初的C语言国际标准</li></ul><blockquote><p>1999年，正式发布<strong>ISO/IEC 9889:1999</strong>，简称为C99标准</p></blockquote><blockquote><p>2011年，正式发布<strong>ISO/IEC 9889:2011</strong>，简称为C11标准</p></blockquote><h3 id="C语言的用途"><a href="#C语言的用途" class="headerlink" title="C语言的用途"></a>C语言的用途</h3><blockquote><p>C语言可以说是其他高级编程语言的老祖宗，历史悠久</p></blockquote><ul><li>它的性能及其优越，在很多领域是其他编程语言无法取代的</li></ul><blockquote><p>凡是对性能要求极高的领域，基本都少不了C语言</p></blockquote><ul><li>操作系统开发(内核、驱动等，UNIX、Linux等著名操作系统就是利用C语言编写的)</li><li>数据库开发</li><li>高性能服务器开发</li><li>嵌入式开发</li><li>游戏开发</li><li>……</li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><blockquote><p>记事本</p></blockquote><ul><li>功能单一、体验差、易出错、开发效率低</li></ul><blockquote><p>IDE(Integrated Development Environment): 集成开发环境</p></blockquote><ul><li>智能提示、高亮识别、语法检测、开发效率高(功能强大到超乎想象)</li><li>常见的C语言IDE有：Visual Studio、QT Creator、CLion、Dev C++</li></ul><p><img src="http://tc.holychen.cn/image/image-20210609232030914.png" alt="image-20210609232030914"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="程序的结构"><a href="#程序的结构" class="headerlink" title="程序的结构"></a>程序的结构</h3><blockquote><p>任何一个C语言程序都有一个或多个函数(Function)构成</p></blockquote><ul><li>每个函数都有自己的功能</li></ul><p><img src="http://tc.holychen.cn/image/image-20210609234553541.png" alt="image-20210609234553541"></p><blockquote><p>所以，以后编写的C语言代码，基本都是写在函数中</p></blockquote><blockquote><p>在有些编程语言中(例如Java)，函数也叫做”方法(Method)”</p></blockquote><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><blockquote><p>每一个函数都有自己的名称</p></blockquote><blockquote><p>每一个函数的名称都是唯一的</p></blockquote><blockquote><p>默认情况下，C语言程序的运行入口点是main函数(翻译为:主函数，没有main函数，C语言程序是无法运行的</p></blockquote><h3 id="语法须知"><a href="#语法须知" class="headerlink" title="语法须知"></a>语法须知</h3><blockquote><p>C语言源代码(Source Code)文件的文件扩展名是.c</p></blockquote><blockquote><p>每一条语句(Stasement)后面都要以分号;结尾，是语句结束的标志</p></blockquote><blockquote><p>括号都是成对出现的</p></blockquote><blockquote><p>C语言是区分大小写的(大小写敏感，case-sensitive)</p></blockquote><blockquote><p>代码中用到的符号必须都是英文符号(注释、字符、字符串等的内容除外)</p></blockquote><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><blockquote><p>该换行就换行</p></blockquote><blockquote><p>该缩进就缩进(按Tab键缩进、按Shift + Tab键反缩进)</p></blockquote><blockquote><p>该留空格就留空格(一般就留一个空格)</p></blockquote><h3 id="编译、链接知识"><a href="#编译、链接知识" class="headerlink" title="编译、链接知识"></a>编译、链接知识</h3><blockquote><p>编译：将C语言源代码文件编译成可重定位二进制目标文件(以.o或.obj作为扩展名)，由编译器(complier)来完成</p></blockquote><blockquote><p>链接：将所有目标文件以及所需要的库文件合并成一个可执行文件(executable file)，由链接器(linker)来完成</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210612220002735.png" alt="image-20210612220002735"></p><h3 id="编译、链接的细节"><a href="#编译、链接的细节" class="headerlink" title="编译、链接的细节"></a>编译、链接的细节</h3><blockquote><p>常见的C语言编译器有(已经内置了链接器)</p></blockquote><ul><li><p>MSVC：微软出品(用在windows中)</p></li><li><p>GCC：GNU Compiler Collection的缩写，GNU出品</p></li><li><p>MinGW：Minimalist GNU for Windows的缩写 ，GNU出品(用在Windows中)</p></li><li><p>LLVM：常用于苹果的开发工具中</p></li><li><p>……</p></li></ul><blockquote><p>对于同一份源代码，经过不同的编译器编译出来的目标文件(体积、格式、运行效率等)是不一样的</p></blockquote><blockquote><p>对于不同平台(操作系统)，最后链接产生的可执行文件格式也是不同的</p></blockquote><ul><li>Windows：PE格式(经常以.exe作为文件扩展名)</li><li>Linux：ELF格式</li><li>Mac：Mach - O格式</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>什么是注释</p></blockquote><ul><li>注释常用来解释某段代码的具体含义、作用</li><li>注释并不会被当做正常代码进行编译</li><li>注释再很多IDE中的默认颜色都是偏绿色</li></ul><blockquote><p>C语言的注释有两种书写风格</p></blockquote><ul><li>多行注释(也被称为C风格注释)</li><li>单行注释(C99开始有，也被称为C++风格注释)</li></ul><blockquote><p>注释的嵌套</p></blockquote><ul><li>单行注释可以嵌套单行注释、多行注释</li><li>多行注释不能嵌套多行注释</li></ul><blockquote><p>多写注释的好处</p></blockquote><ul><li>方便回忆、检查代码</li><li>方便程序员之间的团队协作、提高开发效率</li><li>方便旧项目的交接</li></ul><blockquote><p>注释常用技巧</p></blockquote><ul><li>用来检验功能</li><li>用来定位BUG</li></ul><h3 id="变量-Variable"><a href="#变量-Variable" class="headerlink" title="变量(Variable)"></a>变量(Variable)</h3><h4 id="变量的作用"><a href="#变量的作用" class="headerlink" title="变量的作用"></a>变量的作用</h4><blockquote><p>可以存储程序运行中会变化的数据</p></blockquote><h4 id="如何声明-declare-一个变量"><a href="#如何声明-declare-一个变量" class="headerlink" title="如何声明(declare)一个变量"></a>如何声明(declare)一个变量</h4><ul><li><p>变量类型 变量名;</p></li><li><p>变量类型决定了变量能够存储什么类型的数据</p></li></ul><h4 id="如何给变量赋值"><a href="#如何给变量赋值" class="headerlink" title="如何给变量赋值"></a>如何给变量赋值</h4><ul><li>赋值(assign): 将数据交给变量去存储</li><li>变量名 = 数据;</li><li>这个等号 = 表示赋值，会将右边的数据赋值给左边的变量</li></ul><blockquote><p>在变量声明完毕后，可以直接通过变量名访问，不用带上变量类型</p></blockquote><h4 id="变量的细节"><a href="#变量的细节" class="headerlink" title="变量的细节"></a>变量的细节</h4><ul><li><p>变量可以被多次赋值，新值会覆盖旧值</p></li><li><p>变量的第一次赋值，一般叫做初始化(initialize)</p></li><li><p>变量可以在声明的同时进行初始化</p></li><li><p>变量在未被初始化之前，它的值是不确定的</p></li><li><p>变量在使用之前必须要进行初始化</p></li><li><p>可以同时声明多个同类型的变量</p></li><li><p>可以将一个变量的值赋值给另一个变量</p></li></ul><h4 id="变量的作用域-scope"><a href="#变量的作用域-scope" class="headerlink" title="变量的作用域(scope)"></a>变量的作用域(scope)</h4><blockquote><p>变量的作用域：就是指变量的作用范围、有效使用范围</p></blockquote><ul><li> 从声明变量的那条语句开始，直到变量所在的大括号结束</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误</span>    <span class="token keyword">int</span> age1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="变量的作用域细节"><a href="#变量的作用域细节" class="headerlink" title="变量的作用域细节"></a>变量的作用域细节</h5><ul><li>在同一个作用域内，不允许有同名的变量</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//有歧义(二义性)</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//错误</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3age = %d\n"</span><span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2age = %d\n"</span><span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1age = %d\n"</span><span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//result:30 20 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="变量的存储"><a href="#变量的存储" class="headerlink" title="变量的存储"></a>变量的存储</h4><blockquote><p>变量的内存地址是指首字节的内存地址，首字节是指地址值最小的那个字节</p></blockquote><blockquote><p>越晚定义的变量，内存地址越小</p></blockquote><h5 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h5><blockquote><p>大小端模式：决定了多字节数据的字节存储顺序</p></blockquote><p>大端模式(Big-endian)：高低低高</p><ul><li>高字节放在低地址，低字节放在高地址</li></ul><p>小端模式(Little-endian)：高高低低</p><ul><li>高字节放在高地址，低字节放在低地址</li></ul><p>不同CPU架构的模式不一样</p><ul><li>比如x86架构是小端模式</li><li>有些CPU架构是大端模式</li><li>目前比较常见的是小端模式</li></ul><h5 id="int类型的存储"><a href="#int类型的存储" class="headerlink" title="int类型的存储"></a>int类型的存储</h5><p><img src="http://tc.holychen.cn/image/image-20210613122155853.png" alt="image-20210613122155853"></p><h5 id="字符的存储细节"><a href="#字符的存储细节" class="headerlink" title="字符的存储细节"></a>字符的存储细节</h5><p>计算机中的数据都是以二进制形式存储的，字符数据也不例外</p><ul><li>每一个自负都会被转化成对应的整数值进行存储</li></ul><p>在1967年，美国发布了ASCII码表，里面规定了128个单字节字符对应的整数值(ASCII码值)</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">97</span><span class="token punctuation">;</span><span class="token keyword">char</span> c1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>cahr c2 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="http://tc.holychen.cn/image/image-20210613145053624.png" alt="image-20210613145053624"></p><h6 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a>ASCII码表</h6><blockquote><p>ASCII,全称是American Standard Code for Information  Interchang，译为”美国信息交换标准码”，是一种标准的单字节字符编码方案</p></blockquote><ul><li>共128个字符，码值范围：0-127(也就是0x00-0x7F)</li><li>有33个是控制字符或通信专用字符，码值范围：0-31、127<ul><li>控制字符：LF(换行)、DEL(删除)、BS(退格)等</li><li>通信专用字符：SOH(文头)、EOT(文尾)、ACk(确认)等</li></ul></li><li>有95个可显示字符，码值范围：32-126<ul><li>48-57：十个阿拉伯数字(0~9)</li><li>65-90：26个大写英文字母(A~Z)</li><li>97-122：26个小写英文字母(a~z)</li><li>其余为一些标点符号、运算符等</li></ul></li></ul><p><img src="http://tc.holychen.cn/image/image-20210613150757818.png" alt="image-20210613150757818"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token function">puts</span> <span class="token punctuation">(</span> <span class="token string">"Printable ASCII:"</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token keyword">for</span>  <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span>  <span class="token number">32</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span>  <span class="token number">127</span> <span class="token punctuation">;</span>  <span class="token operator">++</span> i <span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         <span class="token function">putchar</span> <span class="token punctuation">(</span> i <span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token function">putchar</span> <span class="token punctuation">(</span> i <span class="token operator">%</span>  <span class="token number">16</span>  <span class="token operator">==</span>  <span class="token number">15</span>  <span class="token operator">?</span>  <span class="token string">' \n '</span>  <span class="token punctuation">:</span>  <span class="token string">' '</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*Printable ASCII:  ! " # $ % &amp; ' ( ) * + , - . /0 1 2 3 4 5 6 7 8 9 : ; &lt; = > ?@ A B C D E F G H I J K L M N OP Q R S T U V W X Y Z [ \ ] ^ _` a b c d e f g h i j k l m n op q r s t u v w x y z &amp;#123; | &amp;#125; ~*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 (String)"></a>字符串 (String)</h4><blockquote><p>用双引号包住的内容叫做：字符串(由若干个【字符】组成的一串数据)</p></blockquote><blockquote><p>和注释类似，字符串里的内容可以随便写</p></blockquote><h3 id="标识符-Identifier"><a href="#标识符-Identifier" class="headerlink" title="标识符(Identifier)"></a>标识符(Identifier)</h3><blockquote><p>标识符：由开发者自定义的一些名称(比如变量名、函数名等)</p></blockquote><blockquote><p>标识符的命名规则大致如下</p></blockquote><ul><li>不限长度</li><li>可以使用数字、下划线、英文字母</li><li>可以使用以\u及\U转义记号指定的Unicode字符(从C99开始)</li><li>不能以数字开头</li><li>不能使用关键字</li></ul><blockquote><p>标识符的命名规范(命名建议)</p></blockquote><ul><li>尽量用正确的英文单词命名，见名知意</li></ul><blockquote><p>当名称中包含多个单词时</p></blockquote><ul><li><p>小驼峰(第一个单词的首字母小写，其它单词的首字母大写)(mHandle)</p></li><li><p>大驼峰(所有单词的首字母大写)</p></li><li><p>用下划线连接</p></li></ul><h3 id="关键字-Keyword"><a href="#关键字-Keyword" class="headerlink" title="关键字(Keyword)"></a>关键字(Keyword)</h3><blockquote><p>关键字，也叫做保留字(reserved word)</p></blockquote><ul><li>是编程语言内部已经定义好的一些有特殊含义的符号</li></ul><blockquote><p>C语言的关键字如下所示</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613031548234.png" alt="image-20210613031548234"></p><h3 id="字面量-Literal"><a href="#字面量-Literal" class="headerlink" title="字面量(Literal)"></a>字面量(Literal)</h3><blockquote><p>字面量：直接写出来的一个固定值</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">double</span> height <span class="token operator">=</span> <span class="token number">1.68</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>hody <span class="token operator">=</span> <span class="token string">"code"</span><span class="token punctuation">;</span><span class="token keyword">char</span> cc <span class="token operator">=</span> <span class="token string">'m'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上面代码中，等号 = 右边的固定值都叫做字面量</p></blockquote><h3 id="代码中的进制书写形式"><a href="#代码中的进制书写形式" class="headerlink" title="代码中的进制书写形式"></a>代码中的进制书写形式</h3><blockquote><p>C语言标准规定</p></blockquote><ul><li>默认是十进制</li><li>以0开头是八进制</li><li>以0X或0x开头是十六进制</li></ul><blockquote><p>C语言标准并不支持二进制的书写形式</p></blockquote><ul><li>不过有些编译器支持，比如GCC规定以0b或0B开头是二进制</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"八进制：0%o\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"十六进制：0x%x\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="有符号数的二进制表示方法"><a href="#有符号数的二进制表示方法" class="headerlink" title="有符号数的二进制表示方法"></a>有符号数的二进制表示方法</h3><blockquote><p>int 类型属于有符号整数类型(signed integer types)</p></blockquote><ul><li>可以表示正数、负数</li></ul><blockquote><p>有符号数的二进制有三种表示方法：原码、反码、补码</p></blockquote><blockquote><p>三种表示方法均有符号位和数值位两部分</p></blockquote><ul><li>符号位：最高位作为符号位，用0表示”正”，用1表示”负”</li><li>数值位：三种表示方法各不相同</li></ul><blockquote><p>正数的原码、反码、补码一致，负数则不一样，计算机用补码表示和存储数值</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613120716044.png" alt="image-20210613120716044"></p><h3 id="字符的使用细节"><a href="#字符的使用细节" class="headerlink" title="字符的使用细节"></a>字符的使用细节</h3><ul><li>可以将char类型当做整数类型来使用</li></ul><blockquote><p>数字整数、数字字符、数字字符串</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'9'</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token string">"9"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//58</span><span class="token function">prinft</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4210689</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://tc.holychen.cn/image/image-20210613152215827.png" alt="image-20210613152215827"></p><blockquote><p>中文、日文、韩文等非英文字符是如何存储在计算机中的</p></blockquote><ul><li>首先，必然是以二进制的形式存储在计算机中</li><li>其次，每个字符对应的二进制数值取决于具体的编码方案</li></ul><blockquote><p>GBK主要支持CJK字符(C指中国、J指日本、K指朝鲜)，而UTF-8支持几乎世界上所有的文字字符</p></blockquote><h3 id="转义序列-Escape-sequences"><a href="#转义序列-Escape-sequences" class="headerlink" title="转义序列(Escape sequences)"></a>转义序列(Escape sequences)</h3><blockquote><p>转义序列，一般也叫做转义字符，是一些有特殊含义的字符</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613153357034.png" alt="image-20210613153357034"></p><h3 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h3><blockquote><p>scanf函数的功能是：输入(input)，读取数据(比如读取通过键盘输入的数据)</p></blockquote><p>scanf函数开始执行后，会等待用户输入</p><ul><li>程序卡在scanf函数那里，不会执行scanf函数后面的代码</li><li>当用户敲Enter键(回车键)时，表示输入完毕</li><li>程序才会开始执行scanf函数后面的代码</li></ul><h5 id="循环中校验scanf输入"><a href="#循环中校验scanf输入" class="headerlink" title="循环中校验scanf输入"></a>循环中校验scanf输入</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入1-100之间的正整数："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="sancf函数-匹配的细节"><a href="#sancf函数-匹配的细节" class="headerlink" title="sancf函数 - 匹配的细节"></a>sancf函数 - 匹配的细节</h5><ul><li>当中途有匹配失败时，将结束匹配</li></ul><blockquote><p>当尝试把输入的数字赋值给字符变量时</p></blockquote><ul><li>scanf把输入的数字当成是数字字符来处理</li><li>并不会把输入的数字当成是字符的ASCII码值来处理</li></ul><h5 id="scanf函数-——-空白字符"><a href="#scanf函数-——-空白字符" class="headerlink" title="scanf函数 —— 空白字符"></a>scanf函数 —— 空白字符</h5><blockquote><p>空白字符包括：空格(‘ ‘)、Tab(‘\t’)、Enter(‘\n’)</p></blockquote><ul><li><p>如果在输入数据的开头，有一段任意长(长度 &gt;= 0)连续空白字符，是不需要与格式化字符串中的字符进行匹配的</p></li><li><p>在格式化字符串中，任意长(长度 &gt;= 0)连续空白字符能匹配输入的任意长(长度 &gt;= 0)连续空白字符</p></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p>C语言拥有丰富多彩的数据类型，可以分为4大类型</p></blockquote><p>void类型</p><p>基本类型(basic types)</p><ul><li>字符类型(character types)</li><li>有符号整数类型(signed integer types)</li><li>无符号整数类型(unsigned integer types)</li><li>浮点类型(floating types)</li></ul><p>枚举类型(enumerate)</p><p>派生类型(derived types)</p><ul><li>数组类型(array types)</li><li>结构体类型(structure types)</li><li>联合体类型(union types)</li><li>函数类型(function types)</li><li>指针类型(pointer types)</li><li>原子类型(atomic types)</li></ul><h3 id="基本类型-Basic-Types"><a href="#基本类型-Basic-Types" class="headerlink" title="基本类型(Basic Types)"></a>基本类型(Basic Types)</h3><p>有符号整数类型(signed integer types)</p><ul><li>char (等价类型：signed char)</li><li>short(等价类型：signed short、short int、signed short int)</li><li>int(等价类型：signed int、signed)</li><li>long(等价类型：signed long、long int、signed long int)(C99起)</li><li>long long(等价类型：signed long long、long long int、signed long long int)(C99起)</li></ul><p>无符号整数类型(unsigned integer types)</p><ul><li>unsigned char</li><li>unsigned short(等价类型：unsigned short int)</li><li>unsigned int(等价类型：undigned)</li><li>undigned long(等价类型：unsigned long int)(C99起)</li><li>unsigned long long(等价类型：unsigned long long int)(C99起)</li><li>_Bool(C99起)</li></ul><h3 id="字符类型-character-types"><a href="#字符类型-character-types" class="headerlink" title="字符类型(character types)"></a>字符类型(character types)</h3><p>char类型属于字符类型(character types)</p><blockquote><p>一个char类型的变量占用一个字节的内存</p></blockquote><ul><li>所以它只能存储一个单字节字符</li><li>26个英文字母的大小写(a<del>z,A</del>Z)、10个阿拉伯数字(0~9)等都是单字节字符</li></ul><h3 id="浮点类型-floating-types"><a href="#浮点类型-floating-types" class="headerlink" title="浮点类型(floating types)"></a>浮点类型(floating types)</h3><ul><li>float、duoble、long double</li></ul><h3 id="整数类型的大小"><a href="#整数类型的大小" class="headerlink" title="整数类型的大小"></a>整数类型的大小</h3><blockquote><p>C标准规定</p></blockquote><ul><li><strong>sizeof(long long) &gt;= sizeof(long) &gt;= sizeof(int) &gt;= sizeof(short) &gt;= sizeof(char) == 1</strong></li></ul><p><img src="http://tc.holychen.cn/image/image-20210613164507969.png" alt="image-20210613164507969"></p><h3 id="数据模型-Data-Models"><a href="#数据模型-Data-Models" class="headerlink" title="数据模型(Data Models)"></a>数据模型(Data Models)</h3><ul><li>LP32(2/4/4)：int为16位、long、指针为32位</li><li>ILP32(4/4/4)：int、long、指针均为32位</li><li>LLP64(4/4/8)：int、long为32位，指针为64位（Win64 API）</li><li>LP64(4/4/8)：int为32，long、指针为64位(Unix、类Unix系统(Linux、Mac OS X))</li></ul><h3 id="char、unsigned-char区别"><a href="#char、unsigned-char区别" class="headerlink" title="char、unsigned char区别"></a>char、unsigned char区别</h3><p><img src="http://tc.holychen.cn/image/image-20210613170117839.png" alt="image-20210613170117839"></p><ul><li>c1、c2变量在内存中存放的二进制数据是完全一样的</li><li>对于同一份二进制数据，分别以有符号数形式、无符号数形式解读出来的含义可能是不一样的</li></ul><h3 id="整数的取值范围"><a href="#整数的取值范围" class="headerlink" title="整数的取值范围"></a>整数的取值范围</h3><blockquote><p>char、unsigned char都只占用一个字节，能够存放的二进制数据范围都是【0b0000 0000，0b1111 1111】</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613171125136.png" alt="image-20210613171125136"></p><p><img src="http://tc.holychen.cn/image/image-20210613172530305.png" alt="image-20210613172530305"></p><ul><li>有n个二进制位的有符号数的取值范围是【-2^n-1^，2^n-1^ - 1】</li><li>有n个二进制位的无符号数的取值范围是【0，2^n^ - 1 】</li></ul><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><blockquote><p>当出现溢出时，会优先保留低字节的数据，舍弃高字节的数据</p></blockquote><blockquote><p>所以在给取值范围小的变量赋值时，要注意防止数据溢出，否则，结果可能会跟预期不符合</p></blockquote><blockquote><p>无符号数和有符号数溢出时的钟表机制</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613174815987.png" alt="image-20210613174815987"></p><h3 id="浮点类型-Floating-Types"><a href="#浮点类型-Floating-Types" class="headerlink" title="浮点类型(Floating Types)"></a>浮点类型(Floating Types)</h3><blockquote><p>浮点类型可以用来表示小数(比如0.5)，包括了float、double、long double类型</p></blockquote><blockquote><p>最常用浮点类型的是float和double，一般在数值后面加上f或者F表示是float类型的数值</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">1.45F</span><span class="token punctuation">;</span><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">1.89</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1.450000 1.890000</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f %f"</span><span class="token punctuation">,</span>f<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>float：单精度(Single)浮点类型，占用32bit，可以保证精确到小数点后6位</p></blockquote><ul><li>最小值大约是：-3.4 * 10^38^，最大值大约是：3.4 * 10^38^</li></ul><blockquote><p>double：双精度(Double)浮点类型，占用64bit，可以保证精确到小数点后15位</p></blockquote><ul><li>最小值大约是：-1.8 * 10^308^，最大值大约是：1.8 * 10^308^</li></ul><h3 id="浮点类型的存储细节"><a href="#浮点类型的存储细节" class="headerlink" title="浮点类型的存储细节"></a>浮点类型的存储细节</h3><blockquote><p>浮点数在计算机中是按照IEEE 754标准存储的</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613180945333.png" alt="单精度浮点数存储"></p><p><img src="http://tc.holychen.cn/image/image-20210613181059171.png" alt="image-20210613181059171"></p><h3 id="printf中的转换格式指定符"><a href="#printf中的转换格式指定符" class="headerlink" title="printf中的转换格式指定符"></a>printf中的转换格式指定符</h3><blockquote><p>printf中常用的转换格式指定符(conversion format specifier)如下所示</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613182252538.png" alt="image-20210613182252538"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"zd\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> age <span class="token operator">=</span> <span class="token number">10LL</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>unsigend <span class="token keyword">long</span> no <span class="token operator">=</span><span class="token number">8UL</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"lu%\n"</span><span class="token punctuation">,</span>no<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="printf格式符细节"><a href="#printf格式符细节" class="headerlink" title="printf格式符细节"></a>printf格式符细节</h3><ul><li>用%%来显示一个%</li><li>用%6d表示占用6个字符位置，默认靠右对齐</li><li>%-6d中的减号( - )表示靠左对齐</li><li>%+6d中的加号( + )表示显示正负号</li><li>%.2f表示四舍五入保留2位小数</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>强制类型转换</p><pre class="line-numbers language-c"><code class="language-c">类型<span class="token number">1</span> v1 <span class="token operator">=</span> xx<span class="token punctuation">;</span>类型<span class="token number">2</span> v2 <span class="token operator">=</span> <span class="token punctuation">(</span>类型<span class="token number">2</span><span class="token punctuation">)</span> v1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><blockquote><p>在进行一些算数运算时，小类型会被隐式转换成大类型</p></blockquote><ul><li>char &lt; short &lt; int &lt; long &lt; long long &lt; float &lt; double &lt; long double</li></ul><blockquote><p>注意：任何小于int的整数类型，在运算时会隐式转换为int类型</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token number">97</span><span class="token punctuation">;</span><span class="token keyword">short</span> s <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1 2</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%zd %zd\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 4 4 </span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%zd %zd\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 4 4</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%zd %zd\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>c <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>c<span class="token operator">/</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 4</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%zd \n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运算符-Operators"><a href="#运算符-Operators" class="headerlink" title="运算符(Operators)"></a>运算符(Operators)</h2><blockquote><p>C语言常用运算符，如下表所示</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210614094402166.png" alt="image-20210614094402166"></p><h3 id="算术运算符-Arithemetic-Operators"><a href="#算术运算符-Arithemetic-Operators" class="headerlink" title="算术运算符(Arithemetic Operators)"></a>算术运算符(Arithemetic Operators)</h3><p><img src="http://tc.holychen.cn/image/image-20210614094624439.png" alt="image-20210614094624439"></p><ul><li>模运算符不能用在浮点数上</li><li>模运算结果的正负性跟随运算符左边的操作数</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token operator">%</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">%</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//-3</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">%</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//-3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="位运算符-Bitwise-Operators"><a href="#位运算符-Bitwise-Operators" class="headerlink" title="位运算符(Bitwise Operators)"></a>位运算符(Bitwise Operators)</h4><blockquote><p>位运算符，属于算数运算符，位运算符的运算数只能是整数</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210614194041996.png" alt="image-20210614194041996"></p><ul><li>位移运算符b的值必须为非负整数</li><li>左移低位补0</li><li>右移高位用符号位填充 </li></ul><blockquote><p>按位逻辑运算符，也叫逐位逻辑运算符，留意下与位运算相关的赋值运算符即可</p></blockquote><h4 id="位运算的实践应用"><a href="#位运算的实践应用" class="headerlink" title="位运算的实践应用"></a>位运算的实践应用</h4><ul><li><p>尽量使用位运算取代乘(*)、除(/)、模(%)运算，因为位运算效率比它们高</p></li><li><p>用a &amp; 1来判断a的奇偶性</p></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>a <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"奇数"</span> <span class="token punctuation">:</span> <span class="token string">"偶数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>不使用第三方变量交换两个整形变量的值</li></ul><pre class="line-numbers language-c"><code class="language-c">a <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = a * b; // a = a - b; // a = a ^ b; //</span>b <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// b = a / b; // b = a + b; // b = a ^ b; //</span>a <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = a / b; // a = b - a; // a = a ^ b; //</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>前三种方法可能有溢出产生bug，而异或操作则不用担心，虽然省了空间，但时间增加了</p></blockquote><h4 id="按位亦或的特点"><a href="#按位亦或的特点" class="headerlink" title="按位亦或的特点"></a>按位亦或的特点</h4><ul><li>a ^ 0 = a  </li><li>a ^ a = 0 </li><li> a ^ b = b ^ a </li><li> (a ^ b) ^ c == a ^ (b ^ c) == (a ^ c) ^ b</li></ul><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><blockquote><p>当一个表达式中同时使用多个运算符时</p></blockquote><ul><li>会根据运算符的优先级和结合性，来决定运算符的执行顺序</li><li>优先级越高(优先级值越小，越先被执行)</li><li>优先级一样，根据结合性决定执行顺序</li><li>为了确保优先级和代码可读性，应该多使用小括号</li></ul><p><img src="http://tc.holychen.cn/image/image-20210614174400172.png" alt="image-20210614174400172"></p><p><img src="../Image/image-20210614174521168.png" alt="image-20210614174521168"></p><p><img src="http://tc.holychen.cn/image/image-20210614174755974.png" alt="image-20210614174755974"></p><h3 id="赋值运算符-Assignment-Operators"><a href="#赋值运算符-Assignment-Operators" class="headerlink" title="赋值运算符(Assignment Operators)"></a>赋值运算符(Assignment Operators)</h3><p><img src="http://tc.holychen.cn/image/image-20210614175437229.png" alt="image-20210614175437229"></p><h3 id="自增-自减运算符"><a href="#自增-自减运算符" class="headerlink" title="自增/自减运算符"></a>自增/自减运算符</h3><blockquote><p>自增/自减运算符(Increment/Decrement Operators)包括了</p></blockquote><ul><li><p>前缀(prefix)</p><ul><li>自增运算符：++a</li><li>自减运算符：–a</li></ul></li><li><p>后缀(postfix)</p><ul><li>自增运算符：a++</li><li>自减运算符：a–</li></ul><pre class="line-numbers language-c"><code class="language-c">b <span class="token operator">=</span> a<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等效于下面3句代码</span>tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>a <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>b <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token operator">++</span> <span class="token operator">+</span> a<span class="token operator">++</span> <span class="token operator">+</span> a<span class="token operator">++</span> <span class="token operator">+</span> a<span class="token operator">++</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//MSVC: b = 1 + 1 + 1 + 1 = 4</span><span class="token comment" spellcheck="true">//MinG: b = 1 + 2 + 3 + 4 = 10</span><span class="token comment" spellcheck="true">//不容易理解，可读性差，结果具有不确定性</span><span class="token comment" spellcheck="true">//不建议在实际开发中变编写此类代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="最大吞噬规则-maximal-much"><a href="#最大吞噬规则-maximal-much" class="headerlink" title="最大吞噬规则(maximal much)"></a>最大吞噬规则(maximal much)</h4><ul><li>当多个运算符紧挨在一起时，编译器会按照最大吞噬规则去解析</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">++</span><span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2 2 3</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等价于int c = (a++) + b;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="比较运算符-Comparison-Operators"><a href="#比较运算符-Comparison-Operators" class="headerlink" title="比较运算符(Comparison Operators)"></a>比较运算符(Comparison Operators)</h3><ul><li>比较运算符，也称为关系运算符(Relational Operators)</li><li>比较运算符的结果只可能是整数0和1</li></ul><p><img src="http://tc.holychen.cn/image/image-20210614182554844.png" alt="image-20210614182554844"></p><h3 id="逻辑运算符-Logical-Operators"><a href="#逻辑运算符-Logical-Operators" class="headerlink" title="逻辑运算符(Logical Operators)"></a>逻辑运算符(Logical Operators)</h3><p>在C语言中，任何值都有真假性</p><ul><li>任何非0的值都为”真”(比如59、1、-17、6.4、0.1、1.0、”123”、’K’等)</li><li>只有数值0才为”假”(比如0、0.0、’\0’等)</li></ul><p><img src="http://tc.holychen.cn/image/image-20210614183223550.png" alt="image-20210614183223550"></p><blockquote><p>逻辑运算符的运算数可以是任何值，它的运算结果要么是真、要么是假</p></blockquote><ul><li>运算结果为真，就返回整数1</li><li>运算结果为假，就返回整数0</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token operator">!</span><span class="token string">'666'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>在表示范围的时候，逻辑与(&amp;&amp;)是取交集(∩)，逻辑或(||)是取并集(∪)</p></blockquote><h4 id="逻辑与的短路现象"><a href="#逻辑与的短路现象" class="headerlink" title="逻辑与的短路现象"></a>逻辑与的短路现象</h4><blockquote><p>a &amp;&amp; b</p></blockquote><ul><li><p>如果a为假，就不会再去执行代码b。因为不管b是真是假，运算结果都为假</p></li><li><p>如果a为真，就还需要执行代码b。因为得知b是真是假，才知道运算结果</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token operator">++</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">++</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="逻辑或的短路现象"><a href="#逻辑或的短路现象" class="headerlink" title="逻辑或的短路现象"></a>逻辑或的短路现象</h4><blockquote><p>a || b</p></blockquote><ul><li><p>如果a为真，就不会再去执行代码b。因为不管b是真是假，运算结果都为真</p></li><li><p>如果a为假，就还需要执行代码b。因为得知b是真是假，才知道运算结果</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token operator">++</span>a <span class="token operator">||</span> b<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>短路现象可以减少一些不必要的代码的执行，缩短了程序的执行时间</p></blockquote><h3 id="条件运算符-Conditional-Operator"><a href="#条件运算符-Conditional-Operator" class="headerlink" title="条件运算符(Conditional Operator)"></a>条件运算符(Conditional Operator)</h3><ul><li>条件运算符，一般也叫作三目运算符、三元运算符</li><li>a ? b : c<ul><li>如果a为真，就返回b</li><li>如果a为假，就返回c</li></ul></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//将整形变量a、b、c中的最大值打印出来</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 33</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token punctuation">:</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">?</span> b <span class="token punctuation">:</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**int a = 11, b = 22, c = 33;int d = (a >b) ? a : b;d = (c > d) ? c : d;// 33printf("%d\n",d);**/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//如果字符变量c是小写字母，就转成大写字母;否则保持原样</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'g'</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">>=</span> <span class="token string">'a'</span> <span class="token operator">%</span><span class="token operator">%</span> c <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token string">'a'</span> <span class="token operator">+</span> <span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> c<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// G</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//有一个字符变量c，如果它是小写字母，就转成大写字母；如果它是大写字母，就转成小写字母；否则保持原样</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'G'</span><span class="token punctuation">;</span><span class="token keyword">int</span> diff <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">-</span> <span class="token string">'A'</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">>=</span> <span class="token string">'a'</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> diff<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">>=</span> <span class="token string">'A'</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token string">'Z'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> diff<span class="token punctuation">)</span> <span class="token punctuation">:</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// g</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逗号运算符-Comma-Operator"><a href="#逗号运算符-Comma-Operator" class="headerlink" title="逗号运算符(Comma Operator)"></a>逗号运算符(Comma Operator)</h3><p>(a, b,  ……)</p><ul><li>从左到右依次执行表达式</li><li>返回最后一个表达式的运算结果</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> a <span class="token operator">=</span> a <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">10</span> <span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> a<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 11 10</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="流程控制-Flow-Control"><a href="#流程控制-Flow-Control" class="headerlink" title="流程控制(Flow Control)"></a>流程控制(Flow Control)</h2><blockquote><p>按照执行程序流程的不同，可以将平时编写的代码分成3大结构</p></blockquote><ul><li><p>顺序结构：默认的流程结构，按照代码的书写顺序执行每一句代码</p></li><li><p>选择结构：根据表达式的真假性，来决定执行哪一段代码</p></li><li><p>循环结构：在表达式为真的情况下，重复执行某一段代码</p></li></ul><p><img src="http://tc.holychen.cn/image/image-20210614210008968.png" alt="image-20210614210008968"></p><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p><img src="http://tc.holychen.cn/image/image-20210614210142416.png" alt="image-20210614210142416"></p><blockquote><p>if语句陷阱</p></blockquote><ul><li>表达式后面多加分号，变成空语句</li><li>判断相等时 == 误写成赋值 =</li></ul><h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if - else语句"></a>if - else语句</h4><p><img src="http://tc.holychen.cn/image/image-20210614210250588.png" alt="image-20210614210250588"></p><h5 id="if语句-vs-if-else语句"><a href="#if语句-vs-if-else语句" class="headerlink" title="if语句 vs if-else语句"></a>if语句 vs if-else语句</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// if else语句          </span><span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">60</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"及格"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                      <span class="token keyword">else</span>                   <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"不及格"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 多个if语句</span><span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"及格"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"不及格"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>if-else语句能实现的功能，完全也可以用多个if实现，更推荐if-else的写法</p></blockquote><ul><li>if-else代码更简洁，省掉了不必要的”score &lt; 60”的判断</li><li>if-else的代码执行效率更高，只需要进行1次表达式判断：”score &gt;=  60”</li></ul><h4 id="else-if语句"><a href="#else-if语句" class="headerlink" title="else if语句"></a>else if语句</h4><p><img src="http://tc.holychen.cn/image/image-20210614211634375.png" alt="image-20210614211634375"></p><blockquote><p>输入一个整数代表分数，根据分数输出等级(A-E)</p></blockquote><ul><li>A：90-100 ——B：80-89——C：70-79——D：60-69——E：0-59</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//较复杂的写法</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">90</span> <span class="token operator">&lt;=</span> score <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">80</span> <span class="token operator">&lt;=</span> score <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">89</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">70</span> <span class="token operator">&lt;=</span> score <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">79</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">&lt;=</span> score <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">69</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> score <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">60</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"非法输入"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//更简单的写法</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> score <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"非法输入"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">90</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">80</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">70</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">60</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>else-if语句注意点</p></blockquote><ul><li>else if中在对合法输入作限定后，应该将小范围写在前面，大范围写在后面</li><li>更推荐下面简单的写法，省掉了不必要的判断，代码执行效率更高</li></ul><h5 id="if语句-vs-else-if语句"><a href="#if语句-vs-else-if语句" class="headerlink" title="if语句 vs else if语句"></a>if语句 vs else if语句</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//下面两段代码的功能是不一样的</span><span class="token comment" spellcheck="true">//只有其中一个printf会被执行</span><span class="token keyword">int</span> price <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[100,+∞)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"太贵了\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[50,100]</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"还行吧\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[10,50]</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"很便宜\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有可能三个printf都会被执行</span><span class="token keyword">int</span> price <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[100,+∞)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"太贵了\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[50,+∞)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"还行吧\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[10,+∞)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"很便宜\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当多段代码中，只需要选择其中一段来执行时，建议用else if语句</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"负数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当多段代码可能都要被执行时，不能用else if语句</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"奇数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>if、else后可以省略大括号，只会跟其后的第一条语句进行关联</li><li>多个if出现，else后会跟其前面最接近的if相关联</li></ul><p>if语句 ——编译错误</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> price <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>price <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"太贵了\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"买不起\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//夹在if与else中间 编译错误</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"不算贵\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//注意if和else语句中变量的作用域</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编译错误</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编译错误</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编译错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="if-else语句-vs-条件运算符"><a href="#if-else语句-vs-条件运算符" class="headerlink" title="if-else语句 vs 条件运算符"></a>if-else语句 vs 条件运算符</h5><blockquote><p>有一些简单的if-else语句，可以使用条件运算符来替代，以达到简化代码的目的</p></blockquote><h5 id="表达式的等价性"><a href="#表达式的等价性" class="headerlink" title="表达式的等价性"></a>表达式的等价性</h5><p><img src="http://tc.holychen.cn/image/image-20210615002038095.png" alt="image-20210615002038095"></p><p><img src="../Image/image-20210615004111109.png" alt="image-20210615004111109"></p><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p><img src="http://tc.holychen.cn/image/image-20210615012149409.png" alt="image-20210615012149409"></p><h5 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h5><blockquote><p>在switch语句中，break语句的作用：中止switch语句</p></blockquote><blockquote><p>如果case、default后面没有break语句，会出现”贯穿”现象</p></blockquote><ul><li>执行完case、default中的代码后，会继续往下执行其他case、default中的代码</li><li>直到遇到break语句或switch语句的结尾为止</li></ul><p><img src="http://tc.holychen.cn/image/image-20210615013058625.png" alt="image-20210615013058625"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//利用贯穿</span><span class="token keyword">switch</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>    <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>    <span class="token keyword">case</span> <span class="token number">5</span><span class="token punctuation">:</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"春季"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="case的使用注意"><a href="#case的使用注意" class="headerlink" title="case的使用注意"></a>case的使用注意</h5><ul><li>case后面紧跟的表达式不能带有变量</li><li>如果想在case后面声明新的变量，那就必须加上大括号，否则编译报错</li></ul><p><img src="http://tc.holychen.cn/image/image-20210615013722743.png" alt="image-20210615013722743"></p><h5 id="if和switch之间可以相互替代"><a href="#if和switch之间可以相互替代" class="headerlink" title="if和switch之间可以相互替代"></a>if和switch之间可以相互替代</h5><p><img src="http://tc.holychen.cn/image/image-20210615014351578.png" alt="image-20210615014351578"></p><h5 id="if和switch的选择"><a href="#if和switch的选择" class="headerlink" title="if和switch的选择"></a>if和switch的选择</h5><ul><li>当表示一个范围时，建议使用if</li><li>当判断一个变量是否等于一些固定值时，if、switch均可使用</li></ul><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><blockquote><p>很多时候，使用while、do-while、for可以完成一样的功能，只是书写格式不一样</p></blockquote><blockquote><p>在实际开发中，使用频率最多的是for、while</p></blockquote><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><p><img src="http://tc.holychen.cn/image/image-20210615020526675.png" alt="image-20210615020526675"></p><h5 id="while固定次数的打印"><a href="#while固定次数的打印" class="headerlink" title="while固定次数的打印"></a>while固定次数的打印</h5><p><img src="http://tc.holychen.cn/image/image-20210615021115016.png" alt="image-20210615021115016"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//1 - 2 + 3 - 4 + 5 - 6 ... + n</span><span class="token keyword">int</span> value  <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>value <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>value <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> value <span class="token punctuation">:</span> <span class="token operator">-</span>value<span class="token punctuation">;</span>    value<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h4><p><img src="http://tc.holychen.cn/image/image-20210615025028050.png" alt="image-20210615025028050"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">do</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入1-100之间的正整数："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p><img src="http://tc.holychen.cn/image/image-20210615023222797.png" alt="image-20210615023222797"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//请从小到大打印出3、5的前10个公倍数</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="for-语句-vs-while语句"><a href="#for-语句-vs-while语句" class="headerlink" title="for 语句 vs while语句"></a>for 语句 vs while语句</h5><p><img src="http://tc.holychen.cn/image/image-20210615023511753.png" alt="image-20210615023511753"></p><blockquote><p>break语句</p></blockquote><ul><li><p>break语句只用在while、do-while、for、switch语句中</p></li><li><p>break语句的作用：终止其所在的while、do-while、for、switch语句</p></li><li><p>在有多重循环的情况下，break语句只能终止其所在的那一层循环语句</p></li></ul><p><img src="http://tc.holychen.cn/image/image-20210615033735730.png" alt="image-20210615033735730"></p><blockquote><p>continue语句</p></blockquote><ul><li>continue语句只用在while、do-while、for语句中</li><li>continue语句的作用：跳过循环体的剩余部分</li><li>在有多重循环的情况下，continue语句只能作用于其所在的那一层循环语句</li><li>很多时候，巧用continue，可以减少大括号、缩进的数量</li></ul><p><img src="http://tc.holychen.cn/image/image-20210615034211558.png" alt="image-20210615034211558"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><ul><li>goto语句的作用：可以为所欲为地灵活跳转</li><li>goto语句使用起来非常灵活，在有些情况下，还能提高程序的效率</li><li>但goto语句破坏了结构化的设计风格，容易造成代码执行流程的混乱，导致代码难以调试和维护</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BIOS ROM Image分析</title>
      <link href="2021/08/01/BIOS_ROM_Image/"/>
      <url>2021/08/01/BIOS_ROM_Image/</url>
      
        <content type="html"><![CDATA[<h1 id="Flash芯片和生成的BIOS-ROM"><a href="#Flash芯片和生成的BIOS-ROM" class="headerlink" title="Flash芯片和生成的BIOS ROM"></a>Flash芯片和生成的BIOS ROM</h1><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/86ed9927664912afa5ce9778ee3f498.jpg" alt="主板上的NorFlash"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604388851409.png" alt="FPT整刷的bin"></p><h1 id="intel闪存映像布局"><a href="#intel闪存映像布局" class="headerlink" title="intel闪存映像布局"></a>intel闪存映像布局</h1><p>英特尔在相应芯片组的数据表页面上讨论了BIOS的结构。对于所有从第六系列开始的芯片组，此格式通常保持不变，该文件分为3-5个区域，可选的是GbE区域和PDR。</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604388929921.png"></p><h1 id="UEFI-Tool解析"><a href="#UEFI-Tool解析" class="headerlink" title="UEFI Tool解析"></a>UEFI Tool解析</h1><p>用<a href="https://github.com/LongSoft/UEFITool">EFITool</a>工具加载了编译生成的bin文件，发现Reset Vector位于BIOS Rom Image的最底部，探索形成这样的Image结构相关的各种文件(.fdf/.fd/.fv等文件)</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604389109072.png"></p><p>组成结构：16MBIOS + 16M ME + 16M 128KB PDR</p><p>BIOS Rom部分，由GenFv工具根据fdf文件生成</p><pre><code>#FD Section[FD.AMIROM]BaseAddress = 0xff000000Size = 0x1000000ErasePolarity = 1BlockSize = 0x1000NumBlocks = 0x1000DEFINE UNCOMPRESSED_PEI_EXECUTABLES_ALIGNMENT =  DEFINE SEC_CORE_EXECUTABLE_ALIGNMENT = Align = 8......0x0|0x20000FV = LNV_OEM_DATA_REGION0x20000|0x50000FV = NVRAM0x70000|0x50000#RAW - NVRAM_BACKUP0xc0000|0x20000FV = LEM_FV_DATA0xe0000|0x870000FV = FV_MAIN_WRAPPER0x950000|0x20000FV = FV_CMP0x970000|0x10000FV = FV_BCP0x980000|0x110000FV = FV_DATA_BACKUP0xa90000|0x110000FV = FV_DATA0xba0000|0xa0000FV = FV_BB_AFTER_MEMORY_BACKUP0xc40000|0x90000FV = FV_FSP_S_BACKUP0xcd0000|0xa0000FV = FV_BB_AFTER_MEMORY0xd70000|0x90000FV = FV_FSP_S0xe00000|0x70000#FV_FSP_BACKUPFILE = Build/Fsp_Rebased_M_T.fd0xe70000|0x90000FV = FV_BB_BACKUP0xf00000|0x70000#FV_FSPFILE = Build/Fsp_Rebased_M_T.fd0xf70000|0x90000FV = FV_BB#FV Section[FV.FV_MAIN]BlockSize = 0x1000NumBlocks = 0x0FvAlignment = 16MEMORY_MAPPED = TRUEFvNameGuid = 5C60F367-A505-419A-859E-2A4FF6CA6FE5APRIORI DXE &#123;    INF AmiModulePkg/AmiStatusCode/StatusCodeDxe.inf    INF AmiModulePkg/AmiStatusCode/StatusCodeSmm.inf    INF MdeModulePkg/Universal/PCD/Dxe/Pcd.inf    ......!include AmiPkg/Configuration/FontFileStatement.txt!include AmiModulePkg/NVRAM/FvMainDefaultsFdfFileStatement.txt!include AmiChipsetModulePkg/LegacyRom/Vbios/VbiosFdfFileStatements.txt......#FV Section[FV.FV_LOGOROMHOLE]BlockSize = 0x1000NumBlocks = 0x20FvAlignment = 1......FvNameGuid = E54D9684-2735-43ef-A379-30F2F592BA10!include AmiTsePkg/Core/em/AMITSE/Logoffs.txt#FV Section[FV.FV_MEFW_CAPSULE]BlockSize = 0x1000NumBlocks = 0x600FvAlignment = 16......FvNameGuid = 9F8B1DEF-B62B-45F3-8282-BFD7EA19801BINF RuleOverride = SubtypeGuidUncompressedNoChecksum Build/MeFwFid.inf......!include AmiModulePkg/Ofbd/Meud/AutoMeud/MeRegionFdfFileStatement.txt#FV Section[FV.LNV_OEM_DATA_REGION]BlockSize = 0x1000NumBlocks = 0x20FvAlignment = 1......#FV Section[FV.NVRAM]BlockSize = 0x1000NumBlocks = 0x50FvAlignment = 16......FvNameGuid = FA4974FC-AF1D-4E5D-BDC5-DACD6D27BAEC!include AmiModulePkg/NVRAM/NvramFdfFileStatement.txt#FV Section[FV.LEM_FV_DATA]BlockSize = 0x1000NumBlocks = 0x20FvAlignment = 16......FvNameGuid = 4f1c52d3-d824-4d2a-a2f0-ec40c23c5916INF RuleOverride = SubtypeGuidUncompressedNoChecksum ......!include AmiTsePkg/Core/em/AMITSE/Romhole.txt#FV Section[FV.FV_CMP]BlockSize = 0x1000NumBlocks = 0x20FvAlignment = 16......FvNameGuid = aea406cf-4fc8-4dc3-9796-1ee03b64c715!include LenovoModulePkg/Universal/ExtendedComputrace/AbsolutePkg/OEMSpecifiedAgentX64ProductionInstaller.txt#FV Section[FV.FV_BCP]BlockSize = 0x1000NumBlocks = 0x10FvAlignment = 16......FvNameGuid = 8649FC2D-C0E6-4262-AD51-0CEABAB6429EINF RuleOverride = Uncompressed PldmPkg/BiosConfigPreserve/BiosConfigPreserveBin/BCPFlashData/BCPFlashData.inf#FV Section[FV.FV_DATA_BACKUP]BlockSize = 0x1000NumBlocks = 0x110FvAlignment = 16......FvNameGuid = E4A068F1-5EF1-4ACE-857C-7935F8A0C708!include CrbPkg/AmiCrbIntelTopSwap/FvDataBackupFdfFileStatement.txt#FV Section[FV.FV_DATA]BlockSize = 0x1000NumBlocks = 0x110FvAlignment = 16......FvNameGuid = AFDD39F1-19D7-4501-A730-CE5A27E1154BINF RuleOverride = UncompressedBinaryNoChecksum AmiChipsetModulePkg/FIT/ReserveBinary/ReserveBootGuardSaveResigndata.inf!include AmiChipsetModulePkg/FIT/FitTable/FitMicrocodeFdfFileStatement.txt#FV Section[FV.FV_BB_AFTER_MEMORY_BACKUP]BlockSize = 0x1000NumBlocks = 0xa0FvAlignment = 16......FvNameGuid = 5b08a058-784f-4938-9a49-1588aa05f4b9......#FV Section[FV.FV_FSP_S_BACKUP]BlockSize = 0x1000NumBlocks = 0x90FvAlignment = 16!include Intel/CometLakeFspBinPkg/FvFspSFdfFileStatement.txt#FV Section[FV.FV_BB_AFTER_MEMORY]BlockSize = 0x1000NumBlocks = 0xa0FvAlignment = 16......#FV Section[FV.FV_FSP_S]BlockSize = 0x1000NumBlocks = 0x90FvAlignment = 16!include Intel/CometLakeFspBinPkg/FvFspSFdfFileStatement.txt......#FV Section[FV.FV_BB_BACKUP]BlockSize = 0x1000NumBlocks = 0x90FvBaseAddress = 0xfff70000......FvNameGuid = 61C0F511-A691-4F54-974F-B9A42172CE53APRIORI PEI &#123;    INF AmiModulePkg/AmiStatusCode/StatusCodePei.inf    INF AmiModulePkg/IO/NCT6686D/NCT6686DPeiInit.inf    ......!include Build/BiosGuardPubKeyhash_FdfFileStatement.txt!include AmiChipsetModulePkg/FIT/FitTable/FitTableFdfFileStatement.txt!include LenovoModulePkg/Universal/BuildNaming/BuildNaming.txt#FV Section[FV.FV_BB]BlockSize = 0x1000NumBlocks = 0x90FvAlignment = 16......FvNameGuid = 61C0F511-A691-4F54-974F-B9A42172CE53APRIORI PEI &#123;    INF AmiModulePkg/AmiStatusCode/StatusCodePei.inf    INF AmiModulePkg/IO/NCT6686D/NCT6686DPeiInit.inf    INF LenovoModulePkg/Universal/AssetID/AssetIDOnRecoveryMode/AssetIDOnRecoveryModePei.inf    ......!include AmiChipsetModulePkg/BiosGuard/Binary/BiosGuardBinary_FdfFileStatement.txt!include Intel/CometLakePlatSamplePkg/Binaries/Pct/PctGpioFdfFileStatements.txt!include ......</code></pre><p>fdf文件的开头部份是关键字[fd]，它表示完整的BIOS Rom Image。还指定了BIOS的加载地址BaseAddress = 0xff00000，大小Size = 0x1000000(16M)，这与UEFITool给出的数据不谋而合：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604389689841.png"></p><p>根据BIOS Rom Image位于4G空间的顶部(0xFFFFFFFF)，减去Rom Image Size就可以推得Bios Rom加载地址(就是Fdf文件中的BaseAddress=0xff000000)<br>接下来形如下列内容:</p><pre><code>Offset|Size[RegionType]</code></pre><p>则是在FD中开辟了一段连续空间，用来存放FV/FILE等内容。其中Offset和Size是这段空间的相对于整个FD的偏移和大小；前面UEFITool图中”BIOS Region”中列出的每一个FFS项都可以对应到Fdf文件[FD]节中RegionType为FV的项(毕竟只有FV才会用到文件系统FFS)。如果仔细比对，可能会发现UEFITool中倒数第二和倒数第三个FFS的Size和Padding相加正好对应[FD]节中的FV_FSP：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604389914494.png"></p><pre><code>0xf00000|0x70000#FV_FSPFILE = Build/Fsp_Rebased_M_T.fd\</code></pre><p>FV_FSP项的RegionType是FILE，可以包含任意内容，自然也可以包含其他的fd文件，就如NCB_LOGO项中包含了开机Logo文件；其次，fd文件又由fv组成，UEFITool又能解析fd文件，因此造成了这种FDF和BIOS Rom image不一致。其实，我们可以用UEFITool加载Fsp_Rebuild_M_T.fd，发现其中包含两个FFS：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604390180438.png"></p><p>如果FV_FSP包含的fd文件是经过压缩操作的，那么FDF文件中RegionType为FV的项应该和UEFITool实际得到的相一致。</p><p>FDF文件[FD]节之后就是大量的[FV]节，FV的主要作用就是包含组件和模块。他们来填充[FD]节中开辟的空间。先来看一个相对简单的FV节：FV.NVRAM，它只包含一个include语句，指向NvramFdfFileStatement.txt文件:</p><pre><code>!include AmiModulePkg/NVRAM/NvramFdfFileStatement.txt</code></pre><p>NvramFdfFileStatement.txt文件通过FILE指令，包含binary file：</p><pre><code>  FILE RAW = CEF5B9A3-476D-497f-9FDC-E98143E0422C &#123;    $(OUTPUT_DIRECTORY)/Nvram.bin  &#125;</code></pre><p>FV的主要作用就是填充[FD]节中开辟的空间，用这个FV节验证一下：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391042176.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391071513.png"></p><p>FDF中，FV.Nvram位于Bios Rom image的开头，Fv guid：FA4974FC-AF1D-4E5D-BDC5-DACD6D27BAEC，NvramFdfFileStatement.txt中指定的File Guid：CEF5B9A3-476D-497f-9FDC-E98143E0422C；用UEFITool加载Bios Rom image，第一个FFS(就是FV.Nvram)的Volume GUID: FA4974FC-AF1D-4E5D-BDC5-DACD6D27BAEC；再展开FFS，其中包含的唯一的文件的File Guid: CEF5B9A3-476D-497F-9FDC-E98143E0422C，这些值和FDF中的Fv Guid以及File Guid是一致的。<br>除了File Guid是一致的，用UEFITool解压后得到的Nvram.bin和原始的Nvram.bin的内容也是一致的：</p><p>以上是简单的FV的情况，有些复杂的FV中可以嵌套其他的FV，如FDF中的FV.FV_MAIN_WRAPPER，我们再来分析一下它：</p><pre><code>#FV Section[FV.FV_MAIN_WRAPPER]BlockSize = 0x1000NumBlocks = 0x870......!include AmiPkg/Configuration/NestedFvMainFdfFileStatement.txt</code></pre><p>FV.FV_MAIN_WRAPPER节中内容不多，仅仅含有若干条!include语句，但是FV.FV_MAIN_WRAPPER节占据BIOS Rom Image很大一块空间：BlockSize<em>NumBlocks=0x1000</em>0x870=0x870000。它占用如此多空间的原因是NestedFvMainFdfFileStatement.txt通过FILE指令包含了一块压缩的FV文件，而该FV文件是Dxe阶段的代码</p><p>NestedFvMainFdfFileStatement.txt的内容如下：</p><pre><code>#Includes FVMAIN FV imageFILE FV_IMAGE = 9E21FD93-9C72-4c15-8C4B-E77F1DB2D792 $(FFS_FILE_CHECKSUM_KEYWORD) &#123;  SECTION $(PEI_COMPRESSION_SECTION) &#123;    SECTION FV_IMAGE = FV_MAIN  &#125;&#125;</code></pre><p>FV_MAIN节内容如下：</p><pre><code>#FV Section[FV.FV_MAIN]BlockSize = 0x1000NumBlocks = 0x0FvAlignment = 16......INF AmiModulePkg/RomLayout/RomLayoutDxe.infINF MdeModulePkg/Core/Dxe/DxeMain.infINF AmiModulePkg/Bds/Bds.inf</code></pre><p>前面找到Dxe阶段的代码，那Sec和Pei阶段的代码在哪？platform.fdf文件[fd]节中设定FV_BB节位于Bios Rom image的尾部，因此，我们可以猜测并验证Sec模块和Pei模块也位于FV_BB中：</p><pre><code>[FV.FV_BB]BlockSize = 0x1000NumBlocks = 0xa0...APRIORI PEI &#123; ;PEI阶段的APRIORI文件    INF AmiModulePkg/AmiStatusCode/StatusCodePei.inf    ...&#125;...INF MdeModulePkg/Core/Pei/PeiMain.inf ;Pei阶段入口...INF UefiCpuPkg/SecCore/SecCore.inf ;Sec阶段入口...INF UefiCpuPkg/CpuIoPei/CpuIoPei.infINF MdeModulePkg/Universal/PcatSingleSegmentPciCfg2Pei/PcatSingleSegmentPciCfg2Pei.inf</code></pre><p>虽然，我们已经确定Sec模块和Pei模块位于FV_BB块中，但是有个问题随之出现：SecCore.inf并不是FV_BB中最后一个模块(夹在其他模块之间)，所以一眼看去感觉开机时执行的第一条指令并不在SecCore模块中，这明显与EFI Spec相悖。更何况SecCore.inf含有ResetVector：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391678324.png" alt="SecCore.inf部分内容"></p><p>另外，UEFITool也明显显示SecCore位于Bios Rom image尾部</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391761934.png"></p><p>fdf的设定和实际现象有差异，那一定是GenFv在生成Bios Rom image时有特殊处理。和GenFv Build Bios相关的只能查看Build.log，它记录了从源码到制成Rom Image的全过程，在Build.log的结尾，记录了各个模块在Bios Rom Image的排列位置，我发现了特殊的一处Firmware Volumon:08 No.049 类型是SECC—-SecCore，属性被标记为VTF，Bios Rom Image中其他FV中任何模块都不具有该属性：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391860137.png"></p><p>在PI spec Vol3中提到：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604392019507.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604392038413.png"></p><p>VTF是Volume Top File的缩写，PI spec规定VTF的File Guid为EFI_FFS_VOLUME_TOP_FILE_GUID（1BA0062E-C779-4582-8566-336AE8F78F09），必须位于firmware volume的最后一个字节。而SecCore.inf的FILE_GUID = 1BA0062E-C779-4582-8566-336AE8F78F09。看来只要某个inf指定自己FILE_GUID为EFI_FFS_VOLUME_TOP_FILE_GUID就有机会被安排在最开始执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flash,Layout,FV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/08/01/OemWmi%20Demo/"/>
      <url>2021/08/01/OemWmi%20Demo/</url>
      
        <content type="html"><![CDATA[<h1 id="WMI简介"><a href="#WMI简介" class="headerlink" title="WMI简介"></a>WMI简介</h1><h2 id="WMI历史"><a href="#WMI历史" class="headerlink" title="WMI历史"></a>WMI历史</h2><p>Windows Management Instrumentation（WMI）是Microsoft基于Web的企业管理（WBEM）的实现，WBEM是一项行业倡议，旨在开发用于在企业环境中访问管理信息的标准技术。WMI使用通用信息模型（CIM）行业标准来表示系统，应用程序，网络，设备和其他托管组件。CIM由分布式管理任务组（<a href="https://www.dmtf.org/standards/wsman">DMTF</a>）开发和维护。WMI最初于1998年作为Windows NT 4.0 Service Pack 4的附加组件发布，是Windows 2000，Windows XP和Windows Server 2003家族操作系统中内置的支持核心管理的技术。(详情见微软官网<a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/about-wmi">WMI Document</a>)。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在WMI之前，可以通过编程方式访问Windows资源的唯一方法是通过Win32 API。 这种情况使Windows系统管理员无法轻松地使用流行的脚本语言来自动化常见的系统管理任务，因为大多数脚本语言无法直接调用Win32 API。 WMI通过提供一个一致的模型和框架来描述所有Windows资源并将其公开给外界，从而改变了这种状况。 WMI是一种工具和管道，通过它可以访问，配置，管理和监视所有（几乎所有）Windows资源，系统管理员可以使用WMI脚本库创建系统管理脚本，以管理通过WMI公开的任何Windows资源！</p><h2 id="BIOS与WMI的关系"><a href="#BIOS与WMI的关系" class="headerlink" title="BIOS与WMI的关系"></a>BIOS与WMI的关系</h2><p>通常，BIOS不需要为WMI做任何事情，Windows提供了Windows管理所需的所有WMI。 但是有时候，客户想要实现特殊的OEM功能，则需要BIOS通过WMI与AP / Driver配合，例如在CML 7C43&amp;P340 Project中Lenovo Module通过LenovoGameZone.mof和Lenovo.mof作为Provider，声明BIOS提供给OS的WMI接口。<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383419998.png"></p><h2 id="WMI架构图"><a href="#WMI架构图" class="headerlink" title="WMI架构图"></a>WMI架构图</h2><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383435473.png"></p><p>wmi可以使用多种方式进行调用，具体可以参考上图：<br>首先是wm使用者，比如脚本或者其他用到wm接口的应用程序。由wm使用者访问CIM对象管理器WinMgmt(即WMI服务）,后者再访问CIM(公共信息模型Common Information Model)存储库。静态或动态的信息（对象的属性）就保存在CM库中，同时保存对象的方法。比如启动一个服务，通过执行对象的方法实现，实际上是通过COM技术调用各种dll,最后由dll中封装的API完成请求。WMI是事件驱动的，操作系统、服务、应用程序、设备驱动程序等都可以作为事件源，通过COM接口生成事件通知，WinMgmt捕捉到事件，然后刷新CM库中的动态信息。这也是为什么WM服务依赖于EventLog的原因。就像注册表有Key和Value一样，CIM库也有分类，用面向对象的术语描述来说，叫做命名空间（Name Space)。</p><h1 id="OemWmi-ModulePart"><a href="#OemWmi-ModulePart" class="headerlink" title="OemWmi ModulePart"></a>OemWmi ModulePart</h1><h2 id="ModulePart说明"><a href="#ModulePart说明" class="headerlink" title="ModulePart说明"></a>ModulePart说明</h2><p>建立OemWmi ModulePart，简单的封装一个接口注册到OS下，实现向80 Port写值的动作，应用层可以通过通过VB Script或C++调用。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><ul><li>OemWmi.mof</li></ul><pre><code>//****************************************************//filename:MyWmi.mof// MOF(Managed Object File) Sample// 2020.08.05// MOF comment as C++#pragma AUTORECOVER//WMI checks the integrity of the WMI repository when the operating system//starts WMI. If the repository is damaged, WMI automatically rebuilds the //repository and recompiles it.#pragma namespace(&quot;\\root\\wmi&quot;)//specify the namespace when autorecover or register.[WMI, Dynamic, Provider(&quot;WmiProv&quot;), Locale(&quot;MS\\0x409&quot;), Description(&quot;My WMI Sample Class&quot;), guid(&quot;&#123;E2E0B817-EA48-4bad-81A6-FBEB8776A7AF&#125;&quot;)]//WMI Class Qualifiersclass MyClass&#123;    [key, read] string InstanceName;    [read] Boolean Active;    [WmiMethodId(1),     Implemented,     read, write,     Description(&quot;Send to Port 0x80&quot;)    ]void SendTo80([in] uint8 Data);&#125;;//Required Items in WMI Class//*****************************************************</code></pre><ul><li>OemWmi.sdl</li></ul><pre><code> PCIDEVICE    Title  = &quot;OemWmi&quot;    Parent  = &quot;PciHost (Virtual)&quot;    Attribute  = &quot;0x0&quot;      Dev_type  = &quot;Container&quot;    Dev  = 00h    Fun  = 00h    SleepNum  = 01h    ASLfile  = &quot;&#39;OemPkg\OemWmi\OemWmi.asl;After Pci Tree&#39;&quot;    DeviceType = OnBoard    PCIBusSize = 32bit    ROMMain = No    Virtual = YesEndTOKEN    Name  = &quot;OemWmi_INF_SUPPORT&quot;    Value  = &quot;1&quot;    Help  = &quot;Main switch to enable OemWmi support in Project&quot;    TokenType = Boolean    TargetMAK = Yes    Master = YesEndINFComponent    Name  = &quot;OemWmi&quot;    File  = &quot;OemWmi.inf&quot;    Package  = &quot;OemWmi&quot;    Token = &quot;OemWmi_INF_SUPPORT&quot; &quot;=&quot; &quot;1&quot;End</code></pre><ul><li>OemWmi.cif</li></ul><pre><code> PCIDEVICE    Title  = &quot;OemWmi&quot;    Parent  = &quot;PciHost (Virtual)&quot;    Attribute  = &quot;0x0&quot;      Dev_type  = &quot;Container&quot;    Dev  = 00h    Fun  = 00h    SleepNum  = 01h    ASLfile  = &quot;&#39;OemPkg\OemWmi\OemWmi.asl;After Pci Tree&#39;&quot;    DeviceType = OnBoard    PCIBusSize = 32bit    ROMMain = No    Virtual = YesEndTOKEN    Name  = &quot;OemWmi_INF_SUPPORT&quot;    Value  = &quot;1&quot;    Help  = &quot;Main switch to enable OemWmi support in Project&quot;    TokenType = Boolean    TargetMAK = Yes    Master = YesEndINFComponent    Name  = &quot;OemWmi&quot;    File  = &quot;OemWmi.inf&quot;    Package  = &quot;OemWmi&quot;    Token = &quot;OemWmi_INF_SUPPORT&quot; &quot;=&quot; &quot;1&quot;End</code></pre><ul><li>OemWmi.asl</li></ul><pre><code>Scope( \_SB )&#123; Device(WMI2)&#123;        // PNP0C14 is Plug and Play ID assigned to WMI mapper    Name(_HID, EISAID(&quot;PNP0C14&quot;))    Name(_UID, 2)        //        // _WDG evaluates to a data structure that specifies the data        // blocks supported by the ACPI device.        //    Name(_WDG, Buffer() &#123;         //guid&#123;E2E0B817-EA48-4bad-81A6-FBEB8776A7AF&#125;        // -------- Method execution for SendTo80            0x17, 0xb8, 0xe0, 0xe2, 0x48, 0xea, 0xad, 0x4b, 0x81, 0xa6,            0xfb, 0xeb, 0x87, 0x76, 0xa7, 0xaf,            69, 49,     // Object ID (E1)            1,          // Instance Count            0x02,       // Flags WMIACPI_REGFLAG_METHOD             // -------- MOF data            0x21, 0x12, 0x90, 0x05, 0x66, 0xd5, 0xd1, 0x11, 0xb2, 0xf0,            0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10,            66, 65,     // Object ID (BA)            1,          // Instance Count            0x00,       // Flags    &#125;)   OperationRegion (DBG, SystemIO, 0x80, 0x2)   Field (DBG, WordAcc, NoLock, Preserve)   &#123;        P80H, 16   &#125;    Method(WME1, 3) &#123;    If(LEqual(Arg1,1))    &#123;      Store(Arg2,P80H)    &#125;     Return(0)        &#125;    Name(WQBA, Buffer()    &#123;    0x46, 0x4f, 0x4d, 0x42, 0x01, 0x00, 0x00, 0x00, 0x74, 0x02, 0x00, 0x00, 0x80, 0x05, 0x00, 0x00,    0x44, 0x53, 0x00, 0x01, 0x1a, 0x7d, 0xda, 0x54, 0x28, 0xd3, 0x82, 0x00, 0x01, 0x06, 0x18, 0x42,    0x20, 0xc4, 0x01, 0x89, 0xc0, 0xb2, 0x69, 0x24, 0xc2, 0x01, 0x0c, 0x46, 0x03, 0x88, 0xe4, 0x40,    0xc8, 0x05, 0x13, 0x83, 0x0b, 0x21, 0xaf, 0x02, 0x6c, 0x0a, 0x30, 0x09, 0xa2, 0xfe, 0xfd, 0x21,    0x4a, 0x82, 0x43, 0x09, 0x81, 0x90, 0x44, 0x01, 0xe6, 0x05, 0xe8, 0x16, 0x60, 0x58, 0x80, 0x6d,    0x01, 0xa6, 0x05, 0x38, 0x86, 0xa4, 0xd2, 0xc0, 0x29, 0x81, 0xa5, 0x40, 0x48, 0xa8, 0x00, 0xe5,    0x02, 0x7c, 0x0b, 0xd0, 0x8e, 0x28, 0xc9, 0x02, 0x2c, 0xc3, 0x88, 0xc0, 0xa3, 0x88, 0x6c, 0x34,    0x0e, 0x8d, 0x1d, 0x86, 0x65, 0x82, 0x69, 0x10, 0x87, 0x51, 0x36, 0xb2, 0x08, 0x3c, 0xa1, 0x4e,    0x05, 0xc8, 0x15, 0x20, 0x4c, 0x80, 0x78, 0x54, 0x61, 0x34, 0x07, 0x45, 0xf0, 0x43, 0x63, 0xc4,    0x8c, 0x89, 0xc0, 0x76, 0x8e, 0xad, 0x51, 0x9c, 0x46, 0xe1, 0x02, 0xa4, 0x63, 0x68, 0x04, 0xc7,    0x15, 0xde, 0x23, 0x2b, 0x68, 0x86, 0x14, 0xe4, 0x10, 0xce, 0xcd, 0x80, 0xa7, 0x61, 0x9c, 0x0e,    0x41, 0x04, 0x14, 0x3b, 0xc2, 0x01, 0x6b, 0x10, 0x28, 0x19, 0x10, 0xf2, 0x2c, 0xc0, 0xfa, 0xe8,    0x08, 0x81, 0xdd, 0x0b, 0xb0, 0x28, 0x40, 0x19, 0x84, 0xc6, 0x53, 0xe1, 0xf8, 0x0b, 0x30, 0x26,    0xc0, 0x9b, 0x00, 0x5b, 0x38, 0x32, 0x38, 0x27, 0xe1, 0x44, 0x89, 0x51, 0xf1, 0x0c, 0x84, 0x1a,    0x25, 0x9c, 0xb1, 0x6a, 0x43, 0x91, 0x46, 0x54, 0x21, 0xc6, 0x35, 0x6c, 0x84, 0x48, 0xb1, 0x62,    0x84, 0x88, 0xd5, 0xfe, 0x20, 0x48, 0x9c, 0xb3, 0x80, 0x24, 0x80, 0x28, 0xd2, 0x68, 0x50, 0xe3,    0x4f, 0xf0, 0x3c, 0xe0, 0x99, 0x9d, 0xdd, 0x41, 0x1d, 0xe0, 0x49, 0x04, 0x39, 0xc7, 0x33, 0xab,    0x73, 0x72, 0x64, 0xc8, 0x0c, 0x2b, 0xc1, 0xbf, 0x81, 0x4f, 0x06, 0x78, 0xd7, 0x80, 0x9a, 0xe9,    0x03, 0x01, 0x9b, 0x65, 0x38, 0xcc, 0x10, 0xfd, 0xff, 0x1f, 0x74, 0xb8, 0xf3, 0xf2, 0x48, 0x18,    0xc4, 0x11, 0x3e, 0x0b, 0x60, 0x47, 0x7c, 0x32, 0xc7, 0x5d, 0xaa, 0x00, 0xb3, 0x97, 0x00, 0x4d,    0x2e, 0xc1, 0xf1, 0xf8, 0x04, 0xe0, 0xf9, 0x9c, 0x70, 0x02, 0xcb, 0x1f, 0x04, 0x6a, 0x64, 0x86,    0xf6, 0x14, 0x4f, 0xeb, 0x45, 0xc0, 0xe7, 0x83, 0xc3, 0x62, 0x62, 0x21, 0xa4, 0x00, 0x42, 0xe3,    0x01, 0xff, 0xe0, 0x9f, 0x0e, 0x22, 0x3c, 0x17, 0x78, 0xbe, 0x3e, 0x36, 0xc0, 0x18, 0x90, 0xfd,    0x0a, 0x40, 0x08, 0xfe, 0xe2, 0x70, 0x44, 0xcf, 0x08, 0x11, 0x1e, 0x14, 0xd8, 0x11, 0x01, 0x27,    0xf0, 0xd8, 0x80, 0x86, 0xe6, 0x47, 0x80, 0xc8, 0x61, 0xcf, 0x24, 0xf4, 0xb1, 0x44, 0x89, 0x7c,    0x30, 0x3e, 0x50, 0x18, 0xe1, 0x14, 0x9f, 0x23, 0x7a, 0xbf, 0x54, 0x10, 0x02, 0xcb, 0x59, 0xa2,    0x4e, 0x1e, 0x96, 0x02, 0x22, 0x1b, 0x8b, 0xf4, 0x11, 0x83, 0x4a, 0xa1, 0x12, 0xfc, 0x69, 0x1d,    0xd6, 0x41, 0x9e, 0x5c, 0xec, 0xd7, 0x84, 0x73, 0xf4, 0x23, 0x84, 0x1d, 0x43, 0x78, 0x74, 0x08,    0x05, 0x1f, 0x0d, 0x65, 0x73, 0x54, 0x30, 0x0a, 0xe2, 0x81, 0x3b, 0x06, 0x84, 0x8c, 0x9c, 0x01,    0x50, 0x23, 0xf7, 0xf1, 0xe2, 0xf4, 0xde, 0x15, 0x7c, 0x22, 0x21, 0x07, 0x05, 0x68, 0x77, 0x02,    0x9f, 0x00, 0x38, 0x9c, 0x3f, 0x27, 0x14, 0x8e, 0x5c, 0x00, 0x4e, 0x20, 0x01, 0x97, 0x75, 0x10,    0x80, 0xf2, 0xff, 0x3f, 0x08, 0xe0, 0x2e, 0x19, 0x9e, 0xc2, 0xb9, 0x1c, 0xdf, 0xa1, 0x63, 0xcf,    0x01, 0xf0, 0x80, 0x3c, 0x77, 0x2b, 0x1d, 0x3f, 0x9d, 0x42, 0x88, 0x30, 0xd1, 0x0c, 0x8f, 0x89,    0x0d, 0xa1, 0x3f, 0x8c, 0xc7, 0xe3, 0x61, 0xf1, 0xe3, 0x80, 0x4f, 0x2a, 0x0c, 0xfb, 0xe4, 0x0f,    0xa6, 0xe8, 0xc1, 0x6b, 0xf6, 0xc7, 0xf4, 0xca, 0xe0, 0x41, 0x1b, 0xd6, 0x03, 0xe5, 0xb0, 0x46,    0x7b, 0x2a, 0xe1, 0x57, 0x0d, 0x4f, 0xcc, 0x18, 0x61, 0x7d, 0xc8, 0x00, 0x07, 0x20, 0xfe, 0x8a,    0xf0, 0x7e, 0xe1, 0x09, 0x18, 0x90, 0xcd, 0xf1, 0xd1, 0x05, 0x2c, 0xe7, 0x04, 0x3e, 0x88, 0x50,    0x91, 0x62, 0x1c, 0x6e, 0x8c, 0x90, 0x61, 0xa2, 0x3c, 0xce, 0xf8, 0xae, 0xc0, 0x14, 0xda, 0xf4,    0xa9, 0xd1, 0xa8, 0x55, 0x83, 0x32, 0x35, 0xca, 0x34, 0xa8, 0xd5, 0xa7, 0x52, 0x63, 0xc6, 0x4e,    0x28, 0x16, 0xf2, 0x4c, 0xd0, 0x70, 0x1d, 0x03, 0x84, 0x06, 0xa5, 0xd0, 0x49, 0xc1, 0xb1, 0x41,    0x04, 0xe4, 0xff, 0x3f    &#125;)&#125;//End of Device(WMI2)&#125;//End of Scope(\_SB)</code></pre><h2 id="MOF编译为BMF"><a href="#MOF编译为BMF" class="headerlink" title="MOF编译为BMF"></a>MOF编译为BMF</h2><p>Bios\Windows通过WMI相互通信需要借助MOF(经过编译后为BMF)文件，MOF描述了BIOS导出的WMI接口名字。按<a href="https://docs.microsoft.com/en-us/previous-versions/windows/hardware/design/dn614028(v=vs.85)">Windows Instrumentation: WMI and ACPI</a>的描述，MOF可能存在于2处：</p><ul><li>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WmiAcpi的MofImagePath指定；不过我在CML 7C43 Project MB中没有找到这样的设定，应该是应用层编写WMI Provider，生成dll会采取这种方式Register，所以不做讨论。</li><li>作为Buffer资源，将编译的MOF文件二进制BMF资源包进ASL Source  Code，嵌入到ACPI命名空间下。</li></ul><p>一个MOF描述文件，它经过mofcomp编译后，会生成二进制MOF资源文件。OEM厂商提取MOF资源文件中的字节流，嵌入到ACPI命名对象中。另外，WDK工具集中还提供wmimofck工具，该工具以MOF资源文件为输入，生成MOF所描述的WMI接口的测试脚本。下面两行命令将依次生成bmf文件(即MOF资源文件)和vbs接口测试脚本：<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383756674.png"></p><h2 id="ASL-Code部分逻辑"><a href="#ASL-Code部分逻辑" class="headerlink" title="ASL Code部分逻辑"></a>ASL Code部分逻辑</h2><p>BIOS在ASL Source Code中需要向WMI mapper声明设备:PNP0C14和_WDG对象。另外，OEM厂商或者IBV会在声明_WDG对象时，顺带声明嵌入式MOF对象。ACPI spec没有规定嵌入式MOF对象的名字，所以各家OEM会有不同的对象名。但是这并不是问题，它是有迹可循的：</p><ul><li>嵌入式MOF对象位于_WDG对象附近，并且具有形如”Name (WQxy, Buffer()){…”的ACPI对象定义，(其含义为：定义一个包含MOF资源的Buffer，并将该Buffer命名为WQxy。前缀WQ代表这是WMI查询接口，xy是2个16进制数值，用于标识WMI查询接口);</li><li>最重要的，该ACPI对象定义中包含了大量的16进制Byte，即BMF文件的字节流，并且开头4Byte是一个魔术字:”FOMB”，如下：<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383810323.png"><h1 id="OS下调用"><a href="#OS下调用" class="headerlink" title="OS下调用"></a>OS下调用</h1><h2 id="Related-Tool"><a href="#Related-Tool" class="headerlink" title="Related Tool"></a>Related Tool</h2>为了验证WMI功能，我们可以使用WMICodeCreator，它是Microsoft的免费工具。 下载：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=8572">WMI Code Creator v1.0</a>，使用WMI Code Creator工具可以生成VBScript，C＃和VB .NET代码，这些代码使用WMI完成管理任务，例如查询管理数据，从WMI类执行方法或使用WMI接收事件通知。<br>或者也可用第三方开源软件<a href="https://github.com/vinaypamnani/wmie2/releases">WMI Explorer</a>来对WMI进行管理查询。<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383882848.png"><h2 id="指定method调用"><a href="#指定method调用" class="headerlink" title="指定method调用"></a>指定method调用</h2>以管理员身份运行WMICodeCreator.exe，来验证和执行BIOS提供的WMI接口，先执行Query for data from a WMI class，再执行Excute a method，Namespace选择root\WMI，Classes选择MyClass。<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383902165.png"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383920078.png"><h2 id="VB-Script调用"><a href="#VB-Script调用" class="headerlink" title="VB Script调用"></a>VB Script调用</h2><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383950989.png"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383964733.png"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/08/01/StatusCode/"/>
      <url>2021/08/01/StatusCode/</url>
      
        <content type="html"><![CDATA[<h1 id="StatusCode是什么"><a href="#StatusCode是什么" class="headerlink" title="StatusCode是什么"></a>StatusCode是什么</h1><blockquote><p>StatusCode即状态码，它能让系统组件报告它们的当前状态,比如当前正在进行CPU初始化、内存初始化等，你将很清楚系统何时运行在哪，出现何种错误，这样将极利于我们调试</p></blockquote><h1 id="为什么需要StatusCode"><a href="#为什么需要StatusCode" class="headerlink" title="为什么需要StatusCode"></a>为什么需要StatusCode</h1><blockquote><p>由于BIOS涉及规范与组件极多，我们无法了解BIOS所有内容，同时，大量的组件导致后期维护极为困难，若没有状态码，我们很难清除到底是哪个组件的哪类Bug导致这个问题，若对应组件会报告它的状态码，无疑对我们维护带来极大的便利</p></blockquote><blockquote><p>没有状态码，当前出现了一个错误导致系统直接hang机了，此时要想调试这个错误极其困难（考虑一种情况，你的主板没有蜂鸣器，同时没有80卡，此时由于一些系统错误导致整个系统开不了机，请问怎么办。此时，估计你的想法是，我怎么知道怎么办，我还想问别人呢。），当存在状态码时，系统出现一个错误导致系统直接hang机，状态码指示内存报告了一个错误状态，这样，我们一下就能定位错误，对于我们调试是有极大帮助的</p></blockquote><h1 id="怎样使用StatusCode"><a href="#怎样使用StatusCode" class="headerlink" title="怎样使用StatusCode"></a>怎样使用StatusCode</h1><blockquote><p>报告状态码的函数是 ReportStatusCode()，ReportStatusCode()主要的参数有5个，另外一个参数是This指针，This指针对于DXE阶段的ReportStatusCode()不存在。<br>分为：PEI阶段的ReportStatusCode，DXE阶段的ReportStatusCode，Runtime阶段的ReportStatusCode</p></blockquote><ul><li><p>PEI阶段通过Locate EFI_PEI_REPORT_PROGRESS_CODE_PPI_GUID获得句柄handle,在通过handle-&gt;ReportStatusCode()调用。或通过PeiService-&gt;ReportStatusCode()来调用。 </p></li><li><p>DXE阶段通过Locate EFI_STATUS_CODE_RUNTIME_PROTOCOL_GUID获得句柄handle，再通过handle-&gt;ReportStatusCode()调用。</p></li><li><p>Runtime阶段是通过Locate EFI_SMM_STATUS_CODE_PROTOCOL_GUID获得句柄handle，再通过handle-&gt;ReportStatusCode()调用。</p></li></ul><h2 id="ReportStatusCode"><a href="#ReportStatusCode" class="headerlink" title="ReportStatusCode()"></a>ReportStatusCode()</h2><ul><li>pPEI-&gt;ReportStatusCode()或PeiServices-&gt;ReportStatusCode() </li><li>pDXE-&gt;ReportStatusCode() </li><li>pSMM-&gt;ReportStatusCode() </li></ul><h2 id="ReportStatusCode-主要参数"><a href="#ReportStatusCode-主要参数" class="headerlink" title="ReportStatusCode()主要参数"></a>ReportStatusCode()主要参数</h2><ul><li><p>EFI_STATUS_CDOE_TYPE     Type </p></li><li><p>EFI_STATAS_CODE_VALUE    Value </p></li><li><p>UINT32                                      Instance </p></li><li><p>EFI_GUID                                  *CallerrId </p></li><li><p>EFI_STATUS_CODE_DATA      *Data </p><h2 id="EFI-STATUS-CODE-TYPE-Type"><a href="#EFI-STATUS-CODE-TYPE-Type" class="headerlink" title="EFI_STATUS_CODE_TYPE Type"></a>EFI_STATUS_CODE_TYPE Type</h2><blockquote><p>这个参数指明 Status Code 的类型，它是4字节变量，由3部分组成，分别是：StatusCode类别、StatusCode严重性、StatusCode保留部分</p></blockquote></li><li><p>类别占最低8位，当前有效的类别是EFI_PROGRESS_CODE(进程码)、EFI_ERROR_CODE(错误码)、EFI_DEBUG_CODE(调试码)。</p><ul><li>  进程码(EFI_PROGRESS_CODE)用于说明当前处在某一过程中，如在跑 PEIM 或在跑 DXE 。 </li><li>  错误码(EFI_ERROR_CODE)用于说明某一组件出现了错误，如内存错误等。 </li><li>  调试码(EFI_DEBUG_CODE)是为调试目的而认为添加，非调试状态，屏蔽。 </li></ul></li><li><p>严重性占最高8位，当前有效的严重性是EFI_ERROR_MINOR(小错误)、EFI_ERROR_MAJOR(主错误)、EFI_ERROR_UNRECOVERED(未恢复)、EFI_ERROR_UNCONTAINED(未包含)。 </p></li><li><p>保留占中间16位，暂时未使用</p></li></ul><pre><code> ////// Status Code Type Definition.///typedef UINT32  EFI_STATUS_CODE_TYPE;////// A Status Code Type is made up of the code type and severity./// All values masked by EFI_STATUS_CODE_RESERVED_MASK are/// reserved for use by this specification.//////@&#123;#define EFI_STATUS_CODE_TYPE_MASK     0x000000FF#define EFI_STATUS_CODE_SEVERITY_MASK 0xFF000000#define EFI_STATUS_CODE_RESERVED_MASK 0x00FFFF00///@&#125;////// Definition of code types. All other values masked by/// EFI_STATUS_CODE_TYPE_MASK are reserved for use by/// this specification.//////@&#123;#define EFI_PROGRESS_CODE             0x00000001#define EFI_ERROR_CODE                0x00000002#define EFI_DEBUG_CODE                0x00000003///@&#125;////// Definitions of severities, all other values masked by/// EFI_STATUS_CODE_SEVERITY_MASK are reserved for use by/// this specification./// Uncontained errors are major errors that could not contained/// to the specific component that is reporting the error./// For example, if a memory error was not detected early enough,/// the bad data could be consumed by other drivers.//////@&#123;#define EFI_ERROR_MINOR               0x40000000#define EFI_ERROR_MAJOR               0x80000000#define EFI_ERROR_UNRECOVERED         0x90000000#define EFI_ERROR_UNCONTAINED         0xa0000000///@&#125;</code></pre><h2 id="EFI-STATUS-CODE-VALUE-Value"><a href="#EFI-STATUS-CODE-VALUE-Value" class="headerlink" title="EFI_STATUS_CODE_VALUE Value"></a>EFI_STATUS_CODE_VALUE Value</h2><blockquote><p>这个参数是StatusCode的值，它是4字节变量，由3部分组成，分别是：类别(最高8位)、子类(次高8位)、操作(最低16位)。</p></blockquote><blockquote><p>类型分为四个大类：电脑单元、用户可读写外设、IO总线、软件。前三者为硬件类，最后一个为软件类。</p></blockquote><blockquote><p>具体组合可参考PI规范卷3,第6小结</p></blockquote><pre><code>#define EFI_STATUS_CODE_CLASS_MASK          0xFF000000 #define EFI_STATUS_CODE_SUBCLASS_MASK       0x00FF0000 #define EFI_STATUS_CODE_OPERATION_MASK      0x0000FFFF </code></pre><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604384875690.png" alt="StatusCode"></p><h2 id="UINT32-Instance"><a href="#UINT32-Instance" class="headerlink" title="UINT32 Instance"></a>UINT32 Instance</h2><blockquote><p>这个是用来指明状态码的实例，有些组件可能有相同的Type和Value，例如PEI Code，可能会都Report正在运行PEI Code的StatusCode，此时可通过Instance来区分具体哪个PEI Code Report了Status。</p></blockquote><blockquote><p>当存在多处理器时，它可以指明具体哪个处理器，哪个组件报告的状态码。</p></blockquote><h2 id="EFI-GUID-CallerId"><a href="#EFI-GUID-CallerId" class="headerlink" title="EFI_GUID *CallerId"></a>EFI_GUID *CallerId</h2><blockquote><p>指明谁报告了状态码，比如程序员A和程序员B，此参数对不同调用者调用不同的状态码驱动。例如，此参数我们可以这样运用：当此参数为NULL或不为我指定的Guid，跳过我们的状态码函数。</p></blockquote><h2 id="EFI-STATUS-CODE-DATA-Data"><a href="#EFI-STATUS-CODE-DATA-Data" class="headerlink" title="EFI_STATUS_CODE_DATA *Data"></a>EFI_STATUS_CODE_DATA *Data</h2><blockquote><p>这个参数附带一些附加的状态数据，如字符串调试信息，时间等，以让我们更详细的了解当前状态</p></blockquote><blockquote><p>这里主要讲解 EFI_STATUS_CODE_DATA_TYPE_STRING，系统使用的丢字符串信息的 Debug 函数都是利用这个结构来丢字符串</p></blockquote><blockquote><p>具体的数据可参考PI规范卷3，第6小结</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604384875667.png"></p><h1 id="Code中关于StatusCode的实现"><a href="#Code中关于StatusCode的实现" class="headerlink" title="Code中关于StatusCode的实现"></a>Code中关于StatusCode的实现</h1><blockquote><p>AptioV的Code中StatusCode是作为一个ModulePart包含在Core Module中，完整的名字是AmiStatusCode。StatusCode需要做初始化，初始化之后StatusCode才能正常使用。</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604384875679.png" alt="AmiStatusCode"></p><h2 id="StatusCode初始化"><a href="#StatusCode初始化" class="headerlink" title="StatusCode初始化"></a>StatusCode初始化</h2><blockquote><p>StatusCode初始化是通过PeiStatusCodeInitialize和DxeStatusCodeInitialize完成的。这两个函数是Elink，我们可以根据需要挂着我们所需的初始化函数。</p></blockquote><ul><li>PeiStatusCodeInitialize</li><li>DxeStatusCodeInitialize</li></ul><h2 id="AmiStatusCode组成"><a href="#AmiStatusCode组成" class="headerlink" title="AmiStatusCode组成"></a>AmiStatusCode组成</h2><blockquote><p>AmiStatusCode主要由3部分组成，分别是StatusCodePei，StatusCodeDxe，StatusCodeSmm</p></blockquote><ul><li><p>StatusCodePei通过调用StatusCodePei.c中的PeiInitStatusCode()完成Install PEI StatusCode Protocol。</p></li><li><p>StatusCodeDxe通过调用StatusCodeDxe.c中的DxeRuntimeInitStatusCode()完成Install DXE StatusCode Protocol。 </p></li><li><p>StatusCodeSmm通过调用StatusCodeSmm.c中的SmmInitStatusCode()完成Install SMM StatusCode Protocol。</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604384875680.png"></p><h2 id="ReportStatusCode-最终实现函数"><a href="#ReportStatusCode-最终实现函数" class="headerlink" title="ReportStatusCode()最终实现函数"></a>ReportStatusCode()最终实现函数</h2><blockquote><p>ReportStatusCode()最终的实现函数是StatusCodeCommon.c中的AmiReportStatusCode()函数。AmiReportStatusCode()主要由三种ReportStatusCode()的方式，分别是SimpleStatusReport()、StringStatusReport()、MiscStatusReport()。另加一个错误处理，PerformErrorCodeAction()。StatusCode是通过Elink方式来进行实际操作的，因此具有很强的扩展性。</p></blockquote></li></ul><pre><code> /**    Top level status code reporting routine exposed by the status code protocol/PPI.    Calls the various types of status code handlers    (SimpleStatusReport, StringStatusReport, MiscStatusReport, PerformErrorCodeAction)    Generates string from the status code data to pass to StringStatusReport function.    @param PeiServices pointer to the PEI Boot Services table    @param Type the type and severity of the error that occurred    @param Value the Class, subclass and Operation that caused the error    @param Instance     @param CallerId OPTIONAL - The GUID of the caller function    @param Data OPTIONAL - the extended data field that contains additional info    @retval EFI_STATUS**/EFI_STATUS AmiReportStatusCode (    IN VOID *PeiServices,    IN EFI_STATUS_CODE_TYPE Type, IN EFI_STATUS_CODE_VALUE Value,    IN UINT32 Instance, IN  EFI_GUID *CallerId OPTIONAL,    IN EFI_STATUS_CODE_DATA *Data OPTIONAL, UINT8 *String)&#123;    SimpleStatusReport(PeiServices,Type,Value);//#if STRING_STATUS_SUPPORT    String[0] = &#39;\0&#39;;    CreateString(Type, Value, Data, String);    // step through the useable data and display information as needed    // Serial data    if (String[0] != &#39;\0&#39;) StringStatusReport(PeiServices,(CHAR8*)String);//#endif    MiscStatusReport(PeiServices,Type,Value,Instance,CallerId,Data);    if (STATUS_CODE_TYPE(Type)==EFI_ERROR_CODE)    PerformErrorCodeAction(PeiServices,Type,Value);    return EFI_SUCCESS;&#125;</code></pre><h2 id="SimpleStatusReport"><a href="#SimpleStatusReport" class="headerlink" title="SimpleStatusReport()"></a>SimpleStatusReport()</h2><blockquote><p>SimpleStatusReport()即简单状态报告，它只能报告StatusCode的类型和值，报告简单状态的方式分为两大种，1）Checkpoint，通过80 port报告状态码。2）Beep，通过蜂鸣器报告状态码。SimpleStatusCode存在一个StatusCodeMap，它列出所有简单状态码，包括Checkpoint与Beep，可以查看StatusCodeMap.c。</p></blockquote><ul><li>PeiReportSimpleStatus</li><li>DxeReportSimpleStatus</li><li>RtReportSimpleStatus</li><li>SmmReportSimpleStatus</li></ul><h2 id="StringStatusReport"><a href="#StringStatusReport" class="headerlink" title="StringStatusReport()"></a>StringStatusReport()</h2><blockquote><p>StringStatusReport()即字符串状态报告，串口丢出的字符串调试信息就是通过这个函数丢出的，Debug相关的丢字符串的函数也是通过这个函数丢出的。<br>这里我们需要注意的是：在我们通过Debug函数丢字符串信息时，Debug函数会使用EFI_STATUS_CODE_STRING_DATA结构对字符串进行打包处理。这也是我们使用一些自定义的丢字符串函数不能丢出的原因。</p></blockquote><ul><li>PeiReportStringStatus</li><li>DxeReportStringStatus</li><li>RtReportStringStatus</li><li>SmmReportStringStatus</li></ul><h2 id="MiscStatusReport"><a href="#MiscStatusReport" class="headerlink" title="MiscStatusReport()"></a>MiscStatusReport()</h2><blockquote><p>MiscStatusReport()即混合状态码，它包含ReportStatusCode()的全部5个参数，因此可以报告最详细的状态。当前DXE阶段使用它保存完整StatusCode信息到DataHub结构中。</p></blockquote><ul><li>PeiReportMiscStatus</li><li>DxeReportMiscStatus</li><li>RtReportMiscStatus</li><li>SmmReportMiscStatus</li></ul><h2 id="PerformErrorCodeAction"><a href="#PerformErrorCodeAction" class="headerlink" title="PerformErrorCodeAction()"></a>PerformErrorCodeAction()</h2><blockquote><p>PerformErrorCodeAction()即执行错误码动作，它包含ReportStatusCode()参数的类型和值，根据错误类型和值执行相应错误处理动作。</p></blockquote><ul><li>PeiErrorCodeActions</li><li>RtErrorCodeActions</li><li>SmmErrorCodeActions</li><li>DxeErrorCodeActions</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows Firmware Update Guide</title>
      <link href="2021/08/01/WFU/"/>
      <url>2021/08/01/WFU/</url>
      
        <content type="html"><![CDATA[<h1 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h1><ul><li>CometLake 7C43 Project:M80T MB with UEFI Windows 10 System .</li></ul><p>- Product: Aptio 5.x.</p><h1 id="Test-Objective"><a href="#Test-Objective" class="headerlink" title="Test Objective:"></a>Test Objective:</h1><ul><li>Confirm that Firmware can be updated using Windows architecture.</li></ul><h1 id="Test-Procedures"><a href="#Test-Procedures" class="headerlink" title="Test Procedures:"></a>Test Procedures:</h1><ul><li>System With SDK and WINDDK Installed</li></ul><blockquote><p>下载并安装最新WDK和SDK到测试机</p></blockquote><p>WDK：该驱动程序开发工具包（WDK）是从软件工具集微软，使开发设备驱动程序针对微软的Windows平台。它包括用于驱动程序开发人员的文档，样本，构建环境和工具。用于驱动程序开发的完整工具集还需要以下内容：编译器Visual Studio，Windows SDK和Windows HLK。</p><p>SDK：Microsoft Windows SDK及其先前的Platform SDK和.NET Framework SDK是Microsoft的软件开发工具包（SDK），其中包含开发Microsoft Windows和.NET Framework应用程序所需的文档，头文件，库，示例和工具。Platform SDK专门开发用于Windows 2000，XP和Windows Server 2003的应用程序。.NET Framework SDK专门用于开发用于 .NET Framework 1.1和.NET Framework 2.0。Windows SDK是这两者的继承者，并支持为Windows XP和更高版本以及.NET Framework 3.0和更高版本开发应用程序。</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369144037.png"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369151637.png"></p><ul><li>Create a folder C:\WFU and place *.inf and <em>.cap file in it(</em>.cap file built from project source)</li></ul><blockquote><p>*.inf文件示例如下，具体参考微软官网INF相关说明</p></blockquote><pre><code>[Version]Signature   = &quot;$WINDOWS NT$&quot;Provider    = %Provider%Class       = FirmwareClassGuid   = &#123;f2e7dd72-6468-4e36-b6f1-6488f42c1b52&#125;DriverVer   = 07/28/2020,1.0.0.43CatalogFile = M2TKT2CA.catPnpLockdown = 1[Manufacturer]%MfgName% = Firmware,NTamd64[Firmware.NTamd64]%FirmwareDesc% = Firmware_Install,UEFI\RES_&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;[Firmware_Install.NT]CopyFiles = Firmware_CopyFiles[Firmware_CopyFiles]M2TKT2CA.cap[Firmware_Install.NT.Hw]AddReg = Firmware_AddReg[Firmware_AddReg]HKR,,FirmwareId,,&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;HKR,,FirmwareVersion,%REG_DWORD%,0x0001002CHKR,,FirmwareFilename,,&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;\M2TKT2CA.cap[SourceDisksNames]1 = %DiskName%[SourceDisksFiles]M2TKT2CA.cap = 1[DestinationDirs]DefaultDestDir = %DIRID_WINDOWS%,Firmware\&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;[Strings]; localizableProvider     = &quot;Lenovo Ltd.&quot;MfgName      = &quot;Lenovo Ltd.&quot;FirmwareDesc = &quot;ThinkCentre M90t/s, M80t/s, M70t/s, M993t, M930t/s, M737t, QT M630, YT P780 System Firmware 1.0.0.43&quot;DiskName     = &quot;Firmware Update&quot;; non-localizableDIRID_WINDOWS = 10REG_DWORD     = 0x00010001</code></pre><ul><li><p>Change related cap and cat file name  in *.inf file, make these match the prefix of your cap file name, example M2TKT2CA.cat  and M2TKT2CA.cap （如下图2、4、8、9处）<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369166799.png"></p></li><li><p>将M2TKT2CA.inf文件的GUID替换为BIOS Source Code里对应的需要更新Firmware GUID（如上图3、5、7、10处）<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369174098.png"></p></li><li><p>Edit M2TKT2CA.inf file, find string “DriverVer=07/10/2020,1.0.0.42” and increase last two digits to 43, must increment for each flash（如上图1、11处）</p></li><li><p>Edit M2TKT2CA.inf, find string “HKR,,FirmwareVersion,%REG_DWORD%,0x0001002B and increase to 0x0001002C”， must increment for each flash.（如上图6处）<br>(Note: 0x2C is hex values of BIOS version, ex: BIOS version is 043, the hex values is 0x2C)</p></li><li><p>以管理员身份运行PowerShell，切换目录到C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x86</p></li><li><p>Run .\makecert.exe -r -pe -a sha256 -eku 1.3.6.1.5.5.7.3.3 -n CN=Foo -sv fwu.pvk fwu.cer</p></li><li><p>Password window will appear, set and verify this password: wfutest123<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370942326.png"></p></li></ul><ul><li><p>In powershell run .\pvk2pfx.exe -pvk fwu.pvk -spc fwu.cer -pi wfutest123 -spc fwu.cer -pfx fwu.pfx</p></li><li><p>If a .cat with your BIOS name, example m2tkt2ca.cat exists in the Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x86 folder delete it.</p></li><li><p>In powershell run .\Inf2Cat.exe /driver:c:\WFU /os:10_x64</p></li><li><p>In powershell run .\signtool sign /fd sha256 /f fwu.pfx /p wfutest123 C:\WFU\M2TKT2CA.cat</p></li><li><p>In powershell run .\fwu.cer<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370915317.png"></p></li></ul><ul><li><p>A Window should be displayed. Install certificate, local machine, next, browse, select Trusted Root Certification Authorities<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370903085.png"></p></li><li><p>In powershell run bcdedit.exe /set testsigning on</p></li><li><p>Right click My computer -&gt; Manage -&gt; Device Manager -&gt; Firmware -&gt; Update Driver Software -&gt; Browse -&gt; Let me Pick -&gt; Hard Disk -&gt; Select inf -&gt; restart<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370891225.png"></p></li></ul><ul><li>Firmware update should complete without errors.</li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370868293.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370603974.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> WFU,cab,证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ventoy</title>
      <link href="2021/08/01/Ventoy/"/>
      <url>2021/08/01/Ventoy/</url>
      
        <content type="html"><![CDATA[<h1 id="Ventoy简介"><a href="#Ventoy简介" class="headerlink" title="Ventoy简介"></a>Ventoy简介</h1><p> Ventoy是一个制作可启动U盘的开源工具。有了Ventoy你就无需反复地格式化U盘，你只需要把ISO文件拷贝到U盘里面就可以启动了，无需其他操作。 你可以一次性拷贝很多个不同类型的ISO文件，在启动时Ventoy会显示一个菜单来选择(<a href="https://www.ventoy.net/cn/screenshot.html">截图</a>)。 无差异支持Legacy BIOS和UEFI模式。目前已经测试了各类超过260+ 个ISO文件(<a href="https://www.ventoy.net/cn/isolist.html">列表</a>). 同时提出了”Ventoy Compatible”的概念，若被支持则理论上可以启动任何ISO文件.</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><ul><li><p><a href="https://github.com/ventoy/Ventoy">Github开源地址</a></p><ul><li> <a href="https://www.ventoy.net/cn/download.html">下载地址</a></li></ul></li><li><p> 安装到启动盘</p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967090645.png" alt="安装到U盘"></p><h1 id="放置ISO镜像文件"><a href="#放置ISO镜像文件" class="headerlink" title="放置ISO镜像文件"></a>放置ISO镜像文件</h1><h2 id="镜像下载站点"><a href="#镜像下载站点" class="headerlink" title="镜像下载站点"></a>镜像下载站点</h2><ul><li>  <a href="https://next.itellyou.cn/">MSDN</a></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531519.png"></p><ul><li>  <a href="https://developer.aliyun.com/mirror/">阿里云镜像站</a></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531520.png"></p><h2 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h2><blockquote><p>镜像可放在根目录，也可建立文件夹管理，可按需求分类</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967174941.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967207747.png"></p><h1 id="配置json文件和主题（可忽略）"><a href="#配置json文件和主题（可忽略）" class="headerlink" title="配置json文件和主题（可忽略）"></a>配置json文件和主题（可忽略）</h1><ul><li><p>  <a href="https://www.ventoy.net/cn/plugin_entry.html">官方教程</a></p></li><li><p>  个人示例</p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967274942.png"></p><ul><li>ventoy.json<pre><code>&#123;   &quot;theme&quot;: &#123;      &quot;file&quot;: &quot;/ventoy/theme/theme.txt&quot;,      &quot;gfxmode&quot;: &quot;1024x768&quot;,      &quot;ventoy_left&quot;: &quot;42%&quot;,      &quot;ventoy_top&quot;: &quot;100%&quot;,      &quot;ventoy_color&quot;: &quot;#000000&quot;  &#125; ,&quot;menu_alias&quot; :   [      &#123;          &quot;image&quot;: &quot;/ISO/18363.418.191007-0143.19h2_release_svc_refresh_CLIENT_CONSUMER_x64FRE_en-us.iso&quot;,          &quot;alias&quot;: &quot;Win10 19H2英文版&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/19041.208.200420-2019.vb_release_svc_refresh_CLIENT_BUSINESS_VOL_x64FRE_en-us.iso&quot;,          &quot;alias&quot;: &quot;Win10 20H1英文版&quot;      &#125;,              &#123;          &quot;image&quot;: &quot;/ISO/cn_windows_10_business_editions_version_1909_updated_jan_2020_x64_dvd_b3e1f3a6.iso&quot;,          &quot;alias&quot;: &quot;Win10 1909中文版&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/rhel-8.1-x86_64-dvd.iso&quot;,          &quot;alias&quot;: &quot;ReaHat 8.1&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/ubuntu-18.04.3-desktop-amd64.iso&quot;,          &quot;alias&quot;: &quot;Ubuntu 18.04.03&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/ubuntu-20.04-desktop-amd64.iso&quot;,          &quot;alias&quot;: &quot;Ubuntu 20.04&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/wepe_64.iso&quot;,          &quot;alias&quot;: &quot;微PE&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/EasyU_v3.3.iso&quot;,          &quot;alias&quot;: &quot;优启通PE&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/19H2_Bak.wim&quot;,          &quot;alias&quot;: &quot;Win10 19H2英文系统备份&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/1909_Zh_Cn_Backup.wim&quot;,          &quot;alias&quot;: &quot;Win10 19H2中文系统备份&quot;      &#125;,      &#123;          &quot;image&quot;: &quot;/ISO/en_windows_server_2016_x64_dvd_9718492.iso&quot;,          &quot;alias&quot;: &quot;Win10 Server 2016&quot;      &#125;                  ]     &#125;</code></pre></li><li>  <a href="https://www.gnome-look.org/p/1009236/">主题地址</a></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531602.png"></p><h1 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h1><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531607.png"></p><blockquote><p>通过主板快捷键可以从制作的VentoyU盘启动，选择可启动镜像即可进入OS安装或PE等维护工具</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HOB</title>
      <link href="2021/08/01/HOB/"/>
      <url>2021/08/01/HOB/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="HOB简介"><a href="#HOB简介" class="headerlink" title="HOB简介"></a>HOB简介</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>HOB是Hand-Off Block的缩写。是PEI阶段向DXE传递系统信息的手段。PEI阶段构建一些HOB结构，然后将其作为参数传给DXE阶段函数，DXE Core会根据其使用平台相关资源。</p><p>HOB是系列的连续的内存结构体，可以认为其由三部分构成：第一部分，是PHIT头，它描述了HOB的起始地址以及总的内存使用；第二部分是各个Hob列表，DXE阶段会根据这一部分获取相关资源；第三部分是结束部分。</p><hr><p>   <img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603960797897.png"></p><p>  <img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603960797878.png" alt="HOB List"></p><hr><h2 id="相关Spec"><a href="#相关Spec" class="headerlink" title="相关Spec"></a>相关Spec</h2><ul><li>PI Spec(卷一 4.4 HOB Services小节，规范HOB PeiService相关的方法,Pi卷三4/5章节)</li><li><a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/unified-extensible-firmware-interface/efi-specifications-general-technology.html">EFI Spec</a>（规范HOB的数据结构）</li></ul><h1 id="HOB的数据结构表征-PiHob-h"><a href="#HOB的数据结构表征-PiHob-h" class="headerlink" title="HOB的数据结构表征(PiHob.h)"></a>HOB的数据结构表征(PiHob.h)</h1><h2 id="EFI-HOB-GENERIC-HEADER"><a href="#EFI-HOB-GENERIC-HEADER" class="headerlink" title="EFI_HOB_GENERIC_HEADER"></a>EFI_HOB_GENERIC_HEADER</h2><blockquote><p>描述HOB内部数据的格式和大小,所有HOB都必须包含此通用HOB标头,以便可以找到下一个HOB</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">////// Describes the format and size of the data inside the HOB./// All HOBs must contain this generic HOB header.///typedef struct &#123;  ///  /// Identifies the HOB data structure type.  ///  UINT16    HobType;  ///  /// The length in bytes of the HOB.  ///  UINT16    HobLength;  ///  /// This field must always be set to zero.  ///  UINT32    Reserved;&#125; EFI_HOB_GENERIC_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HobType"><a href="#HobType" class="headerlink" title="HobType"></a>HobType</h2><pre class="line-numbers language-c++"><code class="language-c++">//// HobType of EFI_HOB_GENERIC_HEADER.//#define EFI_HOB_TYPE_HANDOFF              0x0001#define EFI_HOB_TYPE_MEMORY_ALLOCATION    0x0002#define EFI_HOB_TYPE_RESOURCE_DESCRIPTOR  0x0003#define EFI_HOB_TYPE_GUID_EXTENSION       0x0004#define EFI_HOB_TYPE_FV                   0x0005#define EFI_HOB_TYPE_CPU                  0x0006#define EFI_HOB_TYPE_MEMORY_POOL          0x0007#define EFI_HOB_TYPE_FV2                  0x0009#define EFI_HOB_TYPE_LOAD_PEIM_UNUSED     0x000A#define EFI_HOB_TYPE_UEFI_CAPSULE         0x000B#define EFI_HOB_TYPE_FV3                  0x000C#define EFI_HOB_TYPE_UNUSED               0xFFFE#define EFI_HOB_TYPE_END_OF_HOB_LIST      0xFFFF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="PHIT-HOB"><a href="#PHIT-HOB" class="headerlink" title="PHIT HOB"></a>PHIT HOB</h2><pre><code>////// Contains general state information used by the HOB producer phase./// This HOB must be the first one in the HOB list.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_HANDOFF.  ///  EFI_HOB_GENERIC_HEADER  Header;  ///  /// The version number pertaining to the PHIT HOB definition.  /// This value is four bytes in length to provide an 8-byte aligned entry  /// when it is combined with the 4-byte BootMode.  ///  UINT32                  Version;  ///  /// The system boot mode as determined during the HOB producer phase.  ///  EFI_BOOT_MODE           BootMode;  ///  /// The highest address location of memory that is allocated for use by the HOB producer  /// phase. This address must be 4-KB aligned to meet page restrictions of UEFI.  ///  EFI_PHYSICAL_ADDRESS    EfiMemoryTop;  ///  /// The lowest address location of memory that is allocated for use by the HOB producer phase.  ///  EFI_PHYSICAL_ADDRESS    EfiMemoryBottom;  ///  /// The highest address location of free memory that is currently available  /// for use by the HOB producer phase.  ///  EFI_PHYSICAL_ADDRESS    EfiFreeMemoryTop;  ///  /// The lowest address location of free memory that is available for use by the HOB producer phase.  ///  EFI_PHYSICAL_ADDRESS    EfiFreeMemoryBottom;  ///  /// The end of the HOB list.  ///  EFI_PHYSICAL_ADDRESS    EfiEndOfHobList;&#125; EFI_HOB_HANDOFF_INFO_TABLE;</code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-HEADER"><a href="#EFI-HOB-MEMORY-ALLOCATION-HEADER" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_HEADER"></a>EFI_HOB_MEMORY_ALLOCATION_HEADER</h2><pre class="line-numbers language-C"><code class="language-C">////// EFI_HOB_MEMORY_ALLOCATION_HEADER describes the/// various attributes of the logical memory allocation. The type field will be used for/// subsequent inclusion in the UEFI memory map.///typedef struct &#123;  ///  /// A GUID that defines the memory allocation region's type and purpose, as well as  /// other fields within the memory allocation HOB. This GUID is used to define the  /// additional data within the HOB that may be present for the memory allocation HOB.  /// Type EFI_GUID is defined in InstallProtocolInterface() in the UEFI 2.0  /// specification.  ///  EFI_GUID              Name;  ///  /// The base address of memory allocated by this HOB. Type  /// EFI_PHYSICAL_ADDRESS is defined in AllocatePages() in the UEFI 2.0  /// specification.  ///  EFI_PHYSICAL_ADDRESS  MemoryBaseAddress;  ///  /// The length in bytes of memory allocated by this HOB.  ///  UINT64                MemoryLength;  ///  /// Defines the type of memory allocated by this HOB. The memory type definition  /// follows the EFI_MEMORY_TYPE definition. Type EFI_MEMORY_TYPE is defined  /// in AllocatePages() in the UEFI 2.0 specification.  ///  EFI_MEMORY_TYPE       MemoryType;  ///  /// Padding for Itanium processor family  ///  UINT8                 Reserved[4];&#125; EFI_HOB_MEMORY_ALLOCATION_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION"><a href="#EFI-HOB-MEMORY-ALLOCATION" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION"></a>EFI_HOB_MEMORY_ALLOCATION</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Describes all memory ranges used during the HOB producer</span><span class="token comment" spellcheck="true">/// phase that exist outside the HOB list. This HOB type</span><span class="token comment" spellcheck="true">/// describes how memory is used, not the physical attributes of memory.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER            Header<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the</span>  <span class="token comment" spellcheck="true">/// various attributes of the logical memory allocation.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//</span>  <span class="token comment" spellcheck="true">// Additional data pertaining to the "Name" Guid memory</span>  <span class="token comment" spellcheck="true">// may go here.</span>  <span class="token comment" spellcheck="true">//</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_MEMORY_ALLOCATION<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-STACK"><a href="#EFI-HOB-MEMORY-ALLOCATION-STACK" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_STACK"></a>EFI_HOB_MEMORY_ALLOCATION_STACK</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Describes the memory stack that is produced by the HOB producer</span><span class="token comment" spellcheck="true">/// phase and upon which all post-memory-installed executable</span><span class="token comment" spellcheck="true">/// content in the HOB producer phase is executing.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER            Header<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the</span>  <span class="token comment" spellcheck="true">/// various attributes of the logical memory allocation.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_MEMORY_ALLOCATION_STACK<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-BSP-STORE"><a href="#EFI-HOB-MEMORY-ALLOCATION-BSP-STORE" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_BSP_STORE"></a>EFI_HOB_MEMORY_ALLOCATION_BSP_STORE</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Defines the location of the boot-strap</span><span class="token comment" spellcheck="true">/// processor (BSP) BSPStore ("Backing Store Pointer Store").</span><span class="token comment" spellcheck="true">/// This HOB is valid for the Itanium processor family only</span><span class="token comment" spellcheck="true">/// register overflow store.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER            Header<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the</span>  <span class="token comment" spellcheck="true">/// various attributes of the logical memory allocation.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_MEMORY_ALLOCATION_BSP_STORE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-MODULE"><a href="#EFI-HOB-MEMORY-ALLOCATION-MODULE" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_MODULE"></a>EFI_HOB_MEMORY_ALLOCATION_MODULE</h2><pre><code>////// Defines the location and entry point of the HOB consumer phase.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.  ///  EFI_HOB_GENERIC_HEADER            Header;  ///  /// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the  /// various attributes of the logical memory allocation.  ///  EFI_HOB_MEMORY_ALLOCATION_HEADER  MemoryAllocationHeader;  ///  /// The GUID specifying the values of the firmware file system name  /// that contains the HOB consumer phase component.  ///  EFI_GUID                          ModuleName;  ///  /// The address of the memory-mapped firmware volume  /// that contains the HOB consumer phase firmware file.  ///  EFI_PHYSICAL_ADDRESS              EntryPoint;&#125; EFI_HOB_MEMORY_ALLOCATION_MODULE;</code></pre><h2 id="EFI-HOB-RESOURCE-DESCRIPTOR"><a href="#EFI-HOB-RESOURCE-DESCRIPTOR" class="headerlink" title="EFI_HOB_RESOURCE_DESCRIPTOR"></a>EFI_HOB_RESOURCE_DESCRIPTOR</h2><pre><code>////// Describes the resource properties of all fixed,/// nonrelocatable resource ranges found on the processor/// host bus during the HOB producer phase.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_RESOURCE_DESCRIPTOR.  ///  EFI_HOB_GENERIC_HEADER      Header;  ///  /// A GUID representing the owner of the resource. This GUID is used by HOB  /// consumer phase components to correlate device ownership of a resource.  ///  EFI_GUID                    Owner;  ///  /// The resource type enumeration as defined by EFI_RESOURCE_TYPE.  ///  EFI_RESOURCE_TYPE           ResourceType;  ///  /// Resource attributes as defined by EFI_RESOURCE_ATTRIBUTE_TYPE.  ///  EFI_RESOURCE_ATTRIBUTE_TYPE ResourceAttribute;  ///  /// The physical start address of the resource region.  ///  EFI_PHYSICAL_ADDRESS        PhysicalStart;  ///  /// The number of bytes of the resource region.  ///  UINT64                      ResourceLength;&#125; EFI_HOB_RESOURCE_DESCRIPTOR;</code></pre><h2 id="EFI-HOB-GUID-TYPE"><a href="#EFI-HOB-GUID-TYPE" class="headerlink" title="EFI_HOB_GUID_TYPE"></a>EFI_HOB_GUID_TYPE</h2><pre><code>////// Allows writers of executable content in the HOB producer phase to/// maintain and manage HOBs with specific GUID.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_GUID_EXTENSION.  ///  EFI_HOB_GENERIC_HEADER      Header;  ///  /// A GUID that defines the contents of this HOB.  ///  EFI_GUID                    Name;  //  // Guid specific data goes here  //&#125; EFI_HOB_GUID_TYPE;</code></pre><h2 id="EFI-HOB-FIRMWARE-VOLUME"><a href="#EFI-HOB-FIRMWARE-VOLUME" class="headerlink" title="EFI_HOB_FIRMWARE_VOLUME"></a>EFI_HOB_FIRMWARE_VOLUME</h2><pre><code>////// Details the location of firmware volumes that contain firmware files.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV.  ///  EFI_HOB_GENERIC_HEADER Header;  ///  /// The physical memory-mapped base address of the firmware volume.  ///  EFI_PHYSICAL_ADDRESS   BaseAddress;  ///  /// The length in bytes of the firmware volume.  ///  UINT64                 Length;&#125; EFI_HOB_FIRMWARE_VOLUME;</code></pre><h2 id="EFI-HOB-FIRMWARE-VOLUME2"><a href="#EFI-HOB-FIRMWARE-VOLUME2" class="headerlink" title="EFI_HOB_FIRMWARE_VOLUME2"></a>EFI_HOB_FIRMWARE_VOLUME2</h2><pre><code>////// Details the location of a firmware volume that was extracted/// from a file within another firmware volume.///typedef struct &#123;  ///  /// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV2.  ///  EFI_HOB_GENERIC_HEADER  Header;  ///  /// The physical memory-mapped base address of the firmware volume.  ///  EFI_PHYSICAL_ADDRESS    BaseAddress;  ///  /// The length in bytes of the firmware volume.  ///  UINT64                  Length;  ///  /// The name of the firmware volume.  ///  EFI_GUID                FvName;  ///  /// The name of the firmware file that contained this firmware volume.  ///  EFI_GUID                FileName;&#125; EFI_HOB_FIRMWARE_VOLUME2;</code></pre><h2 id="EFI-HOB-FIRMWARE-VOLUME3"><a href="#EFI-HOB-FIRMWARE-VOLUME3" class="headerlink" title="EFI_HOB_FIRMWARE_VOLUME3"></a>EFI_HOB_FIRMWARE_VOLUME3</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Details the location of a firmware volume that was extracted</span><span class="token comment" spellcheck="true">/// from a file within another firmware volume.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV3.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER  Header<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The physical memory-mapped base address of the firmware volume.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_PHYSICAL_ADDRESS    BaseAddress<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The length in bytes of the firmware volume.</span>  <span class="token comment" spellcheck="true">///</span>  UINT64                  Length<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The authentication status.</span>  <span class="token comment" spellcheck="true">///</span>  UINT32                  AuthenticationStatus<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// TRUE if the FV was extracted as a file within another firmware volume.</span>  <span class="token comment" spellcheck="true">/// FALSE otherwise.</span>  <span class="token comment" spellcheck="true">///</span>  BOOLEAN                 ExtractedFv<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The name of the firmware volume.</span>  <span class="token comment" spellcheck="true">/// Valid only if IsExtractedFv is TRUE.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_GUID                FvName<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The name of the firmware file that contained this firmware volume.</span>  <span class="token comment" spellcheck="true">/// Valid only if IsExtractedFv is TRUE.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_GUID                FileName<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_FIRMWARE_VOLUME3<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-CPU"><a href="#EFI-HOB-CPU" class="headerlink" title="EFI_HOB_CPU"></a>EFI_HOB_CPU</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Describes processor information, such as address space and I/O space capabilities.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_CPU.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER  Header<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// Identifies the maximum physical memory addressability of the processor.</span>  <span class="token comment" spellcheck="true">///</span>  UINT8                   SizeOfMemorySpace<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// Identifies the maximum physical I/O addressability of the processor.</span>  <span class="token comment" spellcheck="true">///</span>  UINT8                   SizeOfIoSpace<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// This field will always be set to zero.</span>  <span class="token comment" spellcheck="true">///</span>  UINT8                   Reserved<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_CPU<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-POOL"><a href="#EFI-HOB-MEMORY-POOL" class="headerlink" title="EFI_HOB_MEMORY_POOL"></a>EFI_HOB_MEMORY_POOL</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Describes pool memory allocations.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">///</span>  <span class="token comment" spellcheck="true">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_POOL.</span>  <span class="token comment" spellcheck="true">///</span>  EFI_HOB_GENERIC_HEADER  Header<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_HOB_MEMORY_POOL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-UEFI-CAPSULE"><a href="#EFI-HOB-UEFI-CAPSULE" class="headerlink" title="EFI_HOB_UEFI_CAPSULE"></a>EFI_HOB_UEFI_CAPSULE</h2><pre class="line-numbers language-c///"><code class="language-c///">/// Each UEFI capsule HOB details the location of a UEFI capsule. It includes a base address and length/// which is based upon memory blocks with a EFI_CAPSULE_HEADER and the associated/// CapsuleImageSize-based payloads. These HOB's shall be created by the PEI PI firmware/// sometime after the UEFI UpdateCapsule service invocation with the/// CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE flag set in the EFI_CAPSULE_HEADER.///typedef struct &#123;  ///  /// The HOB generic header where Header.HobType = EFI_HOB_TYPE_UEFI_CAPSULE.  ///  EFI_HOB_GENERIC_HEADER Header;  ///  /// The physical memory-mapped base address of an UEFI capsule. This value is set to  /// point to the base of the contiguous memory of the UEFI capsule.  /// The length of the contiguous memory in bytes.  ///  EFI_PHYSICAL_ADDRESS   BaseAddress;  UINT64                 Length;&#125; EFI_HOB_UEFI_CAPSULE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-PEI-HOB-POINTERS"><a href="#EFI-PEI-HOB-POINTERS" class="headerlink" title="EFI_PEI_HOB_POINTERS"></a>EFI_PEI_HOB_POINTERS</h2><blockquote><p>使用union最大的好处是提高源码的可读性和间接性。利用该类型中所有域的取值均一样的特点，在不同的使用方法下，可以使用不同的变量名字，一方面可以省去强制类型转换的麻烦，另一方面可以直接体现出当前的使用需求。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">///</span><span class="token comment" spellcheck="true">/// Union of all the possible HOB Types.</span><span class="token comment" spellcheck="true">///</span><span class="token keyword">typedef</span> <span class="token keyword">union</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  EFI_HOB_GENERIC_HEADER              <span class="token operator">*</span>Header<span class="token punctuation">;</span>  EFI_HOB_HANDOFF_INFO_TABLE          <span class="token operator">*</span>HandoffInformationTable<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION           <span class="token operator">*</span>MemoryAllocation<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION_BSP_STORE <span class="token operator">*</span>MemoryAllocationBspStore<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION_STACK     <span class="token operator">*</span>MemoryAllocationStack<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION_MODULE    <span class="token operator">*</span>MemoryAllocationModule<span class="token punctuation">;</span>  EFI_HOB_RESOURCE_DESCRIPTOR         <span class="token operator">*</span>ResourceDescriptor<span class="token punctuation">;</span>  EFI_HOB_GUID_TYPE                   <span class="token operator">*</span>Guid<span class="token punctuation">;</span>  EFI_HOB_FIRMWARE_VOLUME             <span class="token operator">*</span>FirmwareVolume<span class="token punctuation">;</span>  EFI_HOB_FIRMWARE_VOLUME2            <span class="token operator">*</span>FirmwareVolume2<span class="token punctuation">;</span>  EFI_HOB_FIRMWARE_VOLUME3            <span class="token operator">*</span>FirmwareVolume3<span class="token punctuation">;</span>  EFI_HOB_CPU                         <span class="token operator">*</span>Cpu<span class="token punctuation">;</span>  EFI_HOB_MEMORY_POOL                 <span class="token operator">*</span>Pool<span class="token punctuation">;</span>  EFI_HOB_UEFI_CAPSULE                <span class="token operator">*</span>Capsule<span class="token punctuation">;</span>  UINT8                               <span class="token operator">*</span>Raw<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> EFI_PEI_HOB_POINTERS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="HOB相关方法的声明（HobLib-h）"><a href="#HOB相关方法的声明（HobLib-h）" class="headerlink" title="HOB相关方法的声明（HobLib.h）"></a>HOB相关方法的声明（HobLib.h）</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><ul><li>BuildModuleHob</li><li>BuildResourceDescriptorWithOwnerHob</li><li>BuildResourceDescriptorHob</li><li>BuildGuidHob</li><li>BuildGuidDataHob</li><li>BuildFvHob</li><li>BuildFv2Hob</li><li>BuildFv3Hob</li><li>BuildCvHob</li><li>BuildCpuHob</li><li>BuildStackHob</li><li>BuildBspStoreHob</li><li>BuildMemoryAllocationHob</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**  Builds a HOB for a loaded PE32 module.  This function builds a HOB for a loaded PE32 module.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If ModuleName is NULL, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  @param  ModuleName              The GUID File Name of the module.  @param  MemoryAllocationModule  The 64 bit physical address of the module.  @param  ModuleLength            The length of the module in bytes.  @param  EntryPoint              The 64 bit physical address of the module entry point.**/</span>VOIDEFIAPI<span class="token function">BuildModuleHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID         <span class="token operator">*</span>ModuleName<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS   MemoryAllocationModule<span class="token punctuation">,</span>  IN UINT64                 ModuleLength<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS   EntryPoint  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB that describes a chunk of system memory with Owner GUID.  This function builds a HOB that describes a chunk of system memory.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  ResourceType        The type of resource described by this HOB.  @param  ResourceAttribute   The resource attributes of the memory described by this HOB.  @param  PhysicalStart       The 64 bit physical address of memory described by this HOB.  @param  NumberOfBytes       The length of the memory described by this HOB in bytes.  @param  OwnerGUID           GUID for the owner of this resource.**/</span>VOIDEFIAPI<span class="token function">BuildResourceDescriptorWithOwnerHob</span> <span class="token punctuation">(</span>  IN EFI_RESOURCE_TYPE            ResourceType<span class="token punctuation">,</span>  IN EFI_RESOURCE_ATTRIBUTE_TYPE  ResourceAttribute<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS         PhysicalStart<span class="token punctuation">,</span>  IN UINT64                       NumberOfBytes<span class="token punctuation">,</span>  IN EFI_GUID                     <span class="token operator">*</span>OwnerGUID  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB that describes a chunk of system memory.  This function builds a HOB that describes a chunk of system memory.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  ResourceType        The type of resource described by this HOB.  @param  ResourceAttribute   The resource attributes of the memory described by this HOB.  @param  PhysicalStart       The 64 bit physical address of memory described by this HOB.  @param  NumberOfBytes       The length of the memory described by this HOB in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildResourceDescriptorHob</span> <span class="token punctuation">(</span>  IN EFI_RESOURCE_TYPE            ResourceType<span class="token punctuation">,</span>  IN EFI_RESOURCE_ATTRIBUTE_TYPE  ResourceAttribute<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS         PhysicalStart<span class="token punctuation">,</span>  IN UINT64                       NumberOfBytes  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a customized HOB tagged with a GUID for identification and returns  the start address of GUID HOB data.  This function builds a customized HOB tagged with a GUID for identification  and returns the start address of GUID HOB data so that caller can fill the customized data.  The HOB Header and Name field is already stripped.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If Guid is NULL, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  If DataLength > (0xFFF8 - sizeof (EFI_HOB_GUID_TYPE)), then ASSERT().  HobLength is UINT16 and multiples of 8 bytes, so the max HobLength is 0xFFF8.  @param  Guid          The GUID to tag the customized HOB.  @param  DataLength    The size of the data payload for the GUID HOB.  @retval  NULL         The GUID HOB could not be allocated.  @retval  others       The start address of GUID HOB data.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">BuildGuidHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID              <span class="token operator">*</span>Guid<span class="token punctuation">,</span>  IN UINTN                       DataLength  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a customized HOB tagged with a GUID for identification, copies the input data to the HOB  data field, and returns the start address of the GUID HOB data.  This function builds a customized HOB tagged with a GUID for identification and copies the input  data to the HOB data field and returns the start address of the GUID HOB data.  It can only be  invoked during PEI phase; for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  The HOB Header and Name field is already stripped.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If Guid is NULL, then ASSERT().  If Data is NULL and DataLength > 0, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  If DataLength > (0xFFF8 - sizeof (EFI_HOB_GUID_TYPE)), then ASSERT().  HobLength is UINT16 and multiples of 8 bytes, so the max HobLength is 0xFFF8.  @param  Guid          The GUID to tag the customized HOB.  @param  Data          The data to be copied into the data field of the GUID HOB.  @param  DataLength    The size of the data payload for the GUID HOB.  @retval  NULL         The GUID HOB could not be allocated.  @retval  others       The start address of GUID HOB data.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">BuildGuidDataHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID              <span class="token operator">*</span>Guid<span class="token punctuation">,</span>  IN VOID                        <span class="token operator">*</span>Data<span class="token punctuation">,</span>  IN UINTN                       DataLength  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a Firmware Volume HOB.  This function builds a Firmware Volume HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  If the FvImage buffer is not at its required alignment, then ASSERT().  @param  BaseAddress   The base address of the Firmware Volume.  @param  Length        The size of the Firmware Volume in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildFvHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a EFI_HOB_TYPE_FV2 HOB.  This function builds a EFI_HOB_TYPE_FV2 HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  If the FvImage buffer is not at its required alignment, then ASSERT().  @param  BaseAddress   The base address of the Firmware Volume.  @param  Length        The size of the Firmware Volume in bytes.  @param  FvName        The name of the Firmware Volume.  @param  FileName      The name of the file.**/</span>VOIDEFIAPI<span class="token function">BuildFv2Hob</span> <span class="token punctuation">(</span>  IN          EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN          UINT64                      Length<span class="token punctuation">,</span>  IN CONST    EFI_GUID                    <span class="token operator">*</span>FvName<span class="token punctuation">,</span>  IN CONST    EFI_GUID                    <span class="token operator">*</span>FileName  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a EFI_HOB_TYPE_FV3 HOB.  This function builds a EFI_HOB_TYPE_FV3 HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  If the FvImage buffer is not at its required alignment, then ASSERT().  @param BaseAddress            The base address of the Firmware Volume.  @param Length                 The size of the Firmware Volume in bytes.  @param AuthenticationStatus   The authentication status.  @param ExtractedFv            TRUE if the FV was extracted as a file within                                another firmware volume. FALSE otherwise.  @param FvName                 The name of the Firmware Volume.                                Valid only if IsExtractedFv is TRUE.  @param FileName               The name of the file.                                Valid only if IsExtractedFv is TRUE.**/</span>VOIDEFIAPI<span class="token function">BuildFv3Hob</span> <span class="token punctuation">(</span>  IN          EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN          UINT64                      Length<span class="token punctuation">,</span>  IN          UINT32                      AuthenticationStatus<span class="token punctuation">,</span>  IN          BOOLEAN                     ExtractedFv<span class="token punctuation">,</span>  IN CONST    EFI_GUID                    <span class="token operator">*</span>FvName<span class="token punctuation">,</span> OPTIONAL  IN CONST    EFI_GUID                    <span class="token operator">*</span>FileName OPTIONAL  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a Capsule Volume HOB.  This function builds a Capsule Volume HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If the platform does not support Capsule Volume HOBs, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The base address of the Capsule Volume.  @param  Length        The size of the Capsule Volume in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildCvHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB for the CPU.  This function builds a HOB for the CPU.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  SizeOfMemorySpace   The maximum physical memory addressability of the processor.  @param  SizeOfIoSpace       The maximum physical I/O addressability of the processor.**/</span>VOIDEFIAPI<span class="token function">BuildCpuHob</span> <span class="token punctuation">(</span>  IN UINT8                       SizeOfMemorySpace<span class="token punctuation">,</span>  IN UINT8                       SizeOfIoSpace  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB for the Stack.  This function builds a HOB for the stack.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The 64 bit physical address of the Stack.  @param  Length        The length of the stack in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildStackHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB for the BSP store.  This function builds a HOB for BSP store.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The 64 bit physical address of the BSP.  @param  Length        The length of the BSP store in bytes.  @param  MemoryType    Type of memory allocated by this HOB.**/</span>VOIDEFIAPI<span class="token function">BuildBspStoreHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length<span class="token punctuation">,</span>  IN EFI_MEMORY_TYPE             MemoryType  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Builds a HOB for the memory allocation.  This function builds a HOB for the memory allocation.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The 64 bit physical address of the memory.  @param  Length        The length of the memory allocation in bytes.  @param  MemoryType    Type of memory allocated by this HOB.**/</span>VOIDEFIAPI<span class="token function">BuildMemoryAllocationHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length<span class="token punctuation">,</span>  IN EFI_MEMORY_TYPE             MemoryType  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><blockquote><p>无此方法</p></blockquote><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><ul><li>GetHobList</li><li>GetNextHob</li><li>GetFirstHob</li><li>GetFirstGuidHob</li><li>GetNextGuidHob</li><li>GetBootModeHob</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**  Returns the pointer to the HOB list.  This function returns the pointer to first HOB in the list.  For PEI phase, the PEI service GetHobList() can be used to retrieve the pointer  to the HOB list.  For the DXE phase, the HOB list pointer can be retrieved through  the EFI System Table by looking up theHOB list GUID in the System Configuration Table.  Since the System Configuration Table does not exist that the time the DXE Core is  launched, the DXE Core uses a global variable from the DXE Core Entry Point Library  to manage the pointer to the HOB list.  If the pointer to the HOB list is NULL, then ASSERT().  @return The pointer to the HOB list.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetHobList</span> <span class="token punctuation">(</span>  VOID  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Returns the next instance of a HOB type from the starting HOB.  This function searches the first instance of a HOB type from the starting HOB pointer.  If there does not exist such HOB type from the starting HOB pointer, it will return NULL.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.  If HobStart is NULL, then ASSERT().  @param  Type          The HOB type to return.  @param  HobStart      The starting HOB pointer to search from.  @return The next instance of a HOB type from the starting HOB.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetNextHob</span> <span class="token punctuation">(</span>  IN UINT16                 Type<span class="token punctuation">,</span>  IN CONST VOID             <span class="token operator">*</span>HobStart  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Returns the first instance of a HOB type among the whole HOB list.  This function searches the first instance of a HOB type among the whole HOB list.  If there does not exist such HOB type in the HOB list, it will return NULL.  If the pointer to the HOB list is NULL, then ASSERT().  @param  Type          The HOB type to return.  @return The next instance of a HOB type from the starting HOB.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetFirstHob</span> <span class="token punctuation">(</span>  IN UINT16                 Type  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Returns the next instance of the matched GUID HOB from the starting HOB.  This function searches the first instance of a HOB from the starting HOB pointer.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size info respectively.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.  If Guid is NULL, then ASSERT().  If HobStart is NULL, then ASSERT().  @param  Guid          The GUID to match with in the HOB list.  @param  HobStart      A pointer to a Guid.  @return The next instance of the matched GUID HOB from the starting HOB.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetNextGuidHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID         <span class="token operator">*</span>Guid<span class="token punctuation">,</span>  IN CONST VOID             <span class="token operator">*</span>HobStart  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Returns the first instance of the matched GUID HOB among the whole HOB list.  This function searches the first instance of a HOB among the whole HOB list.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size info respectively.  If the pointer to the HOB list is NULL, then ASSERT().  If Guid is NULL, then ASSERT().  @param  Guid          The GUID to match with in the HOB list.  @return The first instance of the matched GUID HOB among the whole HOB list.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetFirstGuidHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID         <span class="token operator">*</span>Guid  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  Get the system boot mode from the HOB list.  This function returns the system boot mode information from the  PHIT HOB in HOB list.  If the pointer to the HOB list is NULL, then ASSERT().  @param  VOID  @return The Boot Mode.**/</span>EFI_BOOT_MODEEFIAPI<span class="token function">GetBootModeHob</span> <span class="token punctuation">(</span>  VOID  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><blockquote><p>未提供方法，一般是先找到感兴趣的Hob，再修改Block中的数据</p></blockquote><hr><h1 id="HOB相关接口的实现"><a href="#HOB相关接口的实现" class="headerlink" title="HOB相关接口的实现"></a>HOB相关接口的实现</h1><ul><li>HobLib.h </li><li>MdePkg\Library\PeiHobLib\HobLib.c </li><li>MdePkg\Library\DxeHobLib\HobLib.c </li><li>MdePkg\Library\DxeCoreHobLib\HobLib.c </li><li>IntelFrameworkPkg\Library\PeiHobLibFramework\HobLib.c </li></ul><h2 id="相关宏函数"><a href="#相关宏函数" class="headerlink" title="相关宏函数"></a>相关宏函数</h2><ul><li>GET_HOB_TYPE</li><li>GET_HOB_LENGTH</li><li>GET_NEXT_HOB</li><li>END_OF_HOB_LIST</li><li>GET_GUID_HOB_DATAET_GUID_HOB_DATA</li><li>GET_GUID_HOB_DATA_SIZE</li></ul><pre><code>/**  Returns the type of a HOB.  This macro returns the HobType field from the HOB header for the  HOB specified by HobStart.  @param  HobStart   A pointer to a HOB.  @return HobType.**/#define GET_HOB_TYPE(HobStart) \  ((*(EFI_HOB_GENERIC_HEADER **)&amp;(HobStart))-&gt;HobType)/**  Returns the length, in bytes, of a HOB.  This macro returns the HobLength field from the HOB header for the  HOB specified by HobStart.  @param  HobStart   A pointer to a HOB.  @return HobLength.**/#define GET_HOB_LENGTH(HobStart) \  ((*(EFI_HOB_GENERIC_HEADER **)&amp;(HobStart))-&gt;HobLength)/**  Returns a pointer to the next HOB in the HOB list.  This macro returns a pointer to HOB that follows the  HOB specified by HobStart in the HOB List.  @param  HobStart   A pointer to a HOB.  @return A pointer to the next HOB in the HOB list.**/#define GET_NEXT_HOB(HobStart) \  (VOID *)(*(UINT8 **)&amp;(HobStart) + GET_HOB_LENGTH (HobStart))/**  Determines if a HOB is the last HOB in the HOB list.  This macro determine if the HOB specified by HobStart is the  last HOB in the HOB list.  If HobStart is last HOB in the HOB list,  then TRUE is returned.  Otherwise, FALSE is returned.  @param  HobStart   A pointer to a HOB.  @retval TRUE       The HOB specified by HobStart is the last HOB in the HOB list.  @retval FALSE      The HOB specified by HobStart is not the last HOB in the HOB list.**/#define END_OF_HOB_LIST(HobStart)  (GET_HOB_TYPE (HobStart) == (UINT16)EFI_HOB_TYPE_END_OF_HOB_LIST)/**  Returns a pointer to data buffer from a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  This macro returns a pointer to the data buffer in a HOB specified by HobStart.  HobStart is assumed to be a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  @param   GuidHob   A pointer to a HOB.  @return  A pointer to the data buffer in a HOB.**/#define GET_GUID_HOB_DATA(HobStart) \  (VOID *)(*(UINT8 **)&amp;(HobStart) + sizeof (EFI_HOB_GUID_TYPE))/**  Returns the size of the data buffer from a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  This macro returns the size, in bytes, of the data buffer in a HOB specified by HobStart.  HobStart is assumed to be a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  @param   GuidHob   A pointer to a HOB.  @return  The size of the data buffer.**/#define GET_GUID_HOB_DATA_SIZE(HobStart) \  (UINT16)(GET_HOB_LENGTH (HobStart) - sizeof (EFI_HOB_GUID_TYPE))</code></pre><h2 id="CreateHob-仅PEI阶段有效"><a href="#CreateHob-仅PEI阶段有效" class="headerlink" title="CreateHob(仅PEI阶段有效)"></a>CreateHob(仅PEI阶段有效)</h2><ul><li>MdeModulePkg\Core\Pei\PeiMain.h</li></ul><pre><code>/**  Add a new HOB to the HOB List.  @param PeiServices        An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param Type               Type of the new HOB.  @param Length             Length of the new HOB to allocate.  @param Hob                Pointer to the new HOB.  @return  EFI_SUCCESS           Success to create hob.  @retval  EFI_INVALID_PARAMETER if Hob is NULL  @retval  EFI_NOT_AVAILABLE_YET if HobList is still not available.  @retval  EFI_OUT_OF_RESOURCES  if there is no more memory to grow the Hoblist.**/EFI_STATUSEFIAPIPeiCreateHob (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN UINT16            Type,  IN UINT16            Length,  IN OUT VOID          **Hob  );</code></pre><ul><li>MdeModulePkg\Core\Pei\Hob\Hob.c</li></ul><pre><code>/**  Add a new HOB to the HOB List.  @param PeiServices      An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param Type             Type of the new HOB.  @param Length           Length of the new HOB to allocate.  @param Hob              Pointer to the new HOB.  @return  EFI_SUCCESS           Success to create hob.  @retval  EFI_INVALID_PARAMETER if Hob is NULL  @retval  EFI_NOT_AVAILABLE_YET if HobList is still not available.  @retval  EFI_OUT_OF_RESOURCES  if there is no more memory to grow the Hoblist.**/EFI_STATUSEFIAPIPeiCreateHob (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN UINT16            Type,  IN UINT16            Length,  IN OUT VOID          **Hob  )&#123;  EFI_STATUS                           Status;  EFI_HOB_HANDOFF_INFO_TABLE           *HandOffHob;  EFI_HOB_GENERIC_HEADER               *HobEnd;  EFI_PHYSICAL_ADDRESS                 FreeMemory;  Status = PeiGetHobList (PeiServices, Hob);  if (EFI_ERROR(Status)) &#123;    return Status;  &#125;  HandOffHob = *Hob;  //  // Check Length to avoid data overflow.  //  if (0x10000 - Length &lt;= 0x7) &#123;    return EFI_INVALID_PARAMETER;  &#125;  Length     = (UINT16)((Length + 0x7) &amp; (~0x7));  FreeMemory = HandOffHob-&gt;EfiFreeMemoryTop -               HandOffHob-&gt;EfiFreeMemoryBottom;  if (FreeMemory &lt; Length) &#123;    DEBUG ((EFI_D_ERROR, &quot;PeiCreateHob fail: Length - 0x%08x\n&quot;, (UINTN)Length));    DEBUG ((EFI_D_ERROR, &quot;  FreeMemoryTop    - 0x%08x\n&quot;, (UINTN)HandOffHob-&gt;EfiFreeMemoryTop));    DEBUG ((EFI_D_ERROR, &quot;  FreeMemoryBottom - 0x%08x\n&quot;, (UINTN)HandOffHob-&gt;EfiFreeMemoryBottom));    return EFI_OUT_OF_RESOURCES;  &#125;  *Hob = (VOID*) (UINTN) HandOffHob-&gt;EfiEndOfHobList;  ((EFI_HOB_GENERIC_HEADER*) *Hob)-&gt;HobType   = Type;  ((EFI_HOB_GENERIC_HEADER*) *Hob)-&gt;HobLength = Length;  ((EFI_HOB_GENERIC_HEADER*) *Hob)-&gt;Reserved  = 0;  HobEnd = (EFI_HOB_GENERIC_HEADER*) ((UINTN) *Hob + Length);  HandOffHob-&gt;EfiEndOfHobList = (EFI_PHYSICAL_ADDRESS) (UINTN) HobEnd;  HobEnd-&gt;HobType   = EFI_HOB_TYPE_END_OF_HOB_LIST;  HobEnd-&gt;HobLength = (UINT16) sizeof (EFI_HOB_GENERIC_HEADER);  HobEnd-&gt;Reserved  = 0;  HobEnd++;  HandOffHob-&gt;EfiFreeMemoryBottom = (EFI_PHYSICAL_ADDRESS) (UINTN) HobEnd;  return EFI_SUCCESS;&#125; </code></pre><ul><li>MdePkg\Include\Pi\PiPeiCis.h</li></ul><pre><code>/**  This service, published by the PEI Foundation, abstracts the creation of a Hand-Off Block&#39;s (HOB&#39;s) headers.  @param  PeiServices      An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param  Type             The type of HOB to be installed.  @param  Length           The length of the HOB to be added.  @param  Hob              The address of a pointer that will contain the HOB header.  @retval EFI_SUCCESS           The HOB was successfully created.  @retval EFI_OUT_OF_RESOURCES  There is no additional space for HOB creation.**/typedefEFI_STATUS(EFIAPI *EFI_PEI_CREATE_HOB)(  IN CONST EFI_PEI_SERVICES            **PeiServices,  IN UINT16                            Type,  IN UINT16                            Length,  IN OUT VOID                          **Hob  );/// EFI_PEI_SERVICES is a collection of functions whose implementation is provided by the PEI/// Foundation. These services fall into various classes, including the following:/// - Managing the boot mode/// - Allocating both early and permanent memory/// - Supporting the Firmware File System (FFS)/// - Abstracting the PPI database abstraction/// - Creating Hand-Off Blocks (HOBs).///struct _EFI_PEI_SERVICES &#123;  ///  /// The table header for the PEI Services Table.  ///  EFI_TABLE_HEADER                Hdr;  //  // PPI Functions  //  EFI_PEI_INSTALL_PPI             InstallPpi;  EFI_PEI_REINSTALL_PPI           ReInstallPpi;  EFI_PEI_LOCATE_PPI              LocatePpi;  EFI_PEI_NOTIFY_PPI              NotifyPpi;  //  // Boot Mode Functions  //  EFI_PEI_GET_BOOT_MODE           GetBootMode;  EFI_PEI_SET_BOOT_MODE           SetBootMode;  //  // HOB Functions  //  EFI_PEI_GET_HOB_LIST            GetHobList;  EFI_PEI_CREATE_HOB              CreateHob;  //  // Firmware Volume Functions  //  EFI_PEI_FFS_FIND_NEXT_VOLUME2   FfsFindNextVolume;  EFI_PEI_FFS_FIND_NEXT_FILE2     FfsFindNextFile;  EFI_PEI_FFS_FIND_SECTION_DATA2  FfsFindSectionData;  //  // PEI Memory Functions  //  EFI_PEI_INSTALL_PEI_MEMORY      InstallPeiMemory;  EFI_PEI_ALLOCATE_PAGES          AllocatePages;  EFI_PEI_ALLOCATE_POOL           AllocatePool;  EFI_PEI_COPY_MEM                CopyMem;  EFI_PEI_SET_MEM                 SetMem;  //  // Status Code  //  EFI_PEI_REPORT_STATUS_CODE      ReportStatusCode;  //  // Reset  //  EFI_PEI_RESET_SYSTEM            ResetSystem;  //  // (the following interfaces are installed by publishing PEIM)  // I/O Abstractions  //  EFI_PEI_CPU_IO_PPI              *CpuIo;  EFI_PEI_PCI_CFG2_PPI            *PciCfg;  //  // Future Installed Services  //  EFI_PEI_FFS_FIND_BY_NAME        FfsFindFileByName;  EFI_PEI_FFS_GET_FILE_INFO       FfsGetFileInfo;  EFI_PEI_FFS_GET_VOLUME_INFO     FfsGetVolumeInfo;  EFI_PEI_REGISTER_FOR_SHADOW     RegisterForShadow;  EFI_PEI_FFS_FIND_SECTION_DATA3  FindSectionData3;  EFI_PEI_FFS_GET_FILE_INFO2      FfsGetFileInfo2;  EFI_PEI_RESET2_SYSTEM           ResetSystem2;  EFI_PEI_FREE_PAGES              FreePages;&#125;;</code></pre><ul><li>MdeModulePkg\Core\Pei\PeiMain\PeiMain.c</li></ul><pre><code>/// Pei service instance///EFI_PEI_SERVICES  gPs = &#123;  &#123;    PEI_SERVICES_SIGNATURE,    PEI_SERVICES_REVISION,    sizeof (EFI_PEI_SERVICES),    0,    0  &#125;,  PeiInstallPpi,  PeiReInstallPpi,  PeiLocatePpi,  PeiNotifyPpi,  PeiGetBootMode,  PeiSetBootMode,  PeiGetHobList,  PeiCreateHob,  PeiFfsFindNextVolume,  PeiFfsFindNextFile,  PeiFfsFindSectionData,  PeiInstallPeiMemory,  PeiAllocatePages,  PeiAllocatePool,  (EFI_PEI_COPY_MEM)CopyMem,  (EFI_PEI_SET_MEM)SetMem,  PeiReportStatusCode,  PeiResetSystem,  &amp;gPeiDefaultCpuIoPpi,  &amp;gPeiDefaultPciCfg2Ppi,  PeiFfsFindFileByName,  PeiFfsGetFileInfo,  PeiFfsGetVolumeInfo,  PeiRegisterForShadow,  PeiFfsFindSectionData3,  PeiFfsGetFileInfo2,  PeiResetSystem2,  PeiFreePages,&#125;;</code></pre><h2 id="GetHobList-PEI阶段实现"><a href="#GetHobList-PEI阶段实现" class="headerlink" title="GetHobList(PEI阶段实现)"></a>GetHobList(PEI阶段实现)</h2><ul><li>MdeModulePkg\Core\Pei\PeiMain.h</li></ul><pre><code>/**  Gets the pointer to the HOB List.  @param PeiServices                   An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param HobList                       Pointer to the HOB List.  @retval EFI_SUCCESS                  Get the pointer of HOB List  @retval EFI_NOT_AVAILABLE_YET        the HOB List is not yet published  @retval EFI_INVALID_PARAMETER        HobList is NULL (in debug mode)**/EFI_STATUSEFIAPIPeiGetHobList (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN OUT VOID          **HobList  );</code></pre><ul><li>MdeModulePkg\Core\Pei\Hob\Hob.c</li></ul><pre><code>/**   Gets the pointer to the HOB List.  @param PeiServices                   An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param HobList                       Pointer to the HOB List.  @retval EFI_SUCCESS                  Get the pointer of HOB List  @retval EFI_NOT_AVAILABLE_YET        the HOB List is not yet published  @retval EFI_INVALID_PARAMETER        HobList is NULL (in debug mode) **/EFI_STATUSEFIAPIPeiGetHobList (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN OUT VOID          **HobList  )&#123;  PEI_CORE_INSTANCE *PrivateData;  //  // Only check this parameter in debug mode  //  DEBUG_CODE_BEGIN ();    if (HobList == NULL) &#123;      return EFI_INVALID_PARAMETER;    &#125;  DEBUG_CODE_END ();  PrivateData = PEI_CORE_INSTANCE_FROM_PS_THIS(PeiServices);  *HobList    = PrivateData-&gt;HobList.Raw;  return EFI_SUCCESS;&#125;</code></pre><ul><li>PeiMain.h</li></ul><blockquote><p>这个宏的作用是根据一个结构体成员变量的的地址获得该结构体基地址</p></blockquote><p>定义形式：<br>#define _CR(Record, TYPE, Field) <br>((TYPE *) ((CHAR8 *) (Record) - (CHAR8 *) &amp;(((TYPE *) 0)-&gt;Field)))<br>功能是：找出TYPE类型结构体成员Field所在结构体的地址,Record是Field的地址。</p><p>具体实现：<br>1.(CHAR8 *) (Record)：Field的地址以CHAR8 *类型进行运算。</p><p>2.(CHAR8 *) &amp;(((TYPE *) 0)-&gt;Field))：重点就是(TYPE *) 0)了，ANSI C标准允许值为0的常量被强制转换成任何一种类型的指针，并且转换结果是一个NULL指针，因此((type *)0)的结果就是一个类型为type *的NULL指针。如果利用这NULL指针来访问type的成员当然是非法的，但&amp;( ((type *)0)-&gt;field )的意图仅仅是计算field字段的地址。聪明的编译器根本就不生成访问type的代码，而仅仅是根据type的内存布局和结构体实例首址在编译期计算这个（常量）地址，这样就完全避免了通过NULL指针访问内存的问题。又因为首址为0，所以这个地址的值就是字段相对于结构体基址的偏移。以上方法避免了实例化一个type对象，并且求值在编译期进行，没有运行期负担。这样，就得到了Field在它的结构体中的偏移地址并同样以CHAR8 *类型进行运算。</p><p>3.((TYPE *) ：最后求得的地址转成原有结构体类型。<br>用1得到的变量地址减去2得到的变量偏移地址，得到的基地址通过3转换回原来的类型。大功告成！<br>重点就是  ((TYPE *) 0)-&gt;Field)。</p><pre><code> ////// Pei Core Instance Data Macros///#define PEI_CORE_INSTANCE_FROM_PS_THIS(a) \  CR(a, PEI_CORE_INSTANCE, Ps, PEI_CORE_HANDLE_SIGNATURE)</code></pre><h2 id="GetHobList-DXE阶段实现"><a href="#GetHobList-DXE阶段实现" class="headerlink" title="GetHobList(DXE阶段实现)"></a>GetHobList(DXE阶段实现)</h2><ul><li>MdePkg\Library\DxeHobLib\HobLib.c</li></ul><pre><code>VOID  *mHobList = NULL;/**  Returns the pointer to the HOB list.  This function returns the pointer to first HOB in the list.  For PEI phase, the PEI service GetHobList() can be used to retrieve the pointer  to the HOB list.  For the DXE phase, the HOB list pointer can be retrieved through  the EFI System Table by looking up theHOB list GUID in the System Configuration Table.  Since the System Configuration Table does not exist that the time the DXE Core is  launched, the DXE Core uses a global variable from the DXE Core Entry Point Library  to manage the pointer to the HOB list.  If the pointer to the HOB list is NULL, then ASSERT().  This function also caches the pointer to the HOB list retrieved.  @return The pointer to the HOB list.**/VOID *EFIAPIGetHobList (  VOID  )&#123;  EFI_STATUS  Status;  if (mHobList == NULL) &#123;    Status = EfiGetSystemConfigurationTable (&amp;gEfiHobListGuid, &amp;mHobList);    ASSERT_EFI_ERROR (Status);    ASSERT (mHobList != NULL);  &#125;  return mHobList;&#125;</code></pre><pre><code>/**  Retrieves a pointer to the system configuration table from the EFI System Table  based on a specified GUID.  This function searches the list of configuration tables stored in the EFI System Table  for a table with a GUID that matches TableGuid.  If a match is found, then a pointer to  the configuration table is returned in Table., and EFI_SUCCESS is returned. If a matching GUID  is not found, then EFI_NOT_FOUND is returned.  If TableGuid is NULL, then ASSERT().  If Table is NULL, then ASSERT().  @param  TableGuid       The pointer to table&#39;s GUID type.  @param  Table           The pointer to the table associated with TableGuid in the EFI System Table.  @retval EFI_SUCCESS     A configuration table matching TableGuid was found.  @retval EFI_NOT_FOUND   A configuration table matching TableGuid could not be found.**/EFI_STATUSEFIAPIEfiGetSystemConfigurationTable (  IN  EFI_GUID  *TableGuid,  OUT VOID      **Table  )&#123;  EFI_SYSTEM_TABLE  *SystemTable;  UINTN             Index;  ASSERT (TableGuid != NULL);  ASSERT (Table != NULL);  SystemTable = gST;  *Table = NULL;  for (Index = 0; Index &lt; SystemTable-&gt;NumberOfTableEntries; Index++) &#123;    if (CompareGuid (TableGuid, &amp;(SystemTable-&gt;ConfigurationTable[Index].VendorGuid))) &#123;      *Table = SystemTable-&gt;ConfigurationTable[Index].VendorTable;      return EFI_SUCCESS;    &#125;  &#125;  return EFI_NOT_FOUND;&#125;</code></pre><h2 id="GetNextHob"><a href="#GetNextHob" class="headerlink" title="GetNextHob"></a>GetNextHob</h2><pre><code>/**  Returns the next instance of a HOB type from the starting HOB.  This function searches the first instance of a HOB type from the starting HOB pointer.  If there does not exist such HOB type from the starting HOB pointer, it will return NULL.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.  If HobStart is NULL, then ASSERT().  @param  Type          The HOB type to return.  @param  HobStart      The starting HOB pointer to search from.  @return The next instance of a HOB type from the starting HOB.**/VOID *EFIAPIGetNextHob (  IN UINT16                 Type,  IN CONST VOID             *HobStart  )&#123;  EFI_PEI_HOB_POINTERS  Hob;  ASSERT (HobStart != NULL);  Hob.Raw = (UINT8 *) HobStart;  //  // Parse the HOB list until end of list or matching type is found.  //  while (!END_OF_HOB_LIST (Hob)) &#123;    if (Hob.Header-&gt;HobType == Type) &#123;      return Hob.Raw;    &#125;    Hob.Raw = GET_NEXT_HOB (Hob);  &#125;  return NULL;&#125;</code></pre><h2 id="GetFirstHob"><a href="#GetFirstHob" class="headerlink" title="GetFirstHob"></a>GetFirstHob</h2><pre><code>/**  Returns the first instance of a HOB type among the whole HOB list.  This function searches the first instance of a HOB type among the whole HOB list.  If there does not exist such HOB type in the HOB list, it will return NULL.  If the pointer to the HOB list is NULL, then ASSERT().  @param  Type          The HOB type to return.  @return The next instance of a HOB type from the starting HOB.**/VOID *EFIAPIGetFirstHob (  IN UINT16                 Type  )&#123;  VOID      *HobList;  HobList = GetHobList ();  return GetNextHob (Type, HobList);&#125;</code></pre><h2 id="GetNextGuidHob"><a href="#GetNextGuidHob" class="headerlink" title="GetNextGuidHob"></a>GetNextGuidHob</h2><pre><code>/**  Returns the next instance of the matched GUID HOB from the starting HOB.  This function searches the first instance of a HOB from the starting HOB pointer.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size information, respectively.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.  If Guid is NULL, then ASSERT().  If HobStart is NULL, then ASSERT().  @param  Guid          The GUID to match with in the HOB list.  @param  HobStart      A pointer to a Guid.  @return The next instance of the matched GUID HOB from the starting HOB.**/VOID *EFIAPIGetNextGuidHob (  IN CONST EFI_GUID         *Guid,  IN CONST VOID             *HobStart  )&#123;  EFI_PEI_HOB_POINTERS  GuidHob;  GuidHob.Raw = (UINT8 *) HobStart;  while ((GuidHob.Raw = GetNextHob (EFI_HOB_TYPE_GUID_EXTENSION, GuidHob.Raw)) != NULL) &#123;    if (CompareGuid (Guid, &amp;GuidHob.Guid-&gt;Name)) &#123;      break;    &#125;    GuidHob.Raw = GET_NEXT_HOB (GuidHob);  &#125;  return GuidHob.Raw;&#125;</code></pre><h2 id="GetFirstGuidHob"><a href="#GetFirstGuidHob" class="headerlink" title="GetFirstGuidHob"></a>GetFirstGuidHob</h2><pre><code>/**  Returns the first instance of the matched GUID HOB among the whole HOB list.  This function searches the first instance of a HOB among the whole HOB list.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size information, respectively.  If the pointer to the HOB list is NULL, then ASSERT().  If Guid is NULL, then ASSERT().  @param  Guid          The GUID to match with in the HOB list.  @return The first instance of the matched GUID HOB among the whole HOB list.**/VOID *EFIAPIGetFirstGuidHob (  IN CONST EFI_GUID         *Guid  )&#123;  VOID      *HobList;  HobList = GetHobList ();  return GetNextGuidHob (Guid, HobList);&#125;</code></pre><hr><h1 id="HOB生产消费流程"><a href="#HOB生产消费流程" class="headerlink" title="HOB生产消费流程"></a>HOB生产消费流程</h1><h2 id="PHIT-HOB的建立"><a href="#PHIT-HOB的建立" class="headerlink" title="PHIT HOB的建立"></a>PHIT HOB的建立</h2><ul><li> MdeModulePkg\Core\Pei\Hob\Hob.c</li></ul><pre><code>/**  Builds a Handoff Information Table HOB  @param BootMode        - Current Bootmode  @param MemoryBegin     - Start Memory Address.  @param MemoryLength    - Length of Memory.  @return EFI_SUCCESS Always success to initialize HOB.**/EFI_STATUSPeiCoreBuildHobHandoffInfoTable (  IN EFI_BOOT_MODE         BootMode,  IN EFI_PHYSICAL_ADDRESS  MemoryBegin,  IN UINT64                MemoryLength  )&#123;  EFI_HOB_HANDOFF_INFO_TABLE   *Hob;  EFI_HOB_GENERIC_HEADER       *HobEnd;  Hob                      = (VOID *)(UINTN)MemoryBegin;  HobEnd                   = (EFI_HOB_GENERIC_HEADER*) (Hob+1);  Hob-&gt;Header.HobType      = EFI_HOB_TYPE_HANDOFF;  Hob-&gt;Header.HobLength    = (UINT16) sizeof (EFI_HOB_HANDOFF_INFO_TABLE);  Hob-&gt;Header.Reserved     = 0;  HobEnd-&gt;HobType          = EFI_HOB_TYPE_END_OF_HOB_LIST;  HobEnd-&gt;HobLength        = (UINT16) sizeof (EFI_HOB_GENERIC_HEADER);  HobEnd-&gt;Reserved         = 0;  Hob-&gt;Version             = EFI_HOB_HANDOFF_TABLE_VERSION;  Hob-&gt;BootMode            = BootMode;  Hob-&gt;EfiMemoryTop        = MemoryBegin + MemoryLength;  Hob-&gt;EfiMemoryBottom     = MemoryBegin;  Hob-&gt;EfiFreeMemoryTop    = MemoryBegin + MemoryLength;  Hob-&gt;EfiFreeMemoryBottom = (EFI_PHYSICAL_ADDRESS) (UINTN) (HobEnd + 1);  Hob-&gt;EfiEndOfHobList     = (EFI_PHYSICAL_ADDRESS) (UINTN) HobEnd;  return EFI_SUCCESS;&#125;</code></pre><blockquote><p>头和尾HOB建立后，CreateHob会覆盖尾HOB，再将尾HOB后移，此时PEI阶段的模块会相继创建各种类型的HOB，我们可以在PEI阶段自己创建HOB传递一些数据，也可以在PEI和DXE阶段找到感兴趣的HOB块，对其BLOCK数据块进行操作，但是理论上在DXE阶段使用Get方法，不建议在PEI阶段使用，是因为不确定Get的HOB是否已经建立，即无法判断两个Pei ModulePart的执行顺序，当然也可以通过Deepx来限定ModulePart跑的顺序</p></blockquote><h1 id="作业Demo"><a href="#作业Demo" class="headerlink" title="作业Demo"></a>作业Demo</h1><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603960797904.png" alt="HOB Homework"></p><ul><li>OemHob.h</li></ul><pre><code>#ifndef __OEM_HOB_H__#define __OEM_HOB_H__#ifdef __cplusplusextern &quot;C&quot; &#123;#endif#define OEM_HOB_GUID \    &#123;0xe73e6c2b, 0xaa9a, 0x4b51, 0x94, 0x56, 0x50, 0xd2, 0x8b, 0xcc, 0x57, 0xf3&#125;typedef struct _OEM_HOB&#123;       EFI_HOB_GUID_TYPE GuidExtension;    CHAR8 OemString[10];    UINT16 MemorySpace;  &#125; OEM_HOB;/****** DO NOT WRITE BELOW THIS LINE *******/#ifdef __cplusplus&#125;#endif#endif</code></pre><ul><li>PeiCreateHob.c</li></ul><pre><code>#include &lt;AmiPeiLib.h&gt;#include &lt;Library/PeiServicesLib.h&gt;#include &lt;Library/HobLib.h&gt;#include &lt;OemHob.h&gt;#include &lt;MemInfoHob.h&gt;extern EFI_GUID gSiMemoryInfoDataGuid;EFI_STATUS PeiCreateHobEntryPoint(   IN EFI_PEI_FILE_HANDLE   FileHandle,   IN CONST EFI_PEI_SERVICES  **PeiServices)&#123;    EFI_STATUS    Status = EFI_SUCCESS;    OEM_HOB       *pHob     = NULL;    VOID          *Memory_Hob  = NULL;    EFI_GUID      OemHobGuid = OEM_HOB_GUID;    EFI_GUID      MemoryInfoDataGuid = gSiMemoryInfoDataGuid;    //CHAR8         BIOSVersion[] = CONVERT_TO_STRING(PLATFORM_NAME);    CHAR8         BIOSVersion[10]=&quot;kabylake&quot;;    UINT16        MemorySize = 0;    // Get physical address bits supported.    Memory_Hob = GetFirstGuidHob(&amp;MemoryInfoDataGuid);    if (Memory_Hob != NULL) &#123;        MemorySize = ((MEMORY_INFO_DATA_HOB *) Memory_Hob)-&gt;TotalPhysicalMemorySize;        DEBUG((-1,&quot;\nElder has been got MemoryInfoDataHob in Pei Phase!&quot;));        DEBUG((-1,&quot;\nMemoryInfoDataHob Address : %p&quot;,Memory_Hob));      &#125;     //create HOB for DXE    Status = (*PeiServices)-&gt;CreateHob (PeiServices,                                        EFI_HOB_TYPE_GUID_EXTENSION,                                         sizeof(OEM_HOB),                                         &amp;pHob);    if (!EFI_ERROR(Status))&#123;           pHob-&gt;GuidExtension.Name = OemHobGuid;           Strcpy(pHob-&gt;OemString,BIOSVersion);           pHob-&gt;MemorySpace = MemorySize;                      DEBUG((-1,&quot;\nElder has been Created OemHob Success in Pei Phase!&quot;));                  &#125;    return EFI_SUCCESS;&#125;</code></pre><ul><li>DxeFindHob.c</li></ul><pre><code>#include &lt;AmiDxeLib.h&gt;#include &lt;Library/HobLib.h&gt;#include &lt;OemHob.h&gt;EFI_STATUS DxeFindHobEntryPoint(    IN EFI_HANDLE ImageHandle,    IN EFI_SYSTEM_TABLE *SystemTable)&#123;    EFI_STATUS      Status = EFI_SUCCESS;    EFI_GUID        OemHobGuid = OEM_HOB_GUID;    OEM_HOB         *pHob = NULL;    InitAmiLib (ImageHandle , SystemTable) ;    pHob = (OEM_HOB*)GetFirstGuidHob (&amp;OemHobGuid);    if (pHob == NULL)        &#123;            DEBUG((-1,&quot;\n Elder Dxe Phase return OemHob Data Error!\n&quot;));        &#125;    else        &#123;            DEBUG((-1,&quot;\n Elder OemHob Address = %p\n&quot;,pHob));                DEBUG((-1,&quot;\n Elder Dxe Phase has been got HobData OemString = %s\n&quot;,pHob-&gt;OemString));            DEBUG((-1,&quot;\n Elder Dxe Phase has been got HobData MemorySpace = %d MB\n&quot;,pHob-&gt;MemorySpace));        &#125;    return EFI_SUCCESS;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 概念,code,数据结构,使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
