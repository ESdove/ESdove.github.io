<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MdePkg/MdeModuPKg LIB</title>
      <link href="2021/08/04/LIB%20API%E6%9F%A5%E8%AF%A2/"/>
      <url>2021/08/04/LIB%20API%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="MdePkg-相关Lib"><a href="#MdePkg-相关Lib" class="headerlink" title="MdePkg 相关Lib"></a>MdePkg 相关Lib</h2><h2 id="MdePkg-Include-Library"><a href="#MdePkg-Include-Library" class="headerlink" title="MdePkg\Include\Library"></a>MdePkg\Include\Library</h2><blockquote><p>edk2-stable202105目前为止MdePkg一共声明了67个头文件</p><p>UnitTestHostBaseLib|Test/UnitTest/Include/Library/UnitTestHostBaseLib.h比较特殊，放在Test文件夹下，其余都在Include/Library路径下</p></blockquote><blockquote><p>dec文件中LibraryClasses项中会声明相应的Lib和其包含路径的对应的头文件，规范起见一般统一放在Include/Library路径下，一般来说LibraryClassesName和头文件*.h会取相同的命名，有些LibraryClasses不是common的，和架构有关，需要通过[LibraryClasses.IA32, LibraryClasses.X64, LibraryClasses.AARCH64]来指明Lib可以在那些架构中使用,例如SMM SMI只适用于IA32 X64架构</p></blockquote><blockquote><p>dec中定义了LibraryClassesName，并且和Include\Library中声明的头文件关联起来了，对应的LibraryInstance放在Library文件夹下，一般为了统一取的文件夹名也是和LibraryClassesName相同，最后LibraryClasses Mapping的时候会将dec中声明的Lib和实现的LibraryInstance Module的inf对应上，会出现dec出现的Lib，dsc中没有对应，猜想应该是只想共本Pkg调用，所以未对外暴露接口</p></blockquote><blockquote><p>LibraryClasses中声明的接口对应的实现我们叫做LibraryInstance，这个会包在dsc文件里的Components中，实现也是和架构有关的，所以会卡[Components.IA32, Components.X64, Components.ARM, Components.AARCH64]的条件，主要看这个实现部分在对应的架构能不能被用</p></blockquote><blockquote><p>一般来说，一个LibraryClass的LibraryInstance可能有多个，常见的如CpuLib有两个Instance，一个为Null，那就对应Library/BaseCpuLib和Library/BaseCpuLibNull两个文件夹，还有就是不同Phase有不同的实现，例如BaseMemoryLib对应Library/BaseMemoryLib，Library/BaseMemoryLibMmx，Library/BaseMemoryLibOptDxe，Library/BaseMemoryLibOptPei，Library/BaseMemoryLibRepStr，Library/BaseMemoryLibSse2这几个文件夹下对应的inf的LibraryInstance，还有就是instance跨Pkg的情况，一般lib都是本Pkg声明和实现，但不绝对，其中MemoryAllocationLib是在MdePkg声明的，但存在instance在MdeModulePkg，DxeCoreMemoryAllocationLib.inf</p><p>PiSmmCoreMemoryAllocationLib.inf,类似的还有SmmServicesTableLib.h，HobLib.h</p></blockquote><table><thead><tr><th align="left">*.h</th><th align="left">LibraryClassesName</th><th>LibraryInstance</th></tr></thead><tbody><tr><td align="left">BaseLib.h</td><td align="left">BaseLib</td><td>BaseLib.inf</td></tr><tr><td align="left">BaseMemoryLib.h</td><td align="left">BaseMemoryLib</td><td>BaseMemoryLib.inf<br />PeiMemoryLib.inf<br />UefiMemoryLib.inf<br />BaseMemoryLibMmx.inf<br />BaseMemoryLibOptDxe.inf<br />BaseMemoryLibOptPei.inf<br />BaseMemoryLibRepStr.inf<br />BaseMemoryLibSse2.inf</td></tr><tr><td align="left">CacheMaintenanceLib.h</td><td align="left">CacheMaintenanceLib</td><td>BaseCacheMaintenanceLib.inf<br />BaseCacheMaintenanceLibNull.inf</td></tr><tr><td align="left">CpuLib.h</td><td align="left">CpuLib</td><td>BaseCpuLib.inf<br />BaseCpuLibNull.inf</td></tr><tr><td align="left">DebugLib.h</td><td align="left">DebugLib</td><td>BaseDebugLibNull.inf<br />BaseDebugLibSerialPort.inf<br />DxeRuntimeDebugLibSerialPort.inf<br />UefiDebugLibConOut.inf<br />UefiDebugLibDebugPortProtocol.inf<br />UefiDebugLibStdErr.inf</td></tr><tr><td align="left">DebugPrintErrorLevelLib.h</td><td align="left">DebugPrintErrorLevelLib</td><td>BaseDebugPrintErrorLevelLib.inf</td></tr><tr><td align="left">DevicePathLib.h</td><td align="left">DevicePathLib</td><td>UefiDevicePathLib.inf<br />UefiDevicePathLibStandaloneMm.inf<br />UefiDevicePathLibOptional<br />DevicePathProtocol.inf<br />UefiDevicePathLibDevicePathProtocol.inf</td></tr><tr><td align="left">DxeCoreEntryPoint.h</td><td align="left">DxeCoreEntryPoint</td><td>DxeCoreEntryPoint.inf</td></tr><tr><td align="left">DxeServicesLib.h</td><td align="left">DxeServicesLib</td><td>DxeServicesLib.inf</td></tr><tr><td align="left">DxeServicesTableLib.h</td><td align="left">DxeServicesTableLib</td><td>DxeServicesTableLib.inf</td></tr><tr><td align="left">ExtractGuidSectionLib.h</td><td align="left">ExtractGuidedSectionLib</td><td>PeiExtractGuidedSectionLib.inf<br />DxeExtractGuidedSectionLib.inf<br />BaseExtractGuidedSectionLib</td></tr><tr><td align="left">FileHandleLib.h</td><td align="left">FileHandleLib</td><td>UefiFileHandleLib.inf</td></tr><tr><td align="left">HobLib.h</td><td align="left">HobLib</td><td>DxeCoreHobLib.inf<br />PeiHobLib.inf<br />DxeHobLib.inf<br /><br />(MdeModulePkg)<br /><code>BaseHobLibNull</code></td></tr><tr><td align="left">HstiLib.h</td><td align="left">HstiLib</td><td>DxeHstiLib.inf</td></tr><tr><td align="left">IoLib.h</td><td align="left">IoLib</td><td>DxeIoLibCpuIo2.inf<br />PeiIoLibCpuIo.inf<br />PeiIoLibCpuIo.inf<br />BaseIoLibIntrinsic.inf<br />BaseIoLibIntrinsicSev.inf<br />BaseIoLibIntrinsicArmVirt.inf</td></tr><tr><td align="left">MemoryAllocationLib.h</td><td align="left">MemoryAllocationLib</td><td>UefiMemoryAllocationLib<br />SmmMemoryAllocationLib.inf<br />(MdeModulePkg)<br /><code>DxeCoreMemoryAllocationLib.inf</code><br /><code>PiSmmCoreMemoryAllocationLib.inf</code><br /><code>BaseMemoryAllocationLibNull</code></td></tr><tr><td align="left">MmServicesTableLib.h</td><td align="left">MmServicesTableLib</td><td>MmServicesTableLib.inf</td></tr><tr><td align="left">MmUnblockMemoryLib.h</td><td align="left">MmUnblockMemoryLib</td><td>MmUnblockMemoryLibNull.inf</td></tr><tr><td align="left">OrderedCollectionLib.h</td><td align="left">OrderedCollectionLib</td><td>BaseOrderedCollection<br />RedBlackTreeLib.inf</td></tr><tr><td align="left">PcdLib.h</td><td align="left">PcdLib</td><td>BasePcdLibNull.inf<br />PeiPcdLib.inf<br />DxePcdLib.inf<br />SmmIoLibSmmCpuIo2.inf</td></tr><tr><td align="left">PciCf8Lib.h</td><td align="left">PciCf8Lib</td><td>BasePciCf8Lib.inf</td></tr><tr><td align="left">PciExpressLib.h</td><td align="left">PciExpressLib</td><td>BasePciLibPciExpress.inf<br />DxeRuntimePciExpressLib.inf<br />SmmPciExpressLib.inf</td></tr><tr><td align="left">PciLib.h</td><td align="left">PciLib</td><td>PeiPciLibPciCfg2.inf<br />UefiPciLibPciRootBridgeIo.inf</td></tr><tr><td align="left">PciSegmentInfoLib.h</td><td align="left">PciSegmentInfoLib</td><td>BasePciSegmentInfoLibNull.inf</td></tr><tr><td align="left">PciSegmentLib.h</td><td align="left">PciSegmentLib</td><td>BasePciSegmentLibSegmentInfo.inf<br />BasePciSegmentLibPci.inf<br />PeiPciSegmentLibPciCfg2.inf<br />DxeRuntimePciSegmentLib<br />SegmentInfo.inf<br />UefiPciSegmentLib<br />PciRootBridgeIo.inf</td></tr><tr><td align="left">PeCoffExtraActionLib.h</td><td align="left">PeCoffExtraActionLib</td><td>BasePeCoffExtraActionLibNull.inf</td></tr><tr><td align="left">PeCoffGetEntryPointLib.h</td><td align="left">PeCoffGetEntryPointLib</td><td>BasePeCoffGetEntryPointLib.inf</td></tr><tr><td align="left">PeCoffLib.h</td><td align="left">PeCoffLib</td><td>BasePeCoffLib.inf</td></tr><tr><td align="left">PeiCoreEntryPoint.h</td><td align="left">PeiCoreEntryPoint</td><td>PeiCoreEntryPoint.inf</td></tr><tr><td align="left">PeimEntryPoint.h</td><td align="left">PeimEntryPoint</td><td>PeimEntryPoint.inf</td></tr><tr><td align="left">PeiServicesLib.h</td><td align="left">PeiServicesLib</td><td>PeiServicesLib.inf</td></tr><tr><td align="left">PeiServicesTablePointerLib.h</td><td align="left">PeiServicesTablePointerLib</td><td>PeiServicesTablePointerLib.inf<br />PeiServicesTablePointerLibIdt.inf</td></tr><tr><td align="left">PerformanceLib.h</td><td align="left">PerformanceLib</td><td>BasePerformanceLibNull.inf</td></tr><tr><td align="left">PostCodeLib.h</td><td align="left">PostCodeLib</td><td>BasePostCodeLibDebug.inf<br />BasePostCodeLibPort80.inf<br />PeiDxePostCodeLibReportStatusCode.inf</td></tr><tr><td align="left">PrintLib.h</td><td align="left">PrintLib</td><td>BasePrintLib.inf</td></tr><tr><td align="left">RegisterFilterLib.h</td><td align="left">RegisterFilterLib</td><td>RegisterFilterLibNull.inf</td></tr><tr><td align="left">ReportStatusCodeLib.h</td><td align="left">ReportStatusCodeLib</td><td>BaseReportStatusCodeLibNull.inf</td></tr><tr><td align="left">ResourcePublicationLib.h</td><td align="left">ResourcePublicationLib</td><td>PeiResourcePublicationLib.inf</td></tr><tr><td align="left">RngLib.h</td><td align="left">RngLib(IA32 X64 AARCH64)</td><td>DxeRngLib.inf<br />BaseRngLibNull.inf<br />BaseRngLibTimerLib.inf<br />BaseRngLib.inf</td></tr><tr><td align="left">S3BootScriptLib.h</td><td align="left">S3BootScriptLib</td><td>BaseS3BootScriptLibNull.inf</td></tr><tr><td align="left">S3IoLib.h</td><td align="left">S3IoLib</td><td>BaseS3IoLib.inf</td></tr><tr><td align="left">S3PciLib.h</td><td align="left">S3PciLib</td><td>BaseS3PciLib.inf</td></tr><tr><td align="left">S3PciSegmentLib.h</td><td align="left">PciSegmentInfoLib</td><td>BaseS3PciSegmentLib.inf</td></tr><tr><td align="left">S3SmbusLib.h</td><td align="left">S3SmbusLib</td><td>BaseS3SmbusLib.inf</td></tr><tr><td align="left">S3StallLib.h</td><td align="left">S3StallLib</td><td>BaseS3StallLib.inf</td></tr><tr><td align="left">SafeIntLib.h</td><td align="left">SafeIntLib</td><td>BaseSafeIntLib.inf<br />TestBaseSafeIntLibPei.inf<br />TestBaseSafeIntLibDxe.inf<br />TestBaseSafeIntLibSmm.inf<br />TestBaseSafeIntLibUefiShell.inf</td></tr><tr><td align="left">SerialPortLib.h</td><td align="left">SerialPortLib</td><td>BaseSerialPortLibNull.inf</td></tr><tr><td align="left">SmbusLib.h</td><td align="left">SmbusLib</td><td>BaseSmbusLibNull.inf<br />PeiSmbusLibSmbus2Ppi.inf<br />DxeSmbusLib.inf</td></tr><tr><td align="left">SmiHandlerProfileLib.h</td><td align="left">SmiHandlerProfileLib(IA32 X64)</td><td>SmiHandlerProfileLibNull.inf</td></tr><tr><td align="left">SmmIoLib.h</td><td align="left">SmmIoLib(IA32 X64)</td><td>SmmIoLibSmmCpuIo2.inf<br />SmmIoLib.inf</td></tr><tr><td align="left">SmmLib.h</td><td align="left">SmmLib(IA32 X64)</td><td>SmmLibNull.inf</td></tr><tr><td align="left">SmmMemLib.h</td><td align="left">SmmMemLib(IA32 X64)</td><td>SmmMemLib.inf</td></tr><tr><td align="left">SmmPeriodicSmiLib.h</td><td align="left">SmmPeriodicSmiLib(IA32 X64)</td><td>SmmPeriodicSmiLib.inf</td></tr><tr><td align="left">SmmServicesTableLib.h</td><td align="left">SmmServicesTableLib(IA32 X64)</td><td>StandaloneMmServicesTableLib.inf<br />SmmServicesTableLib.inf<br />(MdeModulePkg)<br /><code>PiSmmCoreSmmServicesTableLib.inf</code></td></tr><tr><td align="left">StandloneMmDriverEntryPoint.h</td><td align="left">StandaloneMmDriverEntryPoint</td><td>StandaloneMmDriverEntryPoint.inf</td></tr><tr><td align="left">SynchronizationLib.h</td><td align="left">SynchronizationLib</td><td>BaseSynchronizationLib.inf</td></tr><tr><td align="left">TimerLib.h</td><td align="left">TimerLib</td><td>BaseTimerLibNullTemplate.inf<br />SecPeiDxeTimerLibCpu.inf</td></tr><tr><td align="left">UefiApplicationEntryPoint.h</td><td align="left">UefiApplicationEntryPoint</td><td>UefiApplicationEntryPoint.inf</td></tr><tr><td align="left">UefiBootServicesTableLib.h</td><td align="left">UefiBootServicesTableLib</td><td>UefiBootServicesTableLib.inf</td></tr><tr><td align="left">UefiDecompressLib.h</td><td align="left">UefiDecompressLib</td><td>BaseUefiDecompressLib.inf<br />BaseUefiTianoCustomDecompressLib.inf</td></tr><tr><td align="left">UefiDriverEntryPoint.h</td><td align="left">UefiDriverEntryPoint</td><td>UefiDriverEntryPoint.inf</td></tr><tr><td align="left">UefiLib.h</td><td align="left">UefiLib</td><td>UefiLib.inf</td></tr><tr><td align="left">UefiRuntimeLib.h</td><td align="left">UefiRuntimeLib</td><td>UefiRuntimeLib.inf</td></tr><tr><td align="left">UefiRuntimeSerivcesTablelib.h</td><td align="left">UefiRuntimeServicesTableLib</td><td>UefiRuntimeServicesTableLib.inf</td></tr><tr><td align="left">UefiScsiLib.h</td><td align="left">UefiScsiLib</td><td>UefiScsiLib.inf</td></tr><tr><td align="left">UefiUsbLib.h</td><td align="left">UefiUsbLib</td><td>UefiUsbLib.inf</td></tr><tr><td align="left">UnitTestLib.h</td><td align="left">UnitTestLib</td><td>BaseLibUnitTestsUefi.inf</td></tr></tbody></table><h2 id="MdeModulePkg-相关Lib"><a href="#MdeModulePkg-相关Lib" class="headerlink" title="MdeModulePkg 相关Lib"></a>MdeModulePkg 相关Lib</h2><h2 id="MdeModulePkg-Include-Library"><a href="#MdeModulePkg-Include-Library" class="headerlink" title="MdeModulePkg\Include\Library"></a>MdeModulePkg\Include\Library</h2><blockquote><p>edk2-stable202105目前为止MdeModulePkg一共声明了32个头文件</p></blockquote><table><thead><tr><th>*.h</th><th>LibraryClassesName</th><th>LibraryInstance</th></tr></thead><tbody><tr><td>AuthVariableLib.h</td><td>AuthVariableLib</td><td>AuthVariableLibNull.inf</td></tr><tr><td>BmpSupportLib.h</td><td>BmpSupportLib</td><td>BaseBmpSupportLib.inf</td></tr><tr><td>BootLogoLib.h</td><td>BootLogoLib</td><td>BootLogoLib.inf</td></tr><tr><td>CapsuleLib.h</td><td>CapsuleLib</td><td>DxeCapsuleLibNull.inf<br />DxeCapsuleLib.inf<br />DxeRuntimeCapsuleLib.inf</td></tr><tr><td>CpuExceptionHandlerLib.h</td><td>CpuExceptionHandlerLib</td><td>CpuExceptionHandler<br />LibNull.inf</td></tr><tr><td>CustomizedDisplayLib.h</td><td>CustomizedDisplayLib</td><td>CustomizedDisplayLib.inf</td></tr><tr><td>DebugAgentLib.h</td><td>DebugAgentLib</td><td>DebugAgentLibNull.inf</td></tr><tr><td>DisplayUpdateProgressLib.h</td><td>DisplayUpdateProgressLib</td><td>DisplayUpdate<br />ProgressLibGraphics.inf</td></tr><tr><td>FileExplorerLib.h</td><td>FileExplorerLib</td><td>FileExplorerLib.inf</td></tr><tr><td>FmpAuthenticationLib.h</td><td>FmpAuthenticationLib</td><td>FmpAuthen<br />ticationLibNull.inf</td></tr><tr><td>FrameBufferBltLib.h</td><td>FrameBufferBltLib</td><td>FrameBufferBltLib.inf</td></tr><tr><td>HiiLib.h</td><td>HiiLib</td><td>UefiHiiLib.inf</td></tr><tr><td>IpmiLib.h</td><td>IpmiLib</td><td>BaseIpmiLibNull.inf<br />PeiIpmiLibIpmiPpi.inf<br />DxeIpmiLibIpmiProtocol.inf<br />SmmIpmiLibSmm<br />IpmiProtocol.inf</td></tr><tr><td>LockBoxLib.h</td><td>LockBoxLib</td><td>SmmLockBoxPeiLib.inf<br />SmmLockBoxDxeLib.inf<br />SmmLockBoxStand<br />aloneMmLib.inf<br />LockBoxNullLib.inf</td></tr><tr><td>MemoryProfileLib.h</td><td>MemoryProfileLib</td><td></td></tr><tr><td>NonDiscoverableDeviceRegistrationLib.h</td><td>NonDiscoverableDeviceRegistrationLib</td><td>NonDiscoverable<br />DeviceRegistrationLib.inf</td></tr><tr><td>OemHookStatusCodeLib.h</td><td>OemHookStatusCodeLib</td><td>OemHookStatusCode<br />LibNull.inf</td></tr><tr><td>PciHostBridgeLib.h</td><td>PciHostBridgeLib</td><td>PciHostBridgeLibNull.inf</td></tr><tr><td>PlatformBootManagerLib.h</td><td>PlatformBootManagerLib</td><td>PlatformBootManager<br />LibNull.inf</td></tr><tr><td>PlatformHookLib.h</td><td>PlatformHookLib</td><td>BasePlatform<br />HookLibNull.inf<br />SmmCorePlatform<br />HookLibNull.inf</td></tr><tr><td>PlatformVarCleanupLib.h</td><td>PlatformVarCleanupLib</td><td>PlatformVarCleanupLib.inf</td></tr><tr><td>ResetSystemLib.h</td><td>ResetSystemLib</td><td>BaseResetSystemLibNull.inf</td></tr><tr><td>ResetUtilityLib.h</td><td>ResetUtilityLib</td><td>ResetUtilityLib.inf</td></tr><tr><td>SecurityManagementLib.h</td><td>SecurityManagementLib</td><td>DxeSecurity<br />ManagementLib.inf</td></tr><tr><td>SmmCorePlatformHookLib.h</td><td>SmmCorePlatformHookLib</td><td>SmmCorePlatform<br />HookLibNull.inf</td></tr><tr><td>SortLib.h</td><td>SortLib</td><td>BaseSortLib.inf</td></tr><tr><td>TpmMeasurementLib.h</td><td>TpmMeasurementLib</td><td>TpmMeasurementLibNull.inf</td></tr><tr><td>UefiBootMangerLib.h</td><td>UefiBootManagerLib</td><td>UefiBootManagerLib.inf</td></tr><tr><td>UefiHiiServiceLib.h</td><td>UefiHiiServicesLib</td><td>UefiHiiServicesLib.inf</td></tr><tr><td>VarCheckLib.h</td><td>VarCheckLib</td><td>VarCheckLib.inf</td></tr><tr><td>VariablePolicyHelperLib.h</td><td>VariablePolicyHelperLib</td><td>VariablePolicyLib<br />RuntimeDxe.inf</td></tr><tr><td>VariablePolicyLib.h</td><td>VariablePolicyLib</td><td>VariablePolicyLib.inf</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Lib, Instance, .h, Inf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Doxygen生成edk2 CHM</title>
      <link href="2021/08/04/Doxygen%E7%94%9F%E6%88%90edk2%20CHM/"/>
      <url>2021/08/04/Doxygen%E7%94%9F%E6%88%90edk2%20CHM/</url>
      
        <content type="html"><![CDATA[<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><blockquote><p>目前为止最新Release edk2-stable202105 MdePkg一共声明了67个头文件,MdeModulePkg一共声明了32个头文件，虽说常用API唯手熟尔，但有时候知道有什么，有个全局的印象，用到的时候才能想到去查，不用自己在子函数里造轮子。UDK2017和UDK02018是有提供生成好的包含MdePkg和MdeModulePkg的CHM文档的，本文记录下基于edk2—stable212105用Doxygen生成CHM踩的坑</p></blockquote><h1 id="Tool部署"><a href="#Tool部署" class="headerlink" title="Tool部署"></a>Tool部署</h1><blockquote><p>需要三个工具：doxygen安装包、graphviz安装包、htmlhelp安装包。其中doxygen是一种开源跨平台的文档系统，doxygen可以从一套归档源文件开始，生成HTML格式的在线类浏览器，或离线的LATEX、RTF参考手册</p></blockquote><blockquote><p>doxygen可以生成好几种格式的文档，要生成.chm格式的手册就必须安装htmlhelp，要生成关系图必须安装依graphviz</p></blockquote><h2 id="doxygen安装包"><a href="#doxygen安装包" class="headerlink" title="doxygen安装包"></a>doxygen安装包</h2><blockquote><p> <a href="http://www.doxygen.nl/download.html">http://www.doxygen.nl/download.html</a></p></blockquote><h2 id="graphviz安装包"><a href="#graphviz安装包" class="headerlink" title="graphviz安装包"></a>graphviz安装包</h2><blockquote><p> <a href="http://www.graphviz.org/">http://www.graphviz.org/</a></p></blockquote><h2 id="htmlhelp安装包"><a href="#htmlhelp安装包" class="headerlink" title="htmlhelp安装包"></a>htmlhelp安装包</h2><blockquote><p><a href="https://www.microsoft.com/en-us/download/details.aspx?id=21138"> https://www.microsoft.com/en-us/download/details.aspx?id=21138</a></p></blockquote><h1 id="生成机制"><a href="#生成机制" class="headerlink" title="生成机制"></a>生成机制</h1><blockquote><p>Doxygen可以根据固定格式的代码注释生成相对应的<code>*.chm</code>格式的手册。支持的语言有好多种，如C/C++/C#/Objective-C/PHP/Java等。edk2源码主要是C语言，Doxygen可以识别的固定格式注释有以下几种：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*** ...text...*/</span><span class="token comment">///</span><span class="token comment">///...text...</span><span class="token comment">///</span><span class="token comment">/*************************************   ...text...************************************/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>来看下edk2代码注释的Sample, 所有的函数都使用这样统一格式的注释，还是较为优雅的</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  Translate a *.BMP graphics image to a GOP blt buffer. If a NULL Blt buffer  is passed in a GopBlt buffer will be allocated by this routine using  EFI_BOOT_SERVICES.AllocatePool(). If a GopBlt buffer is passed in it will be  used if it is big enough.  @param [in]      BmpImage      Pointer to BMP file.  @param [in]      BmpImageSize  Number of bytes in BmpImage.  @param [in, out] GopBlt        Buffer containing GOP version of BmpImage.  @param [in, out] GopBltSize    Size of GopBlt in bytes.  @param [out]     PixelHeight   Height of GopBlt&#x2F;BmpImage in pixels.  @param [out]     PixelWidth    Width of GopBlt&#x2F;BmpImage in pixels.  @retval RETURN_SUCCESS            GopBlt and GopBltSize are returned.  @retval RETURN_INVALID_PARAMETER  BmpImage is NULL.  @retval RETURN_INVALID_PARAMETER  GopBlt is NULL.  @retval RETURN_INVALID_PARAMETER  GopBltSize is NULL.  @retval RETURN_INVALID_PARAMETER  PixelHeight is NULL.  @retval RETURN_INVALID_PARAMETER  PixelWidth is NULL.  @retval RETURN_UNSUPPORTED        BmpImage is not a valid *.BMP image.  @retval RETURN_BUFFER_TOO_SMALL   The passed in GopBlt buffer is not big                                    enough.  The required size is returned in                                    GopBltSize.  @retval RETURN_OUT_OF_RESOURCES   The GopBlt buffer could not be allocated.**&#x2F;RETURN_STATUSEFIAPITranslateBmpToGopBlt (  IN     VOID                           *BmpImage,  IN     UINTN                          BmpImageSize,  IN OUT EFI_GRAPHICS_OUTPUT_BLT_PIXEL  **GopBlt,  IN OUT UINTN                          *GopBltSize,  OUT    UINTN                          *PixelHeight,  OUT    UINTN                          *PixelWidth  );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="生成步骤"><a href="#生成步骤" class="headerlink" title="生成步骤"></a>生成步骤</h1><h2 id="设置工程工作目录"><a href="#设置工程工作目录" class="headerlink" title="设置工程工作目录"></a>设置工程工作目录</h2><p><img src="http://tc.holychen.cn/image/883c34a7-73e5-4c83-a75c-3157b194ab22.png" alt="img"></p><h2 id="设置编程语言"><a href="#设置编程语言" class="headerlink" title="设置编程语言"></a>设置编程语言</h2><p><img src="http://tc.holychen.cn/image/426fe839-498b-4f20-abda-0db585caf2d0.png" alt="img"></p><h2 id="设置输出文件格式"><a href="#设置输出文件格式" class="headerlink" title="设置输出文件格式"></a>设置输出文件格式</h2><p><img src="http://tc.holychen.cn/image/450db6b7-9835-4e73-b84c-c14042b8d37d.png" alt="img"></p><h2 id="设置生成的关系表"><a href="#设置生成的关系表" class="headerlink" title="设置生成的关系表"></a>设置生成的关系表</h2><p><img src="http://tc.holychen.cn/image/0e64112c-67aa-4f36-b226-4cb810b4cdef.png" alt="img"></p><h2 id="设置输出的语言和编码"><a href="#设置输出的语言和编码" class="headerlink" title="设置输出的语言和编码"></a>设置输出的语言和编码</h2><p><img src="http://tc.holychen.cn/image/bb9afe3a-0ead-4922-9d87-a900c0d094db.png" alt="img"></p><h2 id="设置一些构建的选择项"><a href="#设置一些构建的选择项" class="headerlink" title="设置一些构建的选择项"></a>设置一些构建的选择项</h2><p><img src="http://tc.holychen.cn/image/2e96bc01-ce33-488b-8e6b-8dae99a94273.png" alt="img"></p><h2 id="设置输入文件的编码"><a href="#设置输入文件的编码" class="headerlink" title="设置输入文件的编码"></a>设置输入文件的编码</h2><p><img src="http://tc.holychen.cn/image/224103a4-2fee-4c0c-a7b1-763d23186ca5.png" alt="img"></p><h2 id="设置是否在-chm中生成源码以供预览"><a href="#设置是否在-chm中生成源码以供预览" class="headerlink" title="设置是否在.chm中生成源码以供预览"></a>设置是否在.chm中生成源码以供预览</h2><p><img src="http://tc.holychen.cn/image/45e33a33-8462-49a1-a37e-bf1a231ed6f5.png" alt="img"></p><h2 id="设置HTML选项"><a href="#设置HTML选项" class="headerlink" title="设置HTML选项"></a>设置HTML选项</h2><p><img src="http://tc.holychen.cn/image/9156c3bd-f300-43c2-873e-e60755f13830.png" alt="img"></p><h2 id="设置Dot选项"><a href="#设置Dot选项" class="headerlink" title="设置Dot选项"></a>设置Dot选项</h2><p><img src="http://tc.holychen.cn/image/67292985-bf22-479f-8e4e-615444a46d0b.png" alt="img"></p><p><img src="http://tc.holychen.cn/image/874dd561-fc06-4d08-aadc-850df7714f0a.png" alt="img"></p><h2 id="运行生成-chm文件"><a href="#运行生成-chm文件" class="headerlink" title="运行生成.chm文件"></a>运行生成.chm文件</h2><p><img src="http://tc.holychen.cn/image/e599507e-1152-475c-989b-6807cbe79ae8.png" alt="img"></p><h2 id="保存工程文件"><a href="#保存工程文件" class="headerlink" title="保存工程文件"></a>保存工程文件</h2><p><img src="http://tc.holychen.cn/image/ec5f18ea-ecc6-42a1-9688-bdf5110c8f75.png" alt="img"></p><h1 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h1><p><img src="http://tc.holychen.cn/image/e4185b04-66bd-4397-907d-f640cffd96fd.png" alt="img"></p><p><img src="http://tc.holychen.cn/image/2ef21bd2-f4fb-49ff-9e4a-6e3a59ae8d20.png" alt="img"></p><p><img src="http://tc.holychen.cn/image/d2f9a953-89ed-42f7-b0d6-3d8a3218c55f.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Comment, Doxygen, CHM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Blog搭建</title>
      <link href="2021/08/03/Hexo_Blog%E6%90%AD%E5%BB%BA/"/>
      <url>2021/08/03/Hexo_Blog%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器购买"><a href="#服务器购买" class="headerlink" title="服务器购买"></a>服务器购买</h1><blockquote><p>鉴于博客托管到<a href="https://github.com/">Github</a>上加载太慢，搞个服务器是必须的，而且后面白嫖七牛云图床服务也需要用到。服务器这块可供选择很多，国内的直接<a href="https://cn.aliyun.com/">阿里云</a>，<a href="https://cloud.tencent.com/">腾讯云</a>走起，国外的<a href="https://bandwagonhost.com/">搬瓦工</a>，<a href="https://www.vultr.com/">Vultr</a>，<a href="https://www.hostwinds.com/vps/linux">Hostwinds</a>等VPS厂商也还行</p></blockquote><blockquote><p>最终选的阿里云学生套餐，配置是1核、2GB内存、40GB SSD的轻量应用服务器，服务端预装CentOS 7.3，一般会进工单后台系统重置下密码，不然下一步SSH连接输密码无回显，输入无规律字符会很难受</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454049.png" alt="轻量应用服务器"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454156.png" alt="工单后台"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454051.png" alt="重置密码"></p><blockquote><p>使用<a href="https://www.putty.org/">PuTTY</a>，<a href="https://www.netsarang.com/zh/xshell/">Xshell</a>，<a href="https://www.vandyke.com/products/securecrt/">SecureCRT</a>等工具，SSH连上远程服务器，这里使用<a href="https://mobaxterm.mobatek.net/">MobaXterm</a>，颜值还是比较耐打的，免费版差不多够用了，话说<a href="https://github.com/microsoft/terminal">Windows Terminal</a>也很OK</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454169.png" alt="SSH远程连接"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454170.png" alt="远程登录成功"></p><h1 id="域名-备案"><a href="#域名-备案" class="headerlink" title="域名 + 备案"></a>域名 + 备案</h1><blockquote><p>域名的话腾讯名购买的，考虑到续费比较贵，购买时应尽量选择年限长一点，会比较合算，阿里云的线上备案机制还是比较完善的，照着填就好</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454177.png" alt="备案说明"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454052.png" alt="备案信息填写"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454053.png" alt="阿里云APP上传证件信息"></p><blockquote><p>备案信息提交后，<code>阿里云客服</code>会初审，电话回访确认信息以及让提供视频备案承诺信息，提交给<code>工信部</code>后，工信部会发信息验证码，要求进行核验，完成后提交<code>通管局</code></p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454054.png" alt="初审材料"></p><blockquote><p><a href="https://beian.miit.gov.cn/">工业和信息化部政务服务平台</a></p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454264.png" alt="工信部短信核验"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454055.png" alt="核验完成"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454144.png" alt="提交通管局"></p><blockquote><p>不过实际管局审核后未进行电话核实，差不对一周的时间，直接发消息提醒备案通过</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210803005813651.png" alt="image-20210803005813651"></p><blockquote><p>然后就是安装个面板，干起运维的活，这里用的<a href="https://www.bt.cn/">宝塔面板</a>，体验还不错</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454213.png" alt="宝塔面板安装"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454214.png"></p><blockquote><p>注意：这里也有可能你进不去面板页面，是因为服务器没有开8888这个端口（具体看宝塔面板连接的端口），去阿里云轻量服务器控制台中的“安全”-&gt;“防火墙”，右上角的”添加规则”，添加相应的端口即可。</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454154.png" alt="放行8888端口"></p><blockquote><p>这边的话安装完成，注册个BT账号绑定下，登录即可开启运维大业</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454215.png" alt="绑定宝塔账号"></p><h1 id="图床搭建"><a href="#图床搭建" class="headerlink" title="图床搭建"></a>图床搭建</h1><h2 id="图床简介"><a href="#图床简介" class="headerlink" title="图床简介"></a>图床简介</h2><blockquote><p>Markdown是博客的标配，写markdown肯定离不开图床，数据才是核心的东西，免费的说不定什么时候就暴毙了，微博图床和路过图床先pass，码云和github上当备份还行，作为主力图床可能加载速度有点勉强，排除这些，然后剩下的主流提供服务的厂商有阿里云OSS存储，七牛云存储，腾讯云对象存储，又拍云图床，认真思虑良久，还是白嫖七牛云使人快乐</p></blockquote><blockquote><p>注册登录七牛云，进入控制台找到添加对象存储，并新建一个存储空间用来作图床</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454220.png" alt="七牛云控制台"></p><h2 id="创建空间"><a href="#创建空间" class="headerlink" title="创建空间"></a>创建空间</h2><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454155.png" alt="自建空间"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454229.png" alt="上传文件测试"></p><h2 id="域名更换"><a href="#域名更换" class="headerlink" title="域名更换"></a>域名更换</h2><blockquote><p>到这里我们就可以在我们的博客引用外链，显示图片了，当然也可用于公众号。但是七牛云给我们使用这种链接的时间只有一个月，一个月之后就会回收域名</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454290.png" alt="CDN测试域名"></p><blockquote><p>所以用我们自己的二级域名来绑定七牛云进行访问（最好不用www开头的二级域名来绑定，因为www开头的域名，我们都是作为主域名的）</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454311.png" alt="添加备案的域名"></p><h2 id="配置CNAME"><a href="#配置CNAME" class="headerlink" title="配置CNAME"></a>配置CNAME</h2><blockquote><p>添加域名后会生成CNAME，拷贝到域名厂商处添加解析</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454255.png" alt="复制添加二级域名的CNAME"></p><h2 id="添加解析"><a href="#添加解析" class="headerlink" title="添加解析"></a>添加解析</h2><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454321.png" alt="添加解析"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454278.png" alt="域名解析说明"></p><h2 id="图床搭建完成"><a href="#图床搭建完成" class="headerlink" title="图床搭建完成"></a>图床搭建完成</h2><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454340.png"></p><h2 id="PicGo绑定七牛云图床"><a href="#PicGo绑定七牛云图床" class="headerlink" title="PicGo绑定七牛云图床"></a>PicGo绑定七牛云图床</h2><blockquote><p><a href="https://github.com/Molunerfinn/PicGo">PicGo</a>配好图床服务，搭配Typora，再搭配<a href="https://github.com/blinkfox/typora-vue-theme">Vue主题</a>，写Markdown体验极佳</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210803012716665.png"></p><blockquote><p>七牛云个人中心查看密钥</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454280.png" alt="七牛云个人中心查看密钥"></p><h1 id="本地Hexo搭建"><a href="#本地Hexo搭建" class="headerlink" title="本地Hexo搭建"></a>本地Hexo搭建</h1><h2 id="Hexo概览"><a href="#Hexo概览" class="headerlink" title="Hexo概览"></a>Hexo概览</h2><ul><li><p>使用hexo g将source文件夹下md文件渲染成静态HTML文件</p></li><li><p>在服务器远端也部署下git环境</p></li><li><p>hexo d将生成的静态文件push到远程仓库(这里指github和阿里云服务器上)</p></li><li><p>使用git-hooks实现自动部署，将仓库checkout到网站根目录</p></li><li><p>Nginx用做静态文件服务器，实现外界对博客的访问</p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454282.png"></p><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><blockquote><p>安装完<a href="https://nodejs.org/zh-cn/">nodejs</a>，node -v, npm -v查看下版本号</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454281.png" alt="nodejs安装"></p><blockquote><p>添加国内镜像源，这里选择使用阿里的国内镜像进行加速</p></blockquote><pre class="line-numbers language-none"><code class="language-none">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">$ npm install <span class="token operator">-</span>g hexo<span class="token operator">-</span>cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454439.png" alt="初始化Hexo"></p><ul><li>scaffolds是模版文件夹，当新建文章时，Hexo 会根据 scaffold 来建立文件</li><li>source文件夹是存放用户资源的地方</li><li>themes是主题文件夹，Hexo 会根据主题来生成静态页面</li></ul><blockquote><p>输入命令行进行本地调试，即可看到初始效果</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454440.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454537.png" alt="Hexo初始界面"></p><h2 id="更换主题为matery"><a href="#更换主题为matery" class="headerlink" title="更换主题为matery"></a>更换主题为matery</h2><blockquote><p>确保本地git环境部署好，使用<a href="https://github.com/blinkfox/hexo-theme-matery">matery</a> theme代替默认的landscape,这个hexo主题与前面提到的typora-vue-theme都是blinkfox大佬制作的，审美在我的点上</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454461.png" alt="clone matery 主题"></p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><blockquote><p>站点配置文件:根目录 config.yml ，主题配置文件: themes/config.yml</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603869841521.png" alt="修改theme名"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866455218.png" alt="初始界面"></p><h2 id="tags-页面"><a href="#tags-页面" class="headerlink" title="tags 页面"></a>tags 页面</h2><blockquote><p>tags页是用来展示所有标签的页面，如果博客source目录下还没有tags/index.md 文件，那么就需要新建一个</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>编辑刚刚新建的页面文件/source/tags/index.md，至少需要以下内容：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">--</span><span class="token operator">-</span>title<span class="token operator">:</span> tagsdate<span class="token operator">:</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">28</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">23</span><span class="token operator">:</span><span class="token number">38</span>type<span class="token operator">:</span> <span class="token string">"tags"</span>layout<span class="token operator">:</span> <span class="token string">"tags"</span><span class="token operator">--</span><span class="token operator">-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="categories-页面"><a href="#categories-页面" class="headerlink" title="categories 页面"></a>categories 页面</h2><blockquote><p>categories页是用来展示所有分类的页面，如果博客source目录下还没有 categories/index.md文件，那么就需要新建一个</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>编辑刚刚新建的页面文件/source/categories/index.md,至少需要以下内容：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">--</span><span class="token operator">-</span>title<span class="token operator">:</span> categoriesdate<span class="token operator">:</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">28</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">25</span><span class="token operator">:</span><span class="token number">30</span>type<span class="token operator">:</span> <span class="token string">"categories"</span>layout<span class="token operator">:</span> <span class="token string">"categories"</span><span class="token operator">--</span><span class="token operator">-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="about-页面"><a href="#about-页面" class="headerlink" title="about 页面"></a>about 页面</h2><blockquote><p>about页是用来展示关于我和我的博客信息的页面，如果博客source目录下还没有about/index.md文件，那么就需要新建一个</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">hexo new page <span class="token string">"about"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>编辑刚刚新建的页面文件/source/about/index.md，至少需要以下内容：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">--</span><span class="token operator">-</span>title<span class="token operator">:</span> aboutdate<span class="token operator">:</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">28</span> <span class="token number">17</span><span class="token operator">:</span><span class="token number">25</span><span class="token operator">:</span><span class="token number">30</span>type<span class="token operator">:</span> <span class="token string">"about"</span>layout<span class="token operator">:</span> <span class="token string">"about"</span><span class="token operator">--</span><span class="token operator">-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当然上面提到的这些通过手动创建也是可以的</p></blockquote><h2 id="菜单导航配置"><a href="#菜单导航配置" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h2><h3 id="名称、路径和图标"><a href="#名称、路径和图标" class="headerlink" title="名称、路径和图标"></a>名称、路径和图标</h3><ul><li>菜单导航名称可以是中文也可以是英文(如：Index或主页)</li><li>图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">menu<span class="token operator">:</span>  Index<span class="token operator">:</span>    url<span class="token operator">:</span> <span class="token operator">/</span>    icon<span class="token operator">:</span> fas fa<span class="token operator">-</span>home  Tags<span class="token operator">:</span>    url<span class="token operator">:</span> <span class="token operator">/</span>tags    icon<span class="token operator">:</span> fas fa<span class="token operator">-</span>tags  Categories<span class="token operator">:</span>    url<span class="token operator">:</span> <span class="token operator">/</span>categories    icon<span class="token operator">:</span> fas fa<span class="token operator">-</span>bookmark  Archives<span class="token operator">:</span>    url<span class="token operator">:</span> <span class="token operator">/</span>archives    icon<span class="token operator">:</span> fas fa<span class="token operator">-</span>archive  About<span class="token operator">:</span>    url<span class="token operator">:</span> <span class="token operator">/</span>about    icon<span class="token operator">:</span> fas fa<span class="token operator">-</span>user<span class="token operator">-</span>circle<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二级菜单配置"><a href="#二级菜单配置" class="headerlink" title="二级菜单配置"></a>二级菜单配置</h3><p>如果需要二级菜单，则可以在原基本菜单导航的基础上如下操作</p><ul><li>在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children)</li><li>在children下创建二级菜单的 名称name,路径url和图标icon.</li><li>注意每个二级菜单模块前要加 -.</li><li>注意缩进格式</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><blockquote><p>由于 Hexo 自带的代码高亮略显平庸，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">npm i <span class="token operator">-</span>S hexo<span class="token operator">-</span>prism<span class="token operator">-</span>plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>修改 Hexo 根目录下_config.yml文件中highlight.enable的值为 false，并新增prism插件相关的配置，主要配置如下：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">prism_plugin<span class="token operator">:</span>  mode<span class="token operator">:</span> <span class="token string">'preprocess'</span> # realtime<span class="token operator">/</span>preprocess  theme<span class="token operator">:</span> <span class="token string">'tomorrow'</span>  line_number<span class="token operator">:</span> true #<span class="token keyword">default</span> false  custom_css<span class="token operator">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><blockquote><p>使用hexo-generator-search](<a href="https://github.com/wzpan/hexo-generator-search">https://github.com/wzpan/hexo-generator-search</a>) 插件来做内容搜索</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">npm install hexo<span class="token operator">-</span>generator<span class="token operator">-</span>search <span class="token operator">--</span>save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在 Hexo 根目录下的_config.yml文件中，新增以下的配置项：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">search<span class="token operator">:</span>  path<span class="token operator">:</span> search<span class="token punctuation">.</span>xml  field<span class="token operator">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="文章字数统计"><a href="#文章字数统计" class="headerlink" title="文章字数统计"></a>文章字数统计</h3><blockquote><p>安装<a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件，在文章中显示文章字数、阅读时长信息</p></blockquote><pre class="line-numbers language-none"><code class="language-none">npm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>需要在本主题下的_config.yml 文件中，激活以下配置项</p></blockquote><pre class="line-numbers language-none"><code class="language-none">postInfo:  date: false # 发布日期  update: false # 更新日期  wordCount: true # 文章字数统计  totalCount: true # 站点总文章字数  min2read: true # 文章阅读时长  readCount: true # 文章阅读次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JS特效"><a href="#JS特效" class="headerlink" title="JS特效"></a>JS特效</h2><blockquote><p>HTML + CSS齐活了，肯定不能少了JS的身影</p></blockquote><h3 id="添加雪花飘落效果"><a href="#添加雪花飘落效果" class="headerlink" title="添加雪花飘落效果"></a>添加雪花飘落效果</h3><blockquote><p>在themes/matery/source/js目录下新建snow.js文件</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&#x2F;*样式一*&#x2F;(function($)&#123;    $.fn.snow &#x3D; function(options)&#123;    var $flake &#x3D; $(&#39;&lt;div id&#x3D;&quot;snowbox&quot; &#x2F;&gt;&#39;).css(&#123;&#39;position&#39;: &#39;absolute&#39;,&#39;z-index&#39;:&#39;9999&#39;, &#39;top&#39;: &#39;-50px&#39;&#125;).html(&#39;&amp;#10052;&#39;),    documentHeight     &#x3D; $(document).height(),    documentWidth    &#x3D; $(document).width(),    defaults &#x3D; &#123;        minSize        : 10,        maxSize        : 20,        newOn        : 1000,        flakeColor    : &quot;#AFDAEF&quot; &#x2F;* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF *&#x2F;    &#125;,    options    &#x3D; $.extend(&#123;&#125;, defaults, options);    var interval&#x3D; setInterval( function()&#123;    var startPositionLeft &#x3D; Math.random() * documentWidth - 100,    startOpacity &#x3D; 0.5 + Math.random(),    sizeFlake &#x3D; options.minSize + Math.random() * options.maxSize,    endPositionTop &#x3D; documentHeight - 200,    endPositionLeft &#x3D; startPositionLeft - 500 + Math.random() * 500,    durationFall &#x3D; documentHeight * 10 + Math.random() * 5000;    $flake.clone().appendTo(&#39;body&#39;).css(&#123;        left: startPositionLeft,        opacity: startOpacity,        &#39;font-size&#39;: sizeFlake,        color: options.flakeColor    &#125;).animate(&#123;        top: endPositionTop,        left: endPositionLeft,        opacity: 0.2    &#125;,durationFall,&#39;linear&#39;,function()&#123;        $(this).remove()    &#125;);    &#125;, options.newOn);    &#125;;&#125;)(jQuery);$(function()&#123;    $.fn.snow(&#123;        minSize: 5, &#x2F;* 定义雪花最小尺寸 *&#x2F;        maxSize: 50,&#x2F;* 定义雪花最大尺寸 *&#x2F;        newOn: 300  &#x2F;* 定义密集程度，数字越小越密集 *&#x2F;    &#125;);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在themes/matery/layout/layout.ejs文件内加下</p></blockquote><script src="/js/snow.js"></script><h3 id="鼠标点击文字特效"><a href="#鼠标点击文字特效" class="headerlink" title="鼠标点击文字特效"></a>鼠标点击文字特效</h3><p>在themes/matery/source/js目录下新建click_show_text.js文件</p><pre class="line-numbers language-none"><code class="language-none">var a_idx &#x3D; 0;jQuery(document).ready(function ($) &#123;    $(&quot;body&quot;).click(function (e) &#123;        var a &#x3D; new Array(&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;, &quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;);        var $i &#x3D; $(&quot;&lt;span&#x2F;&gt;&quot;).text(a[a_idx]);        a_idx &#x3D; (a_idx + 1) % a.length;        var x &#x3D; e.pageX,            y &#x3D; e.pageY;        $i.css(&#123;            &quot;z-index&quot;: 5,            &quot;top&quot;: y - 20,            &quot;left&quot;: x,            &quot;position&quot;: &quot;absolute&quot;,            &quot;font-weight&quot;: &quot;bold&quot;,            &quot;color&quot;: &quot;#FF0000&quot;        &#125;);        $(&quot;body&quot;).append($i);        $i.animate(&#123;                &quot;top&quot;: y - 180,                &quot;opacity&quot;: 0            &#125;,            3000,            function () &#123;                $i.remove();            &#125;);    &#125;);    setTimeout(&#39;delay()&#39;, 2000);&#125;); function delay() &#123;    $(&quot;.buryit&quot;).removeAttr(&quot;onclick&quot;);&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在themes/matery/layout/layout.ejs文件内添加下面的内容：</p></blockquote><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;script src&#x3D;&quot;&#x2F;js&#x2F;click_show_text.js&quot;&gt;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="鼠标彩虹星星掉落"><a href="#鼠标彩虹星星掉落" class="headerlink" title="鼠标彩虹星星掉落"></a>鼠标彩虹星星掉落</h3><blockquote><p>添加鼠标彩虹星星掉落跟随效果</p></blockquote><p>在themes/matery/source/js目录下新建cursor.js文件</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*!* Fairy Dust Cursor.js* - 90&#39;s cursors collection* -- https:&#x2F;&#x2F;github.com&#x2F;tholman&#x2F;90s-cursor-effects* -- http:&#x2F;&#x2F;codepen.io&#x2F;tholman&#x2F;full&#x2F;jWmZxZ&#x2F;*&#x2F; &#x2F;&#x2F;鼠标点击雪花特效(function fairyDustCursor() &#123;   var possibleColors &#x3D; [&quot;#D61C59&quot;, &quot;#E7D84B&quot;, &quot;#1B8798&quot;]  var width &#x3D; window.innerWidth;  var height &#x3D; window.innerHeight;  var cursor &#x3D; &#123;x: width&#x2F;2, y: width&#x2F;2&#125;;  var particles &#x3D; [];   function init() &#123;    bindEvents();    loop();  &#125;   &#x2F;&#x2F; Bind events that are needed  function bindEvents() &#123;    document.addEventListener(&#39;mousemove&#39;, onMouseMove);    document.addEventListener(&#39;touchmove&#39;, onTouchMove);    document.addEventListener(&#39;touchstart&#39;, onTouchMove);     window.addEventListener(&#39;resize&#39;, onWindowResize);  &#125;   function onWindowResize(e) &#123;    width &#x3D; window.innerWidth;    height &#x3D; window.innerHeight;  &#125;   function onTouchMove(e) &#123;    if( e.touches.length &gt; 0 ) &#123;      for( var i &#x3D; 0; i &lt; e.touches.length; i++ ) &#123;        addParticle( e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random()*possibleColors.length)]);      &#125;    &#125;  &#125;   function onMouseMove(e) &#123;      cursor.x &#x3D; e.clientX;    cursor.y &#x3D; e.clientY;     addParticle( cursor.x, cursor.y, possibleColors[Math.floor(Math.random()*possibleColors.length)]);  &#125;   function addParticle(x, y, color) &#123;    var particle &#x3D; new Particle();    particle.init(x, y, color);    particles.push(particle);  &#125;   function updateParticles() &#123;     &#x2F;&#x2F; Updated    for( var i &#x3D; 0; i &lt; particles.length; i++ ) &#123;      particles[i].update();    &#125;     &#x2F;&#x2F; Remove dead particles    for( var i &#x3D; particles.length -1; i &gt;&#x3D; 0; i-- ) &#123;      if( particles[i].lifeSpan &lt; 0 ) &#123;        particles[i].die();        particles.splice(i, 1);      &#125;    &#125;   &#125;   function loop() &#123;    requestAnimationFrame(loop);    updateParticles();  &#125;   &#x2F;**   * Particles   *&#x2F;   function Particle() &#123;     this.character &#x3D; &quot;*&quot;;    this.lifeSpan &#x3D; 120; &#x2F;&#x2F;ms    this.initialStyles &#x3D;&#123;      &quot;position&quot;: &quot;fixed&quot;,      &quot;top&quot;: &quot;0&quot;, &#x2F;&#x2F;必须加      &quot;display&quot;: &quot;block&quot;,      &quot;pointerEvents&quot;: &quot;none&quot;,      &quot;z-index&quot;: &quot;10000000&quot;,      &quot;fontSize&quot;: &quot;20px&quot;,      &quot;will-change&quot;: &quot;transform&quot;    &#125;;     &#x2F;&#x2F; Init, and set properties    this.init &#x3D; function(x, y, color) &#123;       this.velocity &#x3D; &#123;        x:  (Math.random() &lt; 0.5 ? -1 : 1) * (Math.random() &#x2F; 2),        y: 1      &#125;;       this.position &#x3D; &#123;x: x - 10, y: y - 20&#125;;      this.initialStyles.color &#x3D; color;      console.log(color);       this.element &#x3D; document.createElement(&#39;span&#39;);      this.element.innerHTML &#x3D; this.character;      applyProperties(this.element, this.initialStyles);      this.update();       document.body.appendChild(this.element);    &#125;;     this.update &#x3D; function() &#123;      this.position.x +&#x3D; this.velocity.x;      this.position.y +&#x3D; this.velocity.y;      this.lifeSpan--;       this.element.style.transform &#x3D; &quot;translate3d(&quot; + this.position.x + &quot;px,&quot; + this.position.y + &quot;px,0) scale(&quot; + (this.lifeSpan &#x2F; 120) + &quot;)&quot;;    &#125;     this.die &#x3D; function() &#123;      this.element.parentNode.removeChild(this.element);    &#125;   &#125;   &#x2F;**   * Utils   *&#x2F;   &#x2F;&#x2F; Applies css &#96;properties&#96; to an element.  function applyProperties( target, properties ) &#123;    for( var key in properties ) &#123;      target.style[ key ] &#x3D; properties[ key ];    &#125;  &#125;   init();&#125;)();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在themes/matery/layout/layout.ejs文件内添加如下</p></blockquote><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;script src&#x3D;&quot;&#x2F;js&#x2F;cursor.js&quot;&gt;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置音乐播放器"><a href="#配置音乐播放器" class="headerlink" title="配置音乐播放器"></a>配置音乐播放器</h2><blockquote><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件</p></blockquote><blockquote><p>首先，在博客source目录下的_data目录（没有的话就新建一个）中新建 musics.json文件，文件内容如下所示：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">[&#123; &quot;name&quot;: &quot;五月雨变奏电音&quot;,   &quot;artist&quot;: &quot;AnimeVibe&quot;,   &quot;url&quot;: &quot;http:&#x2F;&#x2F;xxx.com&#x2F;music1.mp3&quot;,   &quot;cover&quot;: &quot;http:&#x2F;&#x2F;xxx.com&#x2F;music-cover1.png&quot;&#125;, &#123;  &quot;name&quot;: &quot;Take me hand&quot;,  &quot;artist&quot;: &quot;DAISHI DANCE,Cecile Corbel&quot;,  &quot;url&quot;: &quot;&#x2F;medias&#x2F;music&#x2F;music2.mp3&quot;,  &quot;cover&quot;: &quot;&#x2F;medias&#x2F;music&#x2F;cover2.png&quot;&#125;, &#123;   &quot;name&quot;: &quot;Shape of You&quot;,   &quot;artist&quot;: &quot;J.Fla&quot;,   &quot;url&quot;: &quot;http:&#x2F;&#x2F;xxx.com&#x2F;music3.mp3&quot;,   &quot;cover&quot;: &quot;http:&#x2F;&#x2F;xxx.com&#x2F;music-cover3.png&quot;&#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：以上 JSON 中的属性：name、artist、url、cover 分别表示音乐的名称、作者、音乐文件地址、音乐封面。<br>然后，在主题的_config.yml配置文件中激活配置即可</p><h1 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h1><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><pre class="line-numbers language-none"><code class="language-none">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><pre class="line-numbers language-none"><code class="language-none">yum install gcc perl-ExtUtils-MakeMaker package<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看git的版本"><a href="#查看git的版本" class="headerlink" title="查看git的版本"></a>查看git的版本</h2><pre class="line-numbers language-none"><code class="language-none">git version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除git"><a href="#删除git" class="headerlink" title="删除git"></a>删除git</h2><pre class="line-numbers language-none"><code class="language-none">yum remove git -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="下载解压最新版"><a href="#下载解压最新版" class="headerlink" title="下载解压最新版"></a>下载解压最新版</h2><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;usr&#x2F;local&#x2F;src    #下载的目录wget https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;software&#x2F;scm&#x2F;git&#x2F;git-2.28.0.tar.gz    #下载最新版tar -zxvf git-2.28.0.tar.gz        #解压到当前文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="编译源码并安装"><a href="#编译源码并安装" class="headerlink" title="编译源码并安装"></a>编译源码并安装</h2><pre class="line-numbers language-none"><code class="language-none">cd git-2.28.0    #进入文件夹make prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git all    #编译源码make prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git install    #安装路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="配置git的环境变量"><a href="#配置git的环境变量" class="headerlink" title="配置git的环境变量"></a>配置git的环境变量</h2><pre class="line-numbers language-none"><code class="language-none">echo &#39;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;git&#x2F;bin&#39; &gt;&gt; &#x2F;etc&#x2F;bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="刷新环境变量"><a href="#刷新环境变量" class="headerlink" title="刷新环境变量"></a>刷新环境变量</h2><pre class="line-numbers language-none"><code class="language-none">source &#x2F;etc&#x2F;bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h2><pre class="line-numbers language-none"><code class="language-none">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="创建用户并修改权限"><a href="#创建用户并修改权限" class="headerlink" title="创建用户并修改权限"></a>创建用户并修改权限</h2><pre class="line-numbers language-none"><code class="language-none">adduser holypasswd holychmod 740 &#x2F;etc&#x2F;sudoersvim &#x2F;etc&#x2F;sudoers root    ALL&#x3D;(ALL)       ALLholy     ALL&#x3D;(ALL)       ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454462.png" alt="vim编辑保存"></p><h2 id="改回权限"><a href="#改回权限" class="headerlink" title="改回权限"></a>改回权限</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">chmod <span class="token number">400</span> <span class="token operator">/</span>etc<span class="token operator">/</span>sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="设置holy账户密码"><a href="#设置holy账户密码" class="headerlink" title="设置holy账户密码"></a>设置holy账户密码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">sudo passwd holy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>输入两次密码，不可见</p></blockquote><h2 id="打通SSH"><a href="#打通SSH" class="headerlink" title="打通SSH"></a>打通SSH</h2><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>切换至holy用户，创建 ~/.ssh文件夹和 ~/.ssh/authorized_key文件，并赋予相应的权限</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">su holymkdir <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>sshvim <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span class="token operator">/</span>authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>接着将win10中生成的id_rsa.pub文件中的公钥复制到authorized_keys中</p></blockquote><h2 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">chmod <span class="token number">600</span> <span class="token operator">/</span>home<span class="token operator">/</span>holy<span class="token operator">/</span><span class="token punctuation">.</span>ssh<span class="token operator">/</span>authorized_keyschmod <span class="token number">700</span> <span class="token operator">/</span>home<span class="token operator">/</span>holy<span class="token operator">/</span><span class="token punctuation">.</span>ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="本地登录"><a href="#本地登录" class="headerlink" title="本地登录"></a>本地登录</h2><blockquote><p>在本地Git终端中测试是否能免密登录git，其中SERVER为填写自己的云主机IP，执行输入yes后输入之前配置的git密码，无报错就说明好了</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454489.png" alt="远程登录"></p><h2 id="集成到Windows-Terminal中"><a href="#集成到Windows-Terminal中" class="headerlink" title="集成到Windows Terminal中"></a>集成到Windows Terminal中</h2><blockquote><p>Windwos Terminal 可以开多个窗口，也不断开源维护更新，搭配主题美化下还是很优秀的，所以这里在Windows Terminal配置文件集成下，另外不得不说的是，自从微软收购github以来，生产力工具真的越做越好，VSOCDE、Visual Studio都是开发必备，WSL体验也极佳</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454441.png" alt="配置setting.json"></p><h1 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h1><h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><blockquote><p>在var目录下创建repo作为Git仓库目录，返回服务端命令行切换到root账户，然后输入</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">mkdir <span class="token operator">/</span>var<span class="token operator">/</span>repo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="赋予权限："><a href="#赋予权限：" class="headerlink" title="赋予权限："></a>赋予权限：</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">chown <span class="token operator">-</span>R holy<span class="token operator">:</span>holy <span class="token operator">/</span>var<span class="token operator">/</span>repochmod <span class="token operator">-</span>R <span class="token number">755</span> <span class="token operator">/</span>var<span class="token operator">/</span>repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="创建站点目录"><a href="#创建站点目录" class="headerlink" title="创建站点目录"></a>创建站点目录</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">mkdir <span class="token operator">/</span>var<span class="token operator">/</span>hexochown <span class="token operator">-</span>R holy<span class="token operator">:</span>holy <span class="token operator">/</span>var<span class="token operator">/</span>hexochmod <span class="token operator">-</span>R <span class="token number">755</span> <span class="token operator">/</span>var<span class="token operator">/</span>hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="初始化远程仓库"><a href="#初始化远程仓库" class="headerlink" title="初始化远程仓库"></a>初始化远程仓库</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">cd <span class="token operator">/</span>var<span class="token operator">/</span>repogit init <span class="token operator">--</span>bare hexo<span class="token punctuation">.</span>git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="创建新的-Git-钩子"><a href="#创建新的-Git-钩子" class="headerlink" title="创建新的 Git 钩子"></a>创建新的 Git 钩子</h3><blockquote><p>在 /var/repo/hexo.git 下，有一个自动生成的 hooks 文件夹，需要在里边新建一个新的钩子文件 post-receive，用于自动部署</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">vim <span class="token operator">/</span>var<span class="token operator">/</span>repo<span class="token operator">/</span>hexo<span class="token punctuation">.</span>git<span class="token operator">/</span>hooks<span class="token operator">/</span>post<span class="token operator">-</span>receive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">!</span><span class="token operator">/</span>bin<span class="token operator">/</span>bashgit <span class="token operator">--</span>work<span class="token operator">-</span>tree<span class="token operator">=</span><span class="token operator">/</span>var<span class="token operator">/</span>hexo <span class="token operator">--</span>git<span class="token operator">-</span>dir<span class="token operator">=</span><span class="token operator">/</span>var<span class="token operator">/</span>repo<span class="token operator">/</span>hexo<span class="token punctuation">.</span>git checkout <span class="token operator">-</span>f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">chown <span class="token operator">-</span>R holy<span class="token operator">:</span>holy <span class="token operator">/</span>var<span class="token operator">/</span>repo<span class="token operator">/</span>hexo<span class="token punctuation">.</span>git<span class="token operator">/</span>hooks<span class="token operator">/</span>post<span class="token operator">-</span>receivechmod <span class="token operator">+</span>x <span class="token operator">/</span>var<span class="token operator">/</span>repo<span class="token operator">/</span>hexo<span class="token punctuation">.</span>git<span class="token operator">/</span>hooks<span class="token operator">/</span>post<span class="token operator">-</span>receive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h1><blockquote><p>在本地浏览器端输入宝塔面板地址，进入服务器运维管理界面，安装Nginx</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454490.png"></p><h1 id="添加站点"><a href="#添加站点" class="headerlink" title="添加站点"></a>添加站点</h1><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454530.png"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454536.png" alt="修改配置文件"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603866454488.png" alt="修改网站目录"></p><blockquote><p>回到服务器终端，重启宝塔服务，使之生效</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">service bt restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="本地博客发布"><a href="#本地博客发布" class="headerlink" title="本地博客发布"></a>本地博客发布</h1><blockquote><p>首先需要安装发布的插件，在博客目录下执行hexo d部署到远端仓库，可以添加多个仓库，一般github会留个备份</p></blockquote><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603947984141.png" alt="配置远程仓库"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603950593052.png" alt="hexo g -d推到远程仓库"></p><h1 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h1><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603954833564.png"></p><blockquote><p>既然要支持全站https，那必不可少的是申请证书了，因为域名是在腾讯云买的，所以是直接在腾讯云管理平台申请的ssl证书，选择自动验证十分钟左右就把证书颁发下来了，直接点击下载证书，解压之后会有四个文件夹，因为用的Nginx，所以只需要Nginx文件夹下面的bundle.crt和.key两个文件，至于外层的csr不需要用到</p></blockquote><blockquote><p>由于七牛云图床https流量要计费，所以博客站点还是采用http吧，后续有相关博客美化再更新！</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603955297630.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>拆开来看，技术上没什么难点，主要还是框架和服务的选择，Wordpress、Hexo、Typecho都是比较流行的博客框架，图床服务和Markdown编辑器的选择也很丰富，重点还是要有自己的思路，将记录积累的活整合到适合自己的个性化学习工作流程中，形成习惯，博客只是恰好能提供这样一个持续的反馈</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器，域名，图床，markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UEFI BIOS启动流程</title>
      <link href="2021/08/03/UEFI%20BIOS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>2021/08/03/UEFI%20BIOS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="UEFI-BIOS启动流程"><a href="#UEFI-BIOS启动流程" class="headerlink" title="UEFI BIOS启动流程"></a>UEFI BIOS启动流程</h1><blockquote><p>EFI系统表是UEFI 规范定义的最重要的数据结构，它的指针会被当作入口参数传递给每个驱动和应用程序， 进而驱动和应用程序就可以从这个数据结构得到系统的配置信息和丰富的系统服务</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">///</span><span class="token comment">/// EFI System Table</span><span class="token comment">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>  <span class="token comment">///</span>  <span class="token comment">/// The table header for the EFI System Table.</span>  <span class="token comment">///</span>  EFI_TABLE_HEADER                  Hdr<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// A pointer to a null terminated string that identifies the vendor</span>  <span class="token comment">/// that produces the system firmware for the platform.</span>  <span class="token comment">///</span>  CHAR16                            <span class="token operator">*</span>FirmwareVendor<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// A firmware vendor specific value that identifies the revision</span>  <span class="token comment">/// of the system firmware for the platform.</span>  <span class="token comment">///</span>  UINT32                            FirmwareRevision<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// The handle for the active console input device. This handle must support</span>  <span class="token comment">/// EFI_SIMPLE_TEXT_INPUT_PROTOCOL and EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL.</span>  <span class="token comment">///</span>  EFI_HANDLE                        ConsoleInHandle<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// A pointer to the EFI_SIMPLE_TEXT_INPUT_PROTOCOL interface that is</span>  <span class="token comment">/// associated with ConsoleInHandle.</span>  <span class="token comment">///</span>  EFI_SIMPLE_TEXT_INPUT_PROTOCOL    <span class="token operator">*</span>ConIn<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// The handle for the active console output device.</span>  <span class="token comment">///</span>  EFI_HANDLE                        ConsoleOutHandle<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// A pointer to the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL interface</span>  <span class="token comment">/// that is associated with ConsoleOutHandle.</span>  <span class="token comment">///</span>  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL   <span class="token operator">*</span>ConOut<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// The handle for the active standard error console device.</span>  <span class="token comment">/// This handle must support the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.</span>  <span class="token comment">///</span>  EFI_HANDLE                        StandardErrorHandle<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// A pointer to the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL interface</span>  <span class="token comment">/// that is associated with StandardErrorHandle.</span>  <span class="token comment">///</span>  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL   <span class="token operator">*</span>StdErr<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// A pointer to the EFI Runtime Services Table.</span>  <span class="token comment">///</span>  EFI_RUNTIME_SERVICES              <span class="token operator">*</span>RuntimeServices<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// A pointer to the EFI Boot Services Table.</span>  <span class="token comment">///</span>  EFI_BOOT_SERVICES                 <span class="token operator">*</span>BootServices<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// The number of system configuration tables in the buffer ConfigurationTable.</span>  <span class="token comment">///</span>  UINTN                             NumberOfTableEntries<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// A pointer to the system configuration tables.</span>  <span class="token comment">/// The number of entries in the table is NumberOfTableEntries.</span>  <span class="token comment">///</span>  EFI_CONFIGURATION_TABLE           <span class="token operator">*</span>ConfigurationTable<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> EFI_SYSTEM_TABLE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/image-20210620011215626.png"></p><ul><li><p>EFI 系统表中的启动时服务只在操作系统运行时之前是可用的， 而运行时服务则在操作系统运行时之前和操作系统运行时都是可用的</p></li><li><p>UEFI 规范定义的Handle 数据库是UEFI 需要维护的最重要的对象库，由Handle 和协议(Protocol)组成。 这个Handle 数据库是所有的UEFI Handle 的列表， 每个Handle 上可以挂载一个或者多个协议</p></li><li><p> 协议是GUID（Globally Unique Identifier， 全局唯一标识符）来命名并唯一标识的结构体， 可能包含一些函数指针和数据结构体，即用面向对象的C Struct模拟Class实现OOP，最小的协议可以只定义GUID，而不包含任何函数指针或者数据结构体。 换句话说， GUID 是一个协议必须要定义的</p></li><li><p>协议通过挂载在Handle 上来进行使用， 跟Handle 一起存放在Handle 数据库中。 系统中的其他函数通过GUID 在Handle 数据库中查找对应的协议</p></li><li><p>Handle和Protocol的数据结构实质表征是双向环链表， UEFI 的可扩展特性很大程度上就体现在协议上</p></li></ul><p><strong>基于UEFI和PI规范实现的UEFI BIOS启动流程如下：</strong></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/image-20210620011020584.png"></p><p>按照启动先后顺序， 该流程分为以下7个阶段：</p><ul><li>1） 安全检测(SEC， Security)阶段</li><li>2） EFI初始化准备(PEI， Pre-EFI Initialization)阶段</li><li>3） 驱动程序执行环境(DXE， Driver Execution Environment)阶段</li><li>4） 启动设备选择(BDS， Boot Device Selection)阶段</li><li>5） 瞬时系统加载(TSL， Transient System Load)阶段</li><li>6） 运行时(RT， Run Tim e)阶段</li><li>7） 生命周期后(AL， After Life)阶段</li></ul><h2 id="安全检测-SEC-阶段"><a href="#安全检测-SEC-阶段" class="headerlink" title="安全检测(SEC)阶段"></a>安全检测(SEC)阶段</h2><ul><li><p>在X86的计算机系统上， 系统开机，硬件电路重置寄存器的值(ResetVector) ，CPU从4GB的最高端地址FFFFFFF0h开始执行指令(映射到Nor Flash上的BIOS芯片)</p></li><li><p>ResetVector组件会被打包成一个固件文件系统(FFS， Firmware File System)高文件卷文件(VTF， Volume Top File)，它负责找到和执行SecCore(SECURITY CORE)模块 </p></li><li><p>SecCore模块会进行基本的系统初始化、 为CPU打微码补丁、 初始化CAR(Cache As RAM)、 切换到保护模式、 获取启动固件卷(BFV， Boot Firmware Volume)的地址和找到PeiCore(PEI_CORE)及其入口地址以准备进入PEI阶段</p></li><li><p>在CAR被初始化好之前， 系统没有内存来作为堆栈使用， ResetVector组件和SecCore模块的代码采用汇编实现； 在CAR被初始化好之后， 一小块CPU cache空间将被当作临时内存(temporary memory)来使用， SecCore模块会进入C语言执行环境 </p></li><li><p>SecCore 模块利用获取的启动固件卷地址和初始化了的CAR 来给EFI_SEC_PEI_HAND_OFF中的启动固件卷地址和大小、 临时内存地址和大小、PEI 临时内存地址和大小以及栈地址和大小域赋值， 最后把EFI_SEC_PEI_HAND_OFF与SEC阶段提供的PpiList一起传递给PeiCore， 从而进入PEI阶段</p></li><li><p>SEC阶段提供的PpiList 可能会包含安全或者验证服务， 如TCG(Trusted Computing Group)访问服务， 因为在一个遵循TCG的系统中， SEC就是可信度量根的核心(CRTM， Core Root-of-Trust Measurement)</p></li></ul><h2 id="EFI-初始化准备-PEI-阶段"><a href="#EFI-初始化准备-PEI-阶段" class="headerlink" title="EFI 初始化准备(PEI)阶段"></a>EFI 初始化准备(PEI)阶段</h2><blockquote><p>PEI阶段的主要任务是决定系统的启动路径（正常启动、 S3唤醒或者Recovery等)，初始化各种平台硬件， 包括CPU和芯片组等，检测和初始化系统内存，报告和处理DXE固件卷，最后找到DxeCore(DXE_CORE)及其入口地址以进入DXE阶段</p></blockquote><ul><li><p>PeiCore(PEI_CORE)首先会对PEI的基础服务（如内存、 HOB、 PPI和FV服务等）进行初始化</p></li><li><p>接着PEI调度器开始利用FV服务根据固件文件系统的格式从启动固件卷查找PEI模块， 检查它们的依赖关系(dependency expression)是否已经满足， 进而执行PEI模块， PEI模块可能会产生PPI为其它PEI模块提供服务， DxeIpl PEI模块会产生DxeIpl PPI</p></li><li><p>内存初始化模块在检测和初始化系统内存之后会通过PEI的基础服务InstallPeiMemory来向PeiCore报告PEI阶段可用的常驻内存(permanent memory)和建立Resource HOB来报告系统内存</p></li><li><p>接着PeiCore将会迁移PEI正在使用的临时内存（包括栈(stack)和堆(heap)， HOB列表就在堆中）里面的所有数据到常驻内存中去， 以及产生MemoryDiscovered PPI来通知其它所有依赖于系统内存的PEI模块， 让它们知道系统内存可以使用了</p></li><li><p>然后其它PEI模块通过PEI基础服务NotifyPpi注册的MemoryDiscovered PPI回调函数(callback)就会被执行， 如平台PEI模块注册的MemoryDiscovered PPI回调函数可能会设置系统内存的缓存属性和通过产生FvInfo PPI来报告DXE固件卷</p><p><strong>PEI阶段的内存映射和使用如下：</strong></p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/image-20210620012406859.png"></p><ul><li><p>PEI调度器在执行完所有的PEI模块之后会调用DxeIpl PPI， 接着DxeIpl PPI就会从DXE固件卷中找到DxeCore及其入口地址， 最后把PEI阶段建立的HOB列表传递给DxeCore， 从而进入DXE阶段</p></li><li><p>在X86的计算机系统上， 如果DXE阶段为64位， DxeIpl PPI在执行DxeCore之前还需要建立页表(page table)和切换CPU到IA32e模式(long mode)</p></li><li><p>PEI阶段建立的HOB列表如下图所示， 开始的一个HOB必须是PHIT(Phase Handoff Information Table) HOB， 最后一个HOB必须是end of list HOB</p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/image-20210620011130677.png"></p><h2 id="驱动程序执行环境-DXE-阶段"><a href="#驱动程序执行环境-DXE-阶段" class="headerlink" title="驱动程序执行环境(DXE)阶段"></a>驱动程序执行环境(DXE)阶段</h2><ul><li><p>DXE阶段包含的组件： DXE Foundation、 DXE调度器和DXE驱动程序，DXE阶段的主要任务是生成一套完整的UEFI接口， 和后续的BDS阶段一起工作， 建立控制台并尝试启动操作系统</p></li><li><p>DXE阶段是UEFI BIOS最重要的阶段DxeCore(DXE_CORE)首先会初始化启动时服务表、 运行时服务表和DXE服务表， 利用PEI阶段传递过来的HOB列表中的Resource HOB初始化DXE服务表中的GCD(Global Coherency Domain)服务以及启动时服务表中的内存服务，基于HOB列表中的FV HOB产生FVB协议及FV协议 </p></li><li><p>DxeCore还会把DXE服务表和HOB列表安装到EFI系统表的配置表(ConfigurationTable)中。接着DXE调度器会开始利用FV协议根据固件文件系统的格式从DXE固件卷查找DXE驱动，检查它们的依赖关系是否已经满足， 进而执行DXE驱动</p></li><li><p>DXE驱动有两类： 较早执行的DXE驱动和UEFI驱动（符合UEFI驱动模型的DXE驱动）。 较早执行的DXE驱动程序会初始化平台硬件， 包括CPU和芯片组等， 安装配置表（如ACPI Table和SMBIOS Table就会被相应的DXE驱动安装到配置表中）和产生架构协议（例如DXE Variable驱动就会产生Variable架构协议和Variable Write架构协议， BDS驱动会产生BDS架构协议）等 </p></li><li><p>如下图所示DXE阶段产生的架构协议， 架构协议基本上与EFI系统表中的启动时服务和运行时服务相对应。 UEFI驱动在所有的架构协议产生之后才会被执行， 它们会产生Driver Binding协议， 这些Driver Binding协议在BDS阶段连接控制器（利用启动时服务表中的ConnectController接口）的时候会被连接， 进而为控制台和启动设备提供软件抽象</p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/image-20210620011449280.png"></p><ul><li>DXE阶段会生成一套完整的UEFI接口， DXE调度器在执行完所有的DXE驱动之后会调用BDS架构协议， 从而进入BDS阶段， DXE阶段和BDS阶段一起工作来建立可供操作系统启动的平台。 注意， 只有EFI系统表中的运行时服务和由运行时DXE驱动程序提供的服务在操作系统运行阶段还继续存在</li></ul><h2 id="启动设备选择-BDS-阶段"><a href="#启动设备选择-BDS-阶段" class="headerlink" title="启动设备选择(BDS)阶段"></a>启动设备选择(BDS)阶段</h2><ul><li><p>BDS阶段的主要功能就是为平台选择一个合适的启动设备， 并尝试加载它</p></li><li><p>BDS架构协议是DXE阶段的BDS驱动产生的， DXE调度器在执行完所有的DXE驱动之后会调用BDS架构协议， 从而进入BDS阶段</p></li><li><p>在BDS阶段， BDS架构协议在连接控制器（利用启动时服务表中的ConnectController接口）的时候连接DXE阶段UEFI驱动产生的Driver Binding协议， 进而为控制台和启动设备提供软件抽象。 </p></li><li><p>BDS阶段是一个独特的启动管理阶段， 根据平台的启动策略，UEFI规范定义的全局启动选项Variable L”Boot####”和启动选项顺序VariableL “BootOrder”会被建立</p></li><li><p>一个启动选项对应于相应启动设备中的一个UEFI应用程序(APPLICATION)， 如UEFI BIOS的SETUP、 启动菜单、 扩展的诊断工具和操作系统加载器等等</p></li><li><p>UEFI启动管理器会按照启动顺序来引导启动选项， 启动选项对应的UEFI应用程序会被加载和执行 </p></li><li><p>如果是操作系统加载器被加载和执行， 操作系统加载器就会获得控制权， 然后进入接下来的TSL阶段来加载操作系统</p></li></ul><h2 id="瞬时系统加载-TSL-阶段"><a href="#瞬时系统加载-TSL-阶段" class="headerlink" title="瞬时系统加载(TSL)阶段"></a>瞬时系统加载(TSL)阶段</h2><ul><li><p>操作系统加载器在BDS 阶段被加载和执行， EFI 系统表的指针会被当作入口参数传递给操作系统加载器 </p></li><li><p>在TSL 阶段， 操作系统加载器会使用UEFI接口加载操作系统</p></li><li><p>TSL 阶段结束及操作系统运行时阶段开始的标志是操作系统加载器调用启动时服务表中的ExitBootServices 接口</p></li><li><p>ExitBootServices 接口会触发ExitBootServices 事件来通知其它模块启动时服务将要被终止了</p></li></ul><h2 id="运行时-RT-阶段"><a href="#运行时-RT-阶段" class="headerlink" title="运行时(RT)阶段"></a>运行时(RT)阶段</h2><ul><li>操作系统加载器在TSL 阶段调用启动时服务表中的ExitBootServices 接口而进入操作系统运行时阶段</li><li> 启动时服务表中的ExitBootServices 接口一旦被调用， EFI 系统表中所有的启动时服务都会被终止， 结果就只有EFI 系统表中的配置表和运行时服务在操作系统运行时阶段可用 </li><li>操作系统可以从操作系统加载器得到EFI 系统表的指针， 通过这个指针， 操作系统可以获得各种平台配置信息（如从配置表得到ACPI 表和SMBIOS 表等）和访问运行时服务</li></ul><h2 id="生命周期后-AL-阶段"><a href="#生命周期后-AL-阶段" class="headerlink" title="生命周期后(AL)阶段"></a>生命周期后(AL)阶段</h2><ul><li><p>生命周期后阶段代表的是平台的控制权从操作系统端重新回到了UEFI BIOS 端</p></li><li><p>这个阶段可以说是操作系统运行时阶段的延续， 可能是重启系统（如操作系统调用运行时服务表ResetSystem 接口）、 进入到ACPI 睡眠状态（如进入到S3， S5）或者进入SMM（在X86 CPU 检查到一种特殊的系统中断SMI的时候， 处理器会进入一种特殊的操作模式， 这种操作模式叫做SMM， 它对于OS 来说是完全透明的)等</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Boot, Phase, SEC, PEI, DXE,BDS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Source Level Debug</title>
      <link href="2021/08/03/Source%20%20Level%20%20Debugger/"/>
      <url>2021/08/03/Source%20%20Level%20%20Debugger/</url>
      
        <content type="html"><![CDATA[<h2 id="Debug-VS-Trace"><a href="#Debug-VS-Trace" class="headerlink" title="Debug VS Trace"></a>Debug VS Trace</h2><h3 id="Debug-Static"><a href="#Debug-Static" class="headerlink" title="Debug(Static)"></a>Debug(Static)</h3><ul><li>Run - Control(Break,Halt,Go)</li><li>Code Walking(stepping and running to a break)</li></ul><h3 id="Trace-Dynamic"><a href="#Trace-Dynamic" class="headerlink" title="Trace(Dynamic)"></a>Trace(Dynamic)</h3><ul><li>Root causing more obscure(hard to find) bugs</li><li>These are the few bugs that really blow up the schedule</li><li>Finding these bugs is where Trace shines</li></ul><h2 id="Requirements-for-Hardware"><a href="#Requirements-for-Hardware" class="headerlink" title="Requirements for Hardware"></a>Requirements for Hardware</h2><blockquote><p><a href="https://designintools.intel.com/Debug_Tools_s/1862.htm">Intel Debug Tools</a> </p></blockquote><blockquote><p>现在的X86变得日益复杂，如何进行有效的Debug 也日渐成为一个难题。为此 Intel 在芯片组或者 CPU 上预留了一个称作<strong>DCI （Intel® Direct Connect Interface）</strong>的Debug 接口。这个接口使用 USB 3.0一模一样的外部连接。CPU 内部有切换器，当Chipset 发现外部有设备和他握手，就将原本的USB信号切换为DCI 的信号。这样无需额外的预留就能实现Debug</p></blockquote><blockquote><p>在DCI 出现之前，Intel 使用JTAG 接口。当时的 Debug 盒子叫做 <strong>In-Target Proble</strong>，简称 ITP。为了Debug，主板上同时必须预留JTAG接口。显而易见，说服HW工程师在主板上预留这样的接口需要花费极大的口舌，至于在量产板子上焊接这样的接口几乎是不可能的事情。因此，串口一直是BIOS工程师的最爱</p></blockquote><blockquote><p>现在的Debug 盒子全称是<strong>“Intel SVT Closed Chassis Adapter”，缩写 “CCA”</strong>（Intel Silicon View Technology Closed Chassis Adapter）, 更通俗称<strong>DCI 蓝盒子</strong></p></blockquote><blockquote><p>除此之外还有长得类似 WinDBG 线的 <strong>DbC</strong>（ debug class 线），同样是插在 USB 3.0 口上就能进行Debug</p></blockquote><h2 id="Requirements-For-Software"><a href="#Requirements-For-Software" class="headerlink" title="Requirements For Software"></a>Requirements For Software</h2><blockquote><p>基本开发运行环境</p></blockquote><ul><li>Python</li><li>GIT</li><li>C/C++运行环境</li><li>JRE</li></ul><h2 id="Source-Level-Debugger应用场景"><a href="#Source-Level-Debugger应用场景" class="headerlink" title="Source Level Debugger应用场景"></a>Source Level Debugger应用场景</h2><ul><li>实际硬件支持的CRB或OEM BOARD Project（侧重解bug）</li></ul><blockquote><p>AMI VEB  OR Intel System Debugger</p></blockquote><ul><li>edk2内核Source（侧重追内核实现code，测试开发Tools）</li></ul><blockquote><p>EmulatorPkg(VSCode + Visual Studio)</p></blockquote><blockquote><p>OvmfPkg(QEMU + udk_debugger_tool + windbg)</p></blockquote><div style="page-break-after:always"></div><h2 id="Demo-For-AMI-Veb-Trace-Hub-Debugger"><a href="#Demo-For-AMI-Veb-Trace-Hub-Debugger" class="headerlink" title="Demo For AMI Veb Trace Hub Debugger"></a>Demo For AMI Veb Trace Hub Debugger</h2><h3 id="Connect-Target和Host"><a href="#Connect-Target和Host" class="headerlink" title="Connect Target和Host"></a>Connect Target和Host</h3><blockquote><p> <strong>(Intel)Comet Lake Platform</strong> ，Target端连上USB2.0或者3.0的Port，不一定都可以，可以看调试器DCI CONNECT指示灯来判定</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210520142815249.png"></p><p><img src="http://tc.holychen.cn/image/image-20210522211723225.png"></p><p><img src="http://tc.holychen.cn/image/image-20210522215057481.png"></p><h3 id="SVN导入相关Modules"><a href="#SVN导入相关Modules" class="headerlink" title="SVN导入相关Modules"></a>SVN导入相关Modules</h3><blockquote><p> Release Project Code一般会拿掉Debug相关的Modules，要支持Veb Trace Hub Function，Source Code要导入Debugger和DebuggerCollaterals Module，可以查看相关CHM文件，注意两个Module Version之间的Dependency，查看AMI_Debug_for_Trace_Hub_User_Manual_NDA.pdf知道是否Support对应Platform的DEBUG和Trace以及Guide.</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210524125730073.png"></p><h3 id="NDACollaterals配置"><a href="#NDACollaterals配置" class="headerlink" title="NDACollaterals配置"></a>NDACollaterals配置</h3><blockquote><p>安装CCA Debug Driver和Install.exe导入Trace Hub相关scripts到对应版本的Veb目录下，注意目前只Support JRE8，如果安装其它版本的JDK或者JRE并设置了环境变量，有遇到过Debug_loader报错的情况，可以用VisualeBiosWithJRE目录下的veb</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210522215057481.png"></p><p><img src="http://tc.holychen.cn/image/image-20210524125857568.png"></p><div style="page-break-after:always"></div><h3 id="BIOS-Setup-Settings"><a href="#BIOS-Setup-Settings" class="headerlink" title="BIOS Setup Settings"></a>BIOS Setup Settings</h3><blockquote><p>Target需要修改如下items setting，或者Host build source code时直接修改debugsetup.hfr，避免调Target端item settings，因为有的Project会隐藏CRB默认的items，需要Tool set bit位来调出</p></blockquote><ul><li><p><strong>Trace Hub Enable Mode : Advanced -&gt; Debug Settings -&gt; Advanced Debug Settings -&gt; PCH Trace Hub Enable Mode（Host Debugger）</strong></p></li><li><p><strong>Platform Debug Consent : Advanced -&gt; Debug Settings -&gt; Platform Debug Consent(Enabled(DCI OOB + [Dbc]))</strong></p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">``` oneof varid  <span class="token operator">=</span> PCH_SETUP<span class="token punctuation">.</span>PchTraceHubMode<span class="token punctuation">,</span>    prompt   <span class="token operator">=</span> <span class="token function">STRING_TOKEN</span><span class="token punctuation">(</span>STR_PCH_TRACE_HUB_PROMPT<span class="token punctuation">)</span><span class="token punctuation">,</span>    help     <span class="token operator">=</span> <span class="token function">STRING_TOKEN</span><span class="token punctuation">(</span>STR_TRACE_HUB_MODE_HELP<span class="token punctuation">)</span><span class="token punctuation">,</span>    option text <span class="token operator">=</span> <span class="token function">STRING_TOKEN</span><span class="token punctuation">(</span>STR_DISABLED<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> flags <span class="token operator">=</span> RESET_REQUIRED<span class="token punctuation">;</span>    option text <span class="token operator">=</span> <span class="token function">STRING_TOKEN</span><span class="token punctuation">(</span>STR_TRACE_HUB_TARGET_DEBUGGER<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> flags <span class="token operator">=</span> RESET_REQUIRED<span class="token punctuation">;</span>    option text <span class="token operator">=</span> <span class="token function">STRING_TOKEN</span><span class="token punctuation">(</span>STR_TRACE_HUB_HOST_DEBUGGER<span class="token punctuation">)</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> flags <span class="token operator">=</span> DEFAULT <span class="token operator">|</span> MANUFACTURING <span class="token operator">|</span> RESET_REQUIRED<span class="token punctuation">;</span>    endoneof<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">TOKEN    Name  <span class="token operator">=</span> <span class="token string">"PLATFORM_DEBUG_CONSENT_DEFAULT"</span>    Value  <span class="token operator">=</span> <span class="token string">"1"</span>    Help  <span class="token operator">=</span> <span class="token string">"Default value of Platform Debug Consent for Trace Hub. 0:Disabled / 1:DCI OOB+[DbC] / 2:DCI OOB / 3:USB3 DbC / 4:XDP/MIPI60 / 5:USB2 DbC"</span>    TokenType <span class="token operator">=</span> Integer    TargetMAK <span class="token operator">=</span> Yes    TargetH <span class="token operator">=</span> YesEnd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Build-Token-Settings"><a href="#Build-Token-Settings" class="headerlink" title="Build Token Settings"></a>Build Token Settings</h3><ul><li><p><strong>“DEBUG_MODE”                                         Enabled</strong></p></li><li><p>**”AmiTraceHubDebugger_Support “           Enabled **</p></li><li><p><strong>“PLATFORM_DEBUG_CONSENT_DEFAULT”    1</strong></p></li></ul><div style="page-break-after:always"></div><h3 id="导入证书"><a href="#导入证书" class="headerlink" title="导入证书"></a>导入证书</h3><blockquote><p>对应路径Help -&gt; Mange  Debugger License，证书需要获得AMI授权</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210522215320246.png"></p><h3 id="配置Trace-Hub-Options"><a href="#配置Trace-Hub-Options" class="headerlink" title="配置Trace Hub Options"></a>配置Trace Hub Options</h3><blockquote><p>需要根据硬件调试工具连接方式选取对应 Hardware Probe，Platform Processor和Platform PCH也都需要对应上，如果列表没有合适的选项可以对应，会出现Target端Detected不到的情况，可以尝试更新DebuggerCollaterals Module获取最新Support的Lists或者与Module Owner确认</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210522215818919.png"></p><h3 id="配置Xml"><a href="#配置Xml" class="headerlink" title="配置Xml"></a>配置Xml</h3><blockquote><p>对应Board 的XML需要Enabled如下设置</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210522220105783.png"></p><p><img src="http://tc.holychen.cn/image/image-20210522220219638.png"></p><div style="page-break-after:always"></div><h3 id="Trace-Hub-Debugging"><a href="#Trace-Hub-Debugging" class="headerlink" title="Trace Hub Debugging"></a>Trace Hub Debugging</h3><blockquote><p>Flash Full Bin to Target and Start Trace Hub Debugging，Loaded Driver View视图中可以看到依次加载的Module，此时寻找感兴趣的Module或者可疑的点，可以下断点调试，View call stack、Memory、Variable、Expression、Disassembly、Register、Console Log and so on.</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210523202215441.png"></p><div style="page-break-after:always"></div><h2 id="Demo-for-Intel-system-debugger"><a href="#Demo-for-Intel-system-debugger" class="headerlink" title="Demo for Intel system debugger"></a>Demo for Intel system debugger</h2><blockquote><p>会遇到有些平台AMI VEB还不支持，但Intel System Debuger可以跟进源码，软件调试时使用上大同小异，可以参照Help文档或者寻求Intel的Support</p></blockquote><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p><img src="http://tc.holychen.cn/image/image-20210524131438876.png"></p><p><img src="http://tc.holychen.cn/image/image-20210524131500224.png"></p><h3 id="Debug-Configuration"><a href="#Debug-Configuration" class="headerlink" title="Debug Configuration"></a>Debug Configuration</h3><blockquote><p>设为单线程方便Halt，加入需要Debug的Source的路径</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210524131700261.png"></p><p><img src="http://tc.holychen.cn/image/image-20210524131755466.png"></p><h3 id="Launch-and-Debugging"><a href="#Launch-and-Debugging" class="headerlink" title="Launch and Debugging"></a>Launch and Debugging</h3><p><img src="http://tc.holychen.cn/image/image-20210524130519652.png"></p><div style="page-break-after:always"></div><h2 id="Demo-for-edk2内核源码"><a href="#Demo-for-edk2内核源码" class="headerlink" title="Demo for edk2内核源码"></a>Demo for edk2内核源码</h2><h3 id="代码部署"><a href="#代码部署" class="headerlink" title="代码部署"></a>代码部署</h3><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619517129215.png"></p><blockquote><p>github下载较慢，通过代理挂在美国的节点会快点，也可通过gitee平台，备份edk2和submoulde仓库再进行update</p></blockquote><ul><li>此时需要修改根目录下.gitmodules为对应路径<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619517342071.png"></li></ul><h3 id="编译相关Tool部署"><a href="#编译相关Tool部署" class="headerlink" title="编译相关Tool部署"></a>编译相关Tool部署</h3><ul><li><a href="https://www.nasm.us/">NASM</a></li><li><a href="https://acpica.org/downloads/binary-tools">IASL编译器</a></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619517917113.png"></p><div style="page-break-after:always"></div><blockquote><p>推荐都放在C盘根目录，并设置环境变量，不然需要修改tools_def.txt，edksetup.bat的Tool路径</p></blockquote><ul><li>不设置环境变量，修改Tool路径做法</li></ul><ul><li><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619518038304.png"></li></ul><h3 id="编译edk2-EmulatorPkg"><a href="#编译edk2-EmulatorPkg" class="headerlink" title="编译edk2 EmulatorPkg"></a>编译edk2 EmulatorPkg</h3><ul><li>edksetup.bat rebuild  //重新获取配置的环境变量,会在Conf目录下建立target.txt,Tools_def.txt等文件</li><li>build -t VS2017 -a IA32 -y Report.txt //-t 指定ToolChain -a 指定TargetArch -y 生成格式化的Report.txt<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619518234669.png"></li></ul><div style="page-break-after:always"></div><h3 id="调试edk2-执行Winhost-exe"><a href="#调试edk2-执行Winhost-exe" class="headerlink" title="调试edk2(执行Winhost.exe)"></a>调试edk2(执行Winhost.exe)</h3><ul><li>在需要调试代码处加上CpuBreakpoint(),并修改注册表如下,触发异常会调出Visual Studio作为调试器</li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619518365699.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619519544086.png"></p><h3 id="Start-Debugging"><a href="#Start-Debugging" class="headerlink" title="Start Debugging"></a>Start Debugging</h3><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1619520470753.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Veb, Intel System Debugger, DCI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C基本语法</title>
      <link href="2021/08/03/C%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>2021/08/03/C%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="软件开发概览"><a href="#软件开发概览" class="headerlink" title="软件开发概览"></a>软件开发概览</h1><h3 id="学习的标准"><a href="#学习的标准" class="headerlink" title="学习的标准"></a>学习的标准</h3><blockquote><p>思维缜密 逻辑清晰 知识点能够通俗易懂的复述和编码</p></blockquote><h3 id="软件开发的分类"><a href="#软件开发的分类" class="headerlink" title="软件开发的分类"></a>软件开发的分类</h3><blockquote><p>按照职责的不同，需求量比较大的常见的软件开发类型有：</p></blockquote><ul><li><p>移动开发(Andriod、IOS、Harmony)</p><ul><li>Andriod：Java、Kotlin</li><li>IOS：Objective-C、Swift</li></ul></li><li><p>前端开发(HTML、CSS、JavaScript、TypeScript)</p></li><li><p>后台开发(Java、C++、PHP、.NET、Python、Go)</p></li><li><p>嵌入式开发(C、C++、汇编)</p></li><li><p>……</p></li></ul><h3 id="软件开发的职责分工"><a href="#软件开发的职责分工" class="headerlink" title="软件开发的职责分工"></a>软件开发的职责分工</h3><p><img src="http://tc.holychen.cn/image/image-20210609222456589.png"></p><h2 id="C语言简介"><a href="#C语言简介" class="headerlink" title="C语言简介"></a>C语言简介</h2><h3 id="电子计算机的发展史"><a href="#电子计算机的发展史" class="headerlink" title="电子计算机的发展史"></a>电子计算机的发展史</h3><blockquote><p>第1代：电子管数字机(1946 - 1958年)</p></blockquote><blockquote><p>第2代：晶体管数字机(1958 - 1964年)</p></blockquote><blockquote><p>第3代：集成电路数字机(1946 - 1970年)</p></blockquote><blockquote><p>第4代：大规模集成电路机(1970年至今)</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210612214944935.png"></p><blockquote><p>电路的逻辑状态只有0和1两个状态，0表示低电平，1表示低电平</p></blockquote><blockquote><p>因此，当代的电子计算机只能识别0和1</p></blockquote><blockquote><p>注意：计算机除了电子计算机，还有光子计算机、量子计算机、生物计算机、纳米计算机等</p></blockquote><h3 id="C语言的发展简史"><a href="#C语言的发展简史" class="headerlink" title="C语言的发展简史"></a>C语言的发展简史</h3><blockquote><p>C语言于1972年诞生于美国AT&amp;T公司的贝尔实验室    </p></blockquote><ul><li>由Dennis MacAlistair Ritchie(丹尼斯.里奇)发明，被称为是C语言之父</li><li>C语言之所以命名为C，是因为它以B语言为基础发展而来</li><li>B语言由Kenneth Thompson(肯.汤普森)发明</li></ul><blockquote><p>Thompson和Ritchie用C语言完全重写了UNIX操作系统(以前是用汇编语言)</p></blockquote><ul><li>随着UNIX的发展，C语言也得到了不断的完善</li></ul><h3 id="C语言的标准"><a href="#C语言的标准" class="headerlink" title="C语言的标准"></a>C语言的标准</h3><blockquote><p>为了利于C语言的全面推广，许多专家学者和硬件厂商联合组成了C语言标准委员会(美国国家标准协会，ANSI)</p></blockquote><ul><li>1989年，诞生了第一个完备的C标准，简称C89，也就是ANSI C</li></ul><blockquote><p>1990年，ANSI C被国际标准化组织ISO采纳，C语言在ISO有了一个官方名称<strong>ISO/IEC 9889:1990</strong></p></blockquote><ul><li>9899是C语言在ISO标准中的代号，C++在ISO标准中的代号是14882</li><li>冒号后面的1990表示当前修订好的版本是在1990年发布的</li><li>对于<strong>ISO/IEC 9889:1990</strong>，有人称为C90或C89，是最初的C语言国际标准</li></ul><blockquote><p>1999年，正式发布<strong>ISO/IEC 9889:1999</strong>，简称为C99标准</p></blockquote><blockquote><p>2011年，正式发布<strong>ISO/IEC 9889:2011</strong>，简称为C11标准</p></blockquote><h3 id="C语言的用途"><a href="#C语言的用途" class="headerlink" title="C语言的用途"></a>C语言的用途</h3><blockquote><p>C语言可以说是其他高级编程语言的老祖宗，历史悠久</p></blockquote><ul><li>它的性能及其优越，在很多领域是其他编程语言无法取代的</li></ul><blockquote><p>凡是对性能要求极高的领域，基本都少不了C语言</p></blockquote><ul><li>操作系统开发(内核、驱动等，UNIX、Linux等著名操作系统就是利用C语言编写的)</li><li>数据库开发</li><li>高性能服务器开发</li><li>嵌入式开发</li><li>游戏开发</li><li>……</li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><blockquote><p>记事本</p></blockquote><ul><li>功能单一、体验差、易出错、开发效率低</li></ul><blockquote><p>IDE(Integrated Development Environment): 集成开发环境</p></blockquote><ul><li>智能提示、高亮识别、语法检测、开发效率高(功能强大到超乎想象)</li><li>常见的C语言IDE有：Visual Studio、QT Creator、CLion、Dev C++</li></ul><p><img src="http://tc.holychen.cn/image/image-20210609232030914.png"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="程序的结构"><a href="#程序的结构" class="headerlink" title="程序的结构"></a>程序的结构</h3><blockquote><p>任何一个C语言程序都有一个或多个函数(Function)构成</p></blockquote><ul><li>每个函数都有自己的功能</li></ul><p><img src="http://tc.holychen.cn/image/image-20210609234553541.png"></p><blockquote><p>所以，以后编写的C语言代码，基本都是写在函数中</p></blockquote><blockquote><p>在有些编程语言中(例如Java)，函数也叫做”方法(Method)”</p></blockquote><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><blockquote><p>每一个函数都有自己的名称</p></blockquote><blockquote><p>每一个函数的名称都是唯一的</p></blockquote><blockquote><p>默认情况下，C语言程序的运行入口点是main函数(翻译为:主函数，没有main函数，C语言程序是无法运行的</p></blockquote><h3 id="语法须知"><a href="#语法须知" class="headerlink" title="语法须知"></a>语法须知</h3><blockquote><p>C语言源代码(Source Code)文件的文件扩展名是.c</p></blockquote><blockquote><p>每一条语句(Stasement)后面都要以分号;结尾，是语句结束的标志</p></blockquote><blockquote><p>括号都是成对出现的</p></blockquote><blockquote><p>C语言是区分大小写的(大小写敏感，case-sensitive)</p></blockquote><blockquote><p>代码中用到的符号必须都是英文符号(注释、字符、字符串等的内容除外)</p></blockquote><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><blockquote><p>该换行就换行</p></blockquote><blockquote><p>该缩进就缩进(按Tab键缩进、按Shift + Tab键反缩进)</p></blockquote><blockquote><p>该留空格就留空格(一般就留一个空格)</p></blockquote><h3 id="编译、链接知识"><a href="#编译、链接知识" class="headerlink" title="编译、链接知识"></a>编译、链接知识</h3><blockquote><p>编译：将C语言源代码文件编译成可重定位二进制目标文件(以.o或.obj作为扩展名)，由编译器(complier)来完成</p></blockquote><blockquote><p>链接：将所有目标文件以及所需要的库文件合并成一个可执行文件(executable file)，由链接器(linker)来完成</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210612220002735.png"></p><h3 id="编译、链接的细节"><a href="#编译、链接的细节" class="headerlink" title="编译、链接的细节"></a>编译、链接的细节</h3><blockquote><p>常见的C语言编译器有(已经内置了链接器)</p></blockquote><ul><li><p>MSVC：微软出品(用在windows中)</p></li><li><p>GCC：GNU Compiler Collection的缩写，GNU出品</p></li><li><p>MinGW：Minimalist GNU for Windows的缩写 ，GNU出品(用在Windows中)</p></li><li><p>LLVM：常用于苹果的开发工具中</p></li><li><p>……</p></li></ul><blockquote><p>对于同一份源代码，经过不同的编译器编译出来的目标文件(体积、格式、运行效率等)是不一样的</p></blockquote><blockquote><p>对于不同平台(操作系统)，最后链接产生的可执行文件格式也是不同的</p></blockquote><ul><li>Windows：PE格式(经常以.exe作为文件扩展名)</li><li>Linux：ELF格式</li><li>Mac：Mach - O格式</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>什么是注释</p></blockquote><ul><li>注释常用来解释某段代码的具体含义、作用</li><li>注释并不会被当做正常代码进行编译</li><li>注释再很多IDE中的默认颜色都是偏绿色</li></ul><blockquote><p>C语言的注释有两种书写风格</p></blockquote><ul><li>多行注释(也被称为C风格注释)</li><li>单行注释(C99开始有，也被称为C++风格注释)</li></ul><blockquote><p>注释的嵌套</p></blockquote><ul><li>单行注释可以嵌套单行注释、多行注释</li><li>多行注释不能嵌套多行注释</li></ul><blockquote><p>多写注释的好处</p></blockquote><ul><li>方便回忆、检查代码</li><li>方便程序员之间的团队协作、提高开发效率</li><li>方便旧项目的交接</li></ul><blockquote><p>注释常用技巧</p></blockquote><ul><li>用来检验功能</li><li>用来定位BUG</li></ul><h3 id="变量-Variable"><a href="#变量-Variable" class="headerlink" title="变量(Variable)"></a>变量(Variable)</h3><h4 id="变量的作用"><a href="#变量的作用" class="headerlink" title="变量的作用"></a>变量的作用</h4><blockquote><p>可以存储程序运行中会变化的数据</p></blockquote><h4 id="如何声明-declare-一个变量"><a href="#如何声明-declare-一个变量" class="headerlink" title="如何声明(declare)一个变量"></a>如何声明(declare)一个变量</h4><ul><li><p>变量类型 变量名;</p></li><li><p>变量类型决定了变量能够存储什么类型的数据</p></li></ul><h4 id="如何给变量赋值"><a href="#如何给变量赋值" class="headerlink" title="如何给变量赋值"></a>如何给变量赋值</h4><ul><li>赋值(assign): 将数据交给变量去存储</li><li>变量名 = 数据;</li><li>这个等号 = 表示赋值，会将右边的数据赋值给左边的变量</li></ul><blockquote><p>在变量声明完毕后，可以直接通过变量名访问，不用带上变量类型</p></blockquote><h4 id="变量的细节"><a href="#变量的细节" class="headerlink" title="变量的细节"></a>变量的细节</h4><ul><li><p>变量可以被多次赋值，新值会覆盖旧值</p></li><li><p>变量的第一次赋值，一般叫做初始化(initialize)</p></li><li><p>变量可以在声明的同时进行初始化</p></li><li><p>变量在未被初始化之前，它的值是不确定的</p></li><li><p>变量在使用之前必须要进行初始化</p></li><li><p>可以同时声明多个同类型的变量</p></li><li><p>可以将一个变量的值赋值给另一个变量</p></li></ul><h4 id="变量的作用域-scope"><a href="#变量的作用域-scope" class="headerlink" title="变量的作用域(scope)"></a>变量的作用域(scope)</h4><blockquote><p>变量的作用域：就是指变量的作用范围、有效使用范围</p></blockquote><ul><li> 从声明变量的那条语句开始，直到变量所在的大括号结束</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//错误</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//错误</span>    <span class="token keyword">int</span> age1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//正确</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//错误</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> age2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//正确</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//正确</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//正确</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>age2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//错误</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="变量的作用域细节"><a href="#变量的作用域细节" class="headerlink" title="变量的作用域细节"></a>变量的作用域细节</h5><ul><li>在同一个作用域内，不允许有同名的变量</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//有歧义(二义性)</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//正确</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">//错误</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment">//正确</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        <span class="token punctuation">&#123;</span>          <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3age = %d\n"</span><span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2age = %d\n"</span><span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1age = %d\n"</span><span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//result:30 20 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="变量的存储"><a href="#变量的存储" class="headerlink" title="变量的存储"></a>变量的存储</h4><blockquote><p>变量的内存地址是指首字节的内存地址，首字节是指地址值最小的那个字节</p></blockquote><blockquote><p>越晚定义的变量，内存地址越小</p></blockquote><h5 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h5><blockquote><p>大小端模式：决定了多字节数据的字节存储顺序</p></blockquote><p>大端模式(Big-endian)：高低低高</p><ul><li>高字节放在低地址，低字节放在高地址</li></ul><p>小端模式(Little-endian)：高高低低</p><ul><li>高字节放在高地址，低字节放在低地址</li></ul><p>不同CPU架构的模式不一样</p><ul><li>比如x86架构是小端模式</li><li>有些CPU架构是大端模式</li><li>目前比较常见的是小端模式</li></ul><h5 id="int类型的存储"><a href="#int类型的存储" class="headerlink" title="int类型的存储"></a>int类型的存储</h5><p><img src="http://tc.holychen.cn/image/image-20210613122155853.png"></p><h5 id="字符的存储细节"><a href="#字符的存储细节" class="headerlink" title="字符的存储细节"></a>字符的存储细节</h5><p>计算机中的数据都是以二进制形式存储的，字符数据也不例外</p><ul><li>每一个自负都会被转化成对应的整数值进行存储</li></ul><p>在1967年，美国发布了ASCII码表，里面规定了128个单字节字符对应的整数值(ASCII码值)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">97</span><span class="token punctuation">;</span><span class="token keyword">char</span> c1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>cahr c2 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="http://tc.holychen.cn/image/image-20210613145053624.png"></p><h6 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a>ASCII码表</h6><blockquote><p>ASCII,全称是American Standard Code for Information  Interchang，译为”美国信息交换标准码”，是一种标准的单字节字符编码方案</p></blockquote><ul><li>共128个字符，码值范围：0-127(也就是0x00-0x7F)</li><li>有33个是控制字符或通信专用字符，码值范围：0-31、127<ul><li>控制字符：LF(换行)、DEL(删除)、BS(退格)等</li><li>通信专用字符：SOH(文头)、EOT(文尾)、ACk(确认)等</li></ul></li><li>有95个可显示字符，码值范围：32-126<ul><li>48-57：十个阿拉伯数字(0~9)</li><li>65-90：26个大写英文字母(A~Z)</li><li>97-122：26个小写英文字母(a~z)</li><li>其余为一些标点符号、运算符等</li></ul></li></ul><p><img src="http://tc.holychen.cn/image/image-20210613150757818.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span> <span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token function">puts</span> <span class="token punctuation">(</span> <span class="token string">"Printable ASCII:"</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token keyword">for</span>  <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span>  <span class="token number">32</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span>  <span class="token number">127</span> <span class="token punctuation">;</span>  <span class="token operator">++</span> i <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>         <span class="token function">putchar</span> <span class="token punctuation">(</span> i <span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token function">putchar</span> <span class="token punctuation">(</span> i <span class="token operator">%</span>  <span class="token number">16</span>  <span class="token operator">==</span>  <span class="token number">15</span>  <span class="token operator">?</span>  <span class="token string">' \n '</span>  <span class="token operator">:</span>  <span class="token string">' '</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token comment">/*Printable ASCII:  ! " # $ % &amp; ' ( ) * + , - . /0 1 2 3 4 5 6 7 8 9 : ; &lt; = > ?@ A B C D E F G H I J K L M N OP Q R S T U V W X Y Z [ \ ] ^ _` a b c d e f g h i j k l m n op q r s t u v w x y z &#123; | &#125; ~*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 (String)"></a>字符串 (String)</h4><blockquote><p>用双引号包住的内容叫做：字符串(由若干个【字符】组成的一串数据)</p></blockquote><blockquote><p>和注释类似，字符串里的内容可以随便写</p></blockquote><h3 id="标识符-Identifier"><a href="#标识符-Identifier" class="headerlink" title="标识符(Identifier)"></a>标识符(Identifier)</h3><blockquote><p>标识符：由开发者自定义的一些名称(比如变量名、函数名等)</p></blockquote><blockquote><p>标识符的命名规则大致如下</p></blockquote><ul><li>不限长度</li><li>可以使用数字、下划线、英文字母</li><li>可以使用以\u及\U转义记号指定的Unicode字符(从C99开始)</li><li>不能以数字开头</li><li>不能使用关键字</li></ul><blockquote><p>标识符的命名规范(命名建议)</p></blockquote><ul><li>尽量用正确的英文单词命名，见名知意</li></ul><blockquote><p>当名称中包含多个单词时</p></blockquote><ul><li><p>小驼峰(第一个单词的首字母小写，其它单词的首字母大写)(mHandle)</p></li><li><p>大驼峰(所有单词的首字母大写)</p></li><li><p>用下划线连接</p></li></ul><h3 id="关键字-Keyword"><a href="#关键字-Keyword" class="headerlink" title="关键字(Keyword)"></a>关键字(Keyword)</h3><blockquote><p>关键字，也叫做保留字(reserved word)</p></blockquote><ul><li>是编程语言内部已经定义好的一些有特殊含义的符号</li></ul><blockquote><p>C语言的关键字如下所示</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613031548234.png"></p><h3 id="字面量-Literal"><a href="#字面量-Literal" class="headerlink" title="字面量(Literal)"></a>字面量(Literal)</h3><blockquote><p>字面量：直接写出来的一个固定值</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">double</span> height <span class="token operator">=</span> <span class="token number">1.68</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>hody <span class="token operator">=</span> <span class="token string">"code"</span><span class="token punctuation">;</span><span class="token keyword">char</span> cc <span class="token operator">=</span> <span class="token string">'m'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上面代码中，等号 = 右边的固定值都叫做字面量</p></blockquote><h3 id="代码中的进制书写形式"><a href="#代码中的进制书写形式" class="headerlink" title="代码中的进制书写形式"></a>代码中的进制书写形式</h3><blockquote><p>C语言标准规定</p></blockquote><ul><li>默认是十进制</li><li>以0开头是八进制</li><li>以0X或0x开头是十六进制</li></ul><blockquote><p>C语言标准并不支持二进制的书写形式</p></blockquote><ul><li>不过有些编译器支持，比如GCC规定以0b或0B开头是二进制</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"八进制：0%o\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"十六进制：0x%x\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="有符号数的二进制表示方法"><a href="#有符号数的二进制表示方法" class="headerlink" title="有符号数的二进制表示方法"></a>有符号数的二进制表示方法</h3><blockquote><p>int 类型属于有符号整数类型(signed integer types)</p></blockquote><ul><li>可以表示正数、负数</li></ul><blockquote><p>有符号数的二进制有三种表示方法：原码、反码、补码</p></blockquote><blockquote><p>三种表示方法均有符号位和数值位两部分</p></blockquote><ul><li>符号位：最高位作为符号位，用0表示”正”，用1表示”负”</li><li>数值位：三种表示方法各不相同</li></ul><blockquote><p>正数的原码、反码、补码一致，负数则不一样，计算机用补码表示和存储数值</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613120716044.png"></p><h3 id="字符的使用细节"><a href="#字符的使用细节" class="headerlink" title="字符的使用细节"></a>字符的使用细节</h3><ul><li>可以将char类型当做整数类型来使用</li></ul><blockquote><p>数字整数、数字字符、数字字符串</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'9'</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token string">"9"</span><span class="token punctuation">;</span><span class="token comment">//10</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//58</span><span class="token function">prinft</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4210689</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://tc.holychen.cn/image/image-20210613152215827.png"></p><blockquote><p>中文、日文、韩文等非英文字符是如何存储在计算机中的</p></blockquote><ul><li>首先，必然是以二进制的形式存储在计算机中</li><li>其次，每个字符对应的二进制数值取决于具体的编码方案</li></ul><blockquote><p>GBK主要支持CJK字符(C指中国、J指日本、K指朝鲜)，而UTF-8支持几乎世界上所有的文字字符</p></blockquote><h3 id="转义序列-Escape-sequences"><a href="#转义序列-Escape-sequences" class="headerlink" title="转义序列(Escape sequences)"></a>转义序列(Escape sequences)</h3><blockquote><p>转义序列，一般也叫做转义字符，是一些有特殊含义的字符</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613153357034.png"></p><h3 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h3><blockquote><p>scanf函数的功能是：输入(input)，读取数据(比如读取通过键盘输入的数据)</p></blockquote><p>scanf函数开始执行后，会等待用户输入</p><ul><li>程序卡在scanf函数那里，不会执行scanf函数后面的代码</li><li>当用户敲Enter键(回车键)时，表示输入完毕</li><li>程序才会开始执行scanf函数后面的代码</li></ul><h5 id="循环中校验scanf输入"><a href="#循环中校验scanf输入" class="headerlink" title="循环中校验scanf输入"></a>循环中校验scanf输入</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入1-100之间的正整数："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="sancf函数-匹配的细节"><a href="#sancf函数-匹配的细节" class="headerlink" title="sancf函数 - 匹配的细节"></a>sancf函数 - 匹配的细节</h5><ul><li>当中途有匹配失败时，将结束匹配</li></ul><blockquote><p>当尝试把输入的数字赋值给字符变量时</p></blockquote><ul><li>scanf把输入的数字当成是数字字符来处理</li><li>并不会把输入的数字当成是字符的ASCII码值来处理</li></ul><h5 id="scanf函数-——-空白字符"><a href="#scanf函数-——-空白字符" class="headerlink" title="scanf函数 —— 空白字符"></a>scanf函数 —— 空白字符</h5><blockquote><p>空白字符包括：空格(‘ ‘)、Tab(‘\t’)、Enter(‘\n’)</p></blockquote><ul><li><p>如果在输入数据的开头，有一段任意长(长度 &gt;= 0)连续空白字符，是不需要与格式化字符串中的字符进行匹配的</p></li><li><p>在格式化字符串中，任意长(长度 &gt;= 0)连续空白字符能匹配输入的任意长(长度 &gt;= 0)连续空白字符</p></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p>C语言拥有丰富多彩的数据类型，可以分为4大类型</p></blockquote><p>void类型</p><p>基本类型(basic types)</p><ul><li>字符类型(character types)</li><li>有符号整数类型(signed integer types)</li><li>无符号整数类型(unsigned integer types)</li><li>浮点类型(floating types)</li></ul><p>枚举类型(enumerate)</p><p>派生类型(derived types)</p><ul><li>数组类型(array types)</li><li>结构体类型(structure types)</li><li>联合体类型(union types)</li><li>函数类型(function types)</li><li>指针类型(pointer types)</li><li>原子类型(atomic types)</li></ul><h3 id="基本类型-Basic-Types"><a href="#基本类型-Basic-Types" class="headerlink" title="基本类型(Basic Types)"></a>基本类型(Basic Types)</h3><p>有符号整数类型(signed integer types)</p><ul><li>char (等价类型：signed char)</li><li>short(等价类型：signed short、short int、signed short int)</li><li>int(等价类型：signed int、signed)</li><li>long(等价类型：signed long、long int、signed long int)(C99起)</li><li>long long(等价类型：signed long long、long long int、signed long long int)(C99起)</li></ul><p>无符号整数类型(unsigned integer types)</p><ul><li>unsigned char</li><li>unsigned short(等价类型：unsigned short int)</li><li>unsigned int(等价类型：undigned)</li><li>undigned long(等价类型：unsigned long int)(C99起)</li><li>unsigned long long(等价类型：unsigned long long int)(C99起)</li><li>_Bool(C99起)</li></ul><h3 id="字符类型-character-types"><a href="#字符类型-character-types" class="headerlink" title="字符类型(character types)"></a>字符类型(character types)</h3><p>char类型属于字符类型(character types)</p><blockquote><p>一个char类型的变量占用一个字节的内存</p></blockquote><ul><li>所以它只能存储一个单字节字符</li><li>26个英文字母的大小写(a<del>z,A</del>Z)、10个阿拉伯数字(0~9)等都是单字节字符</li></ul><h3 id="浮点类型-floating-types"><a href="#浮点类型-floating-types" class="headerlink" title="浮点类型(floating types)"></a>浮点类型(floating types)</h3><ul><li>float、duoble、long double</li></ul><h3 id="整数类型的大小"><a href="#整数类型的大小" class="headerlink" title="整数类型的大小"></a>整数类型的大小</h3><blockquote><p>C标准规定</p></blockquote><ul><li><strong>sizeof(long long) &gt;= sizeof(long) &gt;= sizeof(int) &gt;= sizeof(short) &gt;= sizeof(char) == 1</strong></li></ul><p><img src="http://tc.holychen.cn/image/image-20210613164507969.png"></p><h3 id="数据模型-Data-Models"><a href="#数据模型-Data-Models" class="headerlink" title="数据模型(Data Models)"></a>数据模型(Data Models)</h3><ul><li>LP32(2/4/4)：int为16位、long、指针为32位</li><li>ILP32(4/4/4)：int、long、指针均为32位</li><li>LLP64(4/4/8)：int、long为32位，指针为64位（Win64 API）</li><li>LP64(4/4/8)：int为32，long、指针为64位(Unix、类Unix系统(Linux、Mac OS X))</li></ul><h3 id="char、unsigned-char区别"><a href="#char、unsigned-char区别" class="headerlink" title="char、unsigned char区别"></a>char、unsigned char区别</h3><p><img src="http://tc.holychen.cn/image/image-20210613170117839.png"></p><ul><li>c1、c2变量在内存中存放的二进制数据是完全一样的</li><li>对于同一份二进制数据，分别以有符号数形式、无符号数形式解读出来的含义可能是不一样的</li></ul><h3 id="整数的取值范围"><a href="#整数的取值范围" class="headerlink" title="整数的取值范围"></a>整数的取值范围</h3><blockquote><p>char、unsigned char都只占用一个字节，能够存放的二进制数据范围都是【0b0000 0000，0b1111 1111】</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613171125136.png"></p><p><img src="http://tc.holychen.cn/image/image-20210613172530305.png"></p><ul><li>有n个二进制位的有符号数的取值范围是【-2^n-1^，2^n-1^ - 1】</li><li>有n个二进制位的无符号数的取值范围是【0，2^n^ - 1 】</li></ul><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><blockquote><p>当出现溢出时，会优先保留低字节的数据，舍弃高字节的数据</p></blockquote><blockquote><p>所以在给取值范围小的变量赋值时，要注意防止数据溢出，否则，结果可能会跟预期不符合</p></blockquote><blockquote><p>无符号数和有符号数溢出时的钟表机制</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613174815987.png"></p><h3 id="浮点类型-Floating-Types"><a href="#浮点类型-Floating-Types" class="headerlink" title="浮点类型(Floating Types)"></a>浮点类型(Floating Types)</h3><blockquote><p>浮点类型可以用来表示小数(比如0.5)，包括了float、double、long double类型</p></blockquote><blockquote><p>最常用浮点类型的是float和double，一般在数值后面加上f或者F表示是float类型的数值</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">1.45F</span><span class="token punctuation">;</span><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">1.89</span><span class="token punctuation">;</span><span class="token comment">//1.450000 1.890000</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f %f"</span><span class="token punctuation">,</span>f<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>float：单精度(Single)浮点类型，占用32bit，可以保证精确到小数点后6位</p></blockquote><ul><li>最小值大约是：-3.4 * 10^38^，最大值大约是：3.4 * 10^38^</li></ul><blockquote><p>double：双精度(Double)浮点类型，占用64bit，可以保证精确到小数点后15位</p></blockquote><ul><li>最小值大约是：-1.8 * 10^308^，最大值大约是：1.8 * 10^308^</li></ul><h3 id="浮点类型的存储细节"><a href="#浮点类型的存储细节" class="headerlink" title="浮点类型的存储细节"></a>浮点类型的存储细节</h3><blockquote><p>浮点数在计算机中是按照IEEE 754标准存储的</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613180945333.png"></p><p><img src="http://tc.holychen.cn/image/image-20210613181059171.png"></p><h3 id="printf中的转换格式指定符"><a href="#printf中的转换格式指定符" class="headerlink" title="printf中的转换格式指定符"></a>printf中的转换格式指定符</h3><blockquote><p>printf中常用的转换格式指定符(conversion format specifier)如下所示</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210613182252538.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"zd\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> age <span class="token operator">=</span> <span class="token number">10LL</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>unsigend <span class="token keyword">long</span> no <span class="token operator">=</span><span class="token number">8UL</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"lu%\n"</span><span class="token punctuation">,</span>no<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="printf格式符细节"><a href="#printf格式符细节" class="headerlink" title="printf格式符细节"></a>printf格式符细节</h3><ul><li>用%%来显示一个%</li><li>用%6d表示占用6个字符位置，默认靠右对齐</li><li>%-6d中的减号( - )表示靠左对齐</li><li>%+6d中的加号( + )表示显示正负号</li><li>%.2f表示四舍五入保留2位小数</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>强制类型转换</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">类型<span class="token number">1</span> v1 <span class="token operator">=</span> xx<span class="token punctuation">;</span>类型<span class="token number">2</span> v2 <span class="token operator">=</span> <span class="token punctuation">(</span>类型<span class="token number">2</span><span class="token punctuation">)</span> v1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><blockquote><p>在进行一些算数运算时，小类型会被隐式转换成大类型</p></blockquote><ul><li>char &lt; short &lt; int &lt; long &lt; long long &lt; float &lt; double &lt; long double</li></ul><blockquote><p>注意：任何小于int的整数类型，在运算时会隐式转换为int类型</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token number">97</span><span class="token punctuation">;</span><span class="token keyword">short</span> s <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">// 1 2</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%zd %zd\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 4 </span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%zd %zd\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">-</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 4</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%zd %zd\n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>c <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>c<span class="token operator">/</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%zd \n"</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运算符-Operators"><a href="#运算符-Operators" class="headerlink" title="运算符(Operators)"></a>运算符(Operators)</h2><blockquote><p>C语言常用运算符，如下表所示</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210614094402166.png"></p><h3 id="算术运算符-Arithemetic-Operators"><a href="#算术运算符-Arithemetic-Operators" class="headerlink" title="算术运算符(Arithemetic Operators)"></a>算术运算符(Arithemetic Operators)</h3><p><img src="http://tc.holychen.cn/image/image-20210614094624439.png"></p><ul><li>模运算符不能用在浮点数上</li><li>模运算结果的正负性跟随运算符左边的操作数</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token operator">%</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">%</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//-3</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">%</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//-3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="位运算符-Bitwise-Operators"><a href="#位运算符-Bitwise-Operators" class="headerlink" title="位运算符(Bitwise Operators)"></a>位运算符(Bitwise Operators)</h4><blockquote><p>位运算符，属于算数运算符，位运算符的运算数只能是整数</p></blockquote><p><img src="http://tc.holychen.cn/image/image-20210614194041996.png"></p><ul><li>位移运算符b的值必须为非负整数</li><li>左移低位补0</li><li>右移高位用符号位填充 </li></ul><blockquote><p>按位逻辑运算符，也叫逐位逻辑运算符，留意下与位运算相关的赋值运算符即可</p></blockquote><h4 id="位运算的实践应用"><a href="#位运算的实践应用" class="headerlink" title="位运算的实践应用"></a>位运算的实践应用</h4><ul><li><p>尽量使用位运算取代乘(*)、除(/)、模(%)运算，因为位运算效率比它们高</p></li><li><p>用a &amp; 1来判断a的奇偶性</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>a <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"奇数"</span> <span class="token operator">:</span> <span class="token string">"偶数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>不使用第三方变量交换两个整形变量的值</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">a <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment">// a = a * b; // a = a - b; // a = a ^ b; //</span>b <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token comment">// b = a / b; // b = a + b; // b = a ^ b; //</span>a <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token comment">// a = a / b; // a = b - a; // a = a ^ b; //</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>前三种方法可能有溢出产生bug，而异或操作则不用担心，虽然省了空间，但时间增加了</p></blockquote><h4 id="按位亦或的特点"><a href="#按位亦或的特点" class="headerlink" title="按位亦或的特点"></a>按位亦或的特点</h4><ul><li>a ^ 0 = a  </li><li>a ^ a = 0 </li><li> a ^ b = b ^ a </li><li> (a ^ b) ^ c == a ^ (b ^ c) == (a ^ c) ^ b</li></ul><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><blockquote><p>当一个表达式中同时使用多个运算符时</p></blockquote><ul><li>会根据运算符的优先级和结合性，来决定运算符的执行顺序</li><li>优先级越高(优先级值越小，越先被执行)</li><li>优先级一样，根据结合性决定执行顺序</li><li>为了确保优先级和代码可读性，应该多使用小括号</li></ul><p><img src="http://tc.holychen.cn/image/image-20210614174400172.png"></p><p><img src="http://tc.holychen.cn/image/image-20210614174521168.png"></p><p><img src="http://tc.holychen.cn/image/image-20210614174755974.png"></p><h3 id="赋值运算符-Assignment-Operators"><a href="#赋值运算符-Assignment-Operators" class="headerlink" title="赋值运算符(Assignment Operators)"></a>赋值运算符(Assignment Operators)</h3><p><img src="http://tc.holychen.cn/image/image-20210614175437229.png"></p><h3 id="自增-自减运算符"><a href="#自增-自减运算符" class="headerlink" title="自增/自减运算符"></a>自增/自减运算符</h3><blockquote><p>自增/自减运算符(Increment/Decrement Operators)包括了</p></blockquote><ul><li><p>前缀(prefix)</p><ul><li>自增运算符：++a</li><li>自减运算符：–a</li></ul></li><li><p>后缀(postfix)</p><ul><li>自增运算符：a++</li><li>自减运算符：a–</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">b <span class="token operator">=</span> a<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//等效于下面3句代码</span>tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>a <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>b <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token operator">++</span> <span class="token operator">+</span> a<span class="token operator">++</span> <span class="token operator">+</span> a<span class="token operator">++</span> <span class="token operator">+</span> a<span class="token operator">++</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//MSVC: b = 1 + 1 + 1 + 1 = 4</span><span class="token comment">//MinG: b = 1 + 2 + 3 + 4 = 10</span><span class="token comment">//不容易理解，可读性差，结果具有不确定性</span><span class="token comment">//不建议在实际开发中变编写此类代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="最大吞噬规则-maximal-much"><a href="#最大吞噬规则-maximal-much" class="headerlink" title="最大吞噬规则(maximal much)"></a>最大吞噬规则(maximal much)</h4><ul><li>当多个运算符紧挨在一起时，编译器会按照最大吞噬规则去解析</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">++</span><span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token comment">// 2 2 3</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等价于int c = (a++) + b;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="比较运算符-Comparison-Operators"><a href="#比较运算符-Comparison-Operators" class="headerlink" title="比较运算符(Comparison Operators)"></a>比较运算符(Comparison Operators)</h3><ul><li>比较运算符，也称为关系运算符(Relational Operators)</li><li>比较运算符的结果只可能是整数0和1</li></ul><p><img src="http://tc.holychen.cn/image/image-20210614182554844.png"></p><h3 id="逻辑运算符-Logical-Operators"><a href="#逻辑运算符-Logical-Operators" class="headerlink" title="逻辑运算符(Logical Operators)"></a>逻辑运算符(Logical Operators)</h3><p>在C语言中，任何值都有真假性</p><ul><li>任何非0的值都为”真”(比如59、1、-17、6.4、0.1、1.0、”123”、’K’等)</li><li>只有数值0才为”假”(比如0、0.0、’\0’等)</li></ul><p><img src="http://tc.holychen.cn/image/image-20210614183223550.png"></p><blockquote><p>逻辑运算符的运算数可以是任何值，它的运算结果要么是真、要么是假</p></blockquote><ul><li>运算结果为真，就返回整数1</li><li>运算结果为假，就返回整数0</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token operator">!</span><span class="token string">'666'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>在表示范围的时候，逻辑与(&amp;&amp;)是取交集(∩)，逻辑或(||)是取并集(∪)</p></blockquote><h4 id="逻辑与的短路现象"><a href="#逻辑与的短路现象" class="headerlink" title="逻辑与的短路现象"></a>逻辑与的短路现象</h4><blockquote><p>a &amp;&amp; b</p></blockquote><ul><li><p>如果a为假，就不会再去执行代码b。因为不管b是真是假，运算结果都为假</p></li><li><p>如果a为真，就还需要执行代码b。因为得知b是真是假，才知道运算结果</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token operator">++</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">++</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="逻辑或的短路现象"><a href="#逻辑或的短路现象" class="headerlink" title="逻辑或的短路现象"></a>逻辑或的短路现象</h4><blockquote><p>a || b</p></blockquote><ul><li><p>如果a为真，就不会再去执行代码b。因为不管b是真是假，运算结果都为真</p></li><li><p>如果a为假，就还需要执行代码b。因为得知b是真是假，才知道运算结果</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token operator">++</span>a <span class="token operator">||</span> b<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>短路现象可以减少一些不必要的代码的执行，缩短了程序的执行时间</p></blockquote><h3 id="条件运算符-Conditional-Operator"><a href="#条件运算符-Conditional-Operator" class="headerlink" title="条件运算符(Conditional Operator)"></a>条件运算符(Conditional Operator)</h3><ul><li>条件运算符，一般也叫作三目运算符、三元运算符</li><li>a ? b : c<ul><li>如果a为真，就返回b</li><li>如果a为假，就返回c</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//将整形变量a、b、c中的最大值打印出来</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span><span class="token comment">// 33</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">:</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">?</span> b <span class="token operator">:</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**int a = 11, b = 22, c = 33;int d = (a >b) ? a : b;d = (c > d) ? c : d;// 33printf("%d\n",d);**/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//如果字符变量c是小写字母，就转成大写字母;否则保持原样</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'g'</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">>=</span> <span class="token string">'a'</span> <span class="token operator">%</span><span class="token operator">%</span> c <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token string">'a'</span> <span class="token operator">+</span> <span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token operator">:</span> c<span class="token punctuation">;</span><span class="token comment">// G</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//有一个字符变量c，如果它是小写字母，就转成大写字母；如果它是大写字母，就转成小写字母；否则保持原样</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'G'</span><span class="token punctuation">;</span><span class="token keyword">int</span> diff <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">-</span> <span class="token string">'A'</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">>=</span> <span class="token string">'a'</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> diff<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">>=</span> <span class="token string">'A'</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token string">'Z'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> diff<span class="token punctuation">)</span> <span class="token operator">:</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// g</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逗号运算符-Comma-Operator"><a href="#逗号运算符-Comma-Operator" class="headerlink" title="逗号运算符(Comma Operator)"></a>逗号运算符(Comma Operator)</h3><p>(a, b,  ……)</p><ul><li>从左到右依次执行表达式</li><li>返回最后一个表达式的运算结果</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">,</span> a <span class="token operator">=</span> a <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">10</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> a<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 11 10</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="流程控制-Flow-Control"><a href="#流程控制-Flow-Control" class="headerlink" title="流程控制(Flow Control)"></a>流程控制(Flow Control)</h2><blockquote><p>按照执行程序流程的不同，可以将平时编写的代码分成3大结构</p></blockquote><ul><li><p>顺序结构：默认的流程结构，按照代码的书写顺序执行每一句代码</p></li><li><p>选择结构：根据表达式的真假性，来决定执行哪一段代码</p></li><li><p>循环结构：在表达式为真的情况下，重复执行某一段代码</p></li></ul><p><img src="http://tc.holychen.cn/image/image-20210614210008968.png"></p><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p><img src="http://tc.holychen.cn/image/image-20210614210142416.png"></p><blockquote><p>if语句陷阱</p></blockquote><ul><li>表达式后面多加分号，变成空语句</li><li>判断相等时 == 误写成赋值 =</li></ul><h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if - else语句"></a>if - else语句</h4><p><img src="http://tc.holychen.cn/image/image-20210614210250588.png"></p><h5 id="if语句-vs-if-else语句"><a href="#if语句-vs-if-else语句" class="headerlink" title="if语句 vs if-else语句"></a>if语句 vs if-else语句</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// if else语句          </span><span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">60</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>                          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"及格"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>                      <span class="token keyword">else</span>                   <span class="token punctuation">&#123;</span>                         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"不及格"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token comment">// 多个if语句</span><span class="token keyword">int</span> score <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"及格"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"不及格"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>if-else语句能实现的功能，完全也可以用多个if实现，更推荐if-else的写法</p></blockquote><ul><li>if-else代码更简洁，省掉了不必要的”score &lt; 60”的判断</li><li>if-else的代码执行效率更高，只需要进行1次表达式判断：”score &gt;=  60”</li></ul><h4 id="else-if语句"><a href="#else-if语句" class="headerlink" title="else if语句"></a>else if语句</h4><p><img src="http://tc.holychen.cn/image/image-20210614211634375.png"></p><blockquote><p>输入一个整数代表分数，根据分数输出等级(A-E)</p></blockquote><ul><li>A：90-100 ——B：80-89——C：70-79——D：60-69——E：0-59</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//较复杂的写法</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">90</span> <span class="token operator">&lt;=</span> score <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">80</span> <span class="token operator">&lt;=</span> score <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">89</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">70</span> <span class="token operator">&lt;=</span> score <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">79</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">&lt;=</span> score <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">69</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> score <span class="token operator">&amp;&amp;</span> score <span class="token operator">&lt;=</span> <span class="token number">60</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"非法输入"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//更简单的写法</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> score <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"非法输入"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">90</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">80</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">70</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">60</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>else-if语句注意点</p></blockquote><ul><li>else if中在对合法输入作限定后，应该将小范围写在前面，大范围写在后面</li><li>更推荐下面简单的写法，省掉了不必要的判断，代码执行效率更高</li></ul><h5 id="if语句-vs-else-if语句"><a href="#if语句-vs-else-if语句" class="headerlink" title="if语句 vs else if语句"></a>if语句 vs else if语句</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//下面两段代码的功能是不一样的</span><span class="token comment">//只有其中一个printf会被执行</span><span class="token keyword">int</span> price <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment">//[100,+∞)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"太贵了\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token comment">//[50,100]</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"还行吧\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">//[10,50]</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"很便宜\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//有可能三个printf都会被执行</span><span class="token keyword">int</span> price <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment">//[100,+∞)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"太贵了\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token comment">//[50,+∞)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"还行吧\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>price <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">//[10,+∞)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"很便宜\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当多段代码中，只需要选择其中一段来执行时，建议用else if语句</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"负数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当多段代码可能都要被执行时，不能用else if语句</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"奇数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>if、else后可以省略大括号，只会跟其后的第一条语句进行关联</li><li>多个if出现，else后会跟其前面最接近的if相关联</li></ul><p>if语句 ——编译错误</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> price <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>price <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"太贵了\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"买不起\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//夹在if与else中间 编译错误</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"不算贵\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//注意if和else语句中变量的作用域</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token comment">//编译错误</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编译错误</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编译错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="if-else语句-vs-条件运算符"><a href="#if-else语句-vs-条件运算符" class="headerlink" title="if-else语句 vs 条件运算符"></a>if-else语句 vs 条件运算符</h5><blockquote><p>有一些简单的if-else语句，可以使用条件运算符来替代，以达到简化代码的目的</p></blockquote><h5 id="表达式的等价性"><a href="#表达式的等价性" class="headerlink" title="表达式的等价性"></a>表达式的等价性</h5><p><img src="http://tc.holychen.cn/image/image-20210615002038095.png"></p><p><img src="../Image/image-20210615004111109.png" alt="image-20210615004111109"></p><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p><img src="http://tc.holychen.cn/image/image-20210615012149409.png"></p><h5 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h5><blockquote><p>在switch语句中，break语句的作用：中止switch语句</p></blockquote><blockquote><p>如果case、default后面没有break语句，会出现”贯穿”现象</p></blockquote><ul><li>执行完case、default中的代码后，会继续往下执行其他case、default中的代码</li><li>直到遇到break语句或switch语句的结尾为止</li></ul><p><img src="http://tc.holychen.cn/image/image-20210615013058625.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//利用贯穿</span><span class="token keyword">switch</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>    <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>    <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"春季"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="case的使用注意"><a href="#case的使用注意" class="headerlink" title="case的使用注意"></a>case的使用注意</h5><ul><li>case后面紧跟的表达式不能带有变量</li><li>如果想在case后面声明新的变量，那就必须加上大括号，否则编译报错</li></ul><p><img src="http://tc.holychen.cn/image/image-20210615013722743.png"></p><h5 id="if和switch之间可以相互替代"><a href="#if和switch之间可以相互替代" class="headerlink" title="if和switch之间可以相互替代"></a>if和switch之间可以相互替代</h5><p><img src="http://tc.holychen.cn/image/image-20210615014351578.png"></p><h5 id="if和switch的选择"><a href="#if和switch的选择" class="headerlink" title="if和switch的选择"></a>if和switch的选择</h5><ul><li>当表示一个范围时，建议使用if</li><li>当判断一个变量是否等于一些固定值时，if、switch均可使用</li></ul><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><blockquote><p>很多时候，使用while、do-while、for可以完成一样的功能，只是书写格式不一样</p></blockquote><blockquote><p>在实际开发中，使用频率最多的是for、while</p></blockquote><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><p><img src="http://tc.holychen.cn/image/image-20210615020526675.png"></p><h5 id="while固定次数的打印"><a href="#while固定次数的打印" class="headerlink" title="while固定次数的打印"></a>while固定次数的打印</h5><p><img src="http://tc.holychen.cn/image/image-20210615021115016.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//1 - 2 + 3 - 4 + 5 - 6 ... + n</span><span class="token keyword">int</span> value  <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>value <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    sum <span class="token operator">+=</span> <span class="token punctuation">(</span>value <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> value <span class="token operator">:</span> <span class="token operator">-</span>value<span class="token punctuation">;</span>value<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h4><p><img src="http://tc.holychen.cn/image/image-20210615025028050.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">do</span><span class="token punctuation">&#123;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入1-100之间的正整数："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p><img src="http://tc.holychen.cn/image/image-20210615023222797.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//请从小到大打印出3、5的前10个公倍数</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="for-语句-vs-while语句"><a href="#for-语句-vs-while语句" class="headerlink" title="for 语句 vs while语句"></a>for 语句 vs while语句</h5><p><img src="http://tc.holychen.cn/image/image-20210615023511753.png"></p><blockquote><p>break语句</p></blockquote><ul><li><p>break语句只用在while、do-while、for、switch语句中</p></li><li><p>break语句的作用：终止其所在的while、do-while、for、switch语句</p></li><li><p>在有多重循环的情况下，break语句只能终止其所在的那一层循环语句</p></li></ul><p><img src="http://tc.holychen.cn/image/image-20210615033735730.png"></p><blockquote><p>continue语句</p></blockquote><ul><li>continue语句只用在while、do-while、for语句中</li><li>continue语句的作用：跳过循环体的剩余部分</li><li>在有多重循环的情况下，continue语句只能作用于其所在的那一层循环语句</li><li>很多时候，巧用continue，可以减少大括号、缩进的数量</li></ul><p><img src="http://tc.holychen.cn/image/image-20210615034211558.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><ul><li>goto语句的作用：可以为所欲为地灵活跳转</li><li>goto语句使用起来非常灵活，在有些情况下，还能提高程序的效率</li><li>但goto语句破坏了结构化的设计风格，容易造成代码执行流程的混乱，导致代码难以调试和维护</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据类型, 分支, 循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIOS ROM Image分析</title>
      <link href="2021/08/01/BIOS%20ROM%20Image/"/>
      <url>2021/08/01/BIOS%20ROM%20Image/</url>
      
        <content type="html"><![CDATA[<h1 id="Flash芯片"><a href="#Flash芯片" class="headerlink" title="Flash芯片"></a>Flash芯片</h1><blockquote><p>之前Desktop的案子，BIOS 由一块32M的Nor Flash存储，还有一块Flash做PDR Region</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/86ed9927664912afa5ce9778ee3f498.jpg" alt="主板上的NorFlash"></p><h1 id="生成的BIOS-Bin"><a href="#生成的BIOS-Bin" class="headerlink" title="生成的BIOS Bin"></a>生成的BIOS Bin</h1><blockquote><p>BIOS编译过程中会根据不同的xml file生成对应的BIOS bin文件，xml file可以用Intel提供的Fit.exe工具解析</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604388851409.png" alt="FPT整刷的bin"></p><h1 id="Intel闪存映像布局"><a href="#Intel闪存映像布局" class="headerlink" title="Intel闪存映像布局"></a>Intel闪存映像布局</h1><p>英特尔在相应芯片组的数据表页面上讨论了BIOS的结构。对于所有从第六系列开始的芯片组，此格式通常保持不变，该文件分为3-5个区域，可选的是GbE区域和PDR。</p><p><img src="../../../Work_Area/Typora/Image/image-20210804112152776.png" alt="image-20210804112152776"></p><h1 id="UEFI-Tool解析"><a href="#UEFI-Tool解析" class="headerlink" title="UEFI Tool解析"></a>UEFI Tool解析</h1><blockquote><p>用开源<a href="https://github.com/LongSoft/UEFITool">EFITool</a>工具加载了编译生成的bin文件，AMI有自己的MMtool</p></blockquote><p>可以发现Reset Vector位于BIOS Rom Image的最底部，探索形成这样的Image结构相关的各种文件(.fdf/.fd/.fv等文件)</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604389109072.png"></p><p>组成结构：16M BIOS + 16M ME ，PDR Regin存在备用的PDR Flash上</p><p>BIOS Rom部分，由GenFv工具根据fdf文件生成，根据代码的定义的Flash Layout相关的Token Veb会自动生成fdf，前面的部分描述了Flahs Layout的布局，详细列出各个FV的起始地址和Size，edk2的话fdf则需要自己写</p><pre class="line-numbers language-none"><code class="language-none">#FD Section[FD.AMIROM]BaseAddress &#x3D; 0xff000000Size &#x3D; 0x1000000ErasePolarity &#x3D; 1BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x1000DEFINE UNCOMPRESSED_PEI_EXECUTABLES_ALIGNMENT &#x3D;  DEFINE SEC_CORE_EXECUTABLE_ALIGNMENT &#x3D; Align &#x3D; 8......0x0|0x20000FV &#x3D; LNV_OEM_DATA_REGION0x20000|0x50000FV &#x3D; NVRAM0x70000|0x50000#RAW - NVRAM_BACKUP0xc0000|0x20000FV &#x3D; LEM_FV_DATA0xe0000|0x870000FV &#x3D; FV_MAIN_WRAPPER0x950000|0x20000FV &#x3D; FV_CMP0x970000|0x10000FV &#x3D; FV_BCP0x980000|0x110000FV &#x3D; FV_DATA_BACKUP0xa90000|0x110000FV &#x3D; FV_DATA0xba0000|0xa0000FV &#x3D; FV_BB_AFTER_MEMORY_BACKUP0xc40000|0x90000FV &#x3D; FV_FSP_S_BACKUP0xcd0000|0xa0000FV &#x3D; FV_BB_AFTER_MEMORY0xd70000|0x90000FV &#x3D; FV_FSP_S0xe00000|0x70000#FV_FSP_BACKUPFILE &#x3D; Build&#x2F;Fsp_Rebased_M_T.fd0xe70000|0x90000FV &#x3D; FV_BB_BACKUP0xf00000|0x70000#FV_FSPFILE &#x3D; Build&#x2F;Fsp_Rebased_M_T.fd0xf70000|0x90000FV &#x3D; FV_BB#FV Section[FV.FV_MAIN]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x0FvAlignment &#x3D; 16MEMORY_MAPPED &#x3D; TRUEFvNameGuid &#x3D; 5C60F367-A505-419A-859E-2A4FF6CA6FE5APRIORI DXE &#123;INF AmiModulePkg&#x2F;AmiStatusCode&#x2F;StatusCodeDxe.infINF AmiModulePkg&#x2F;AmiStatusCode&#x2F;StatusCodeSmm.infINF MdeModulePkg&#x2F;Universal&#x2F;PCD&#x2F;Dxe&#x2F;Pcd.inf......!include AmiPkg&#x2F;Configuration&#x2F;FontFileStatement.txt!include AmiModulePkg&#x2F;NVRAM&#x2F;FvMainDefaultsFdfFileStatement.txt!include AmiChipsetModulePkg&#x2F;LegacyRom&#x2F;Vbios&#x2F;VbiosFdfFileStatements.txt......#FV Section[FV.FV_LOGOROMHOLE]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x20FvAlignment &#x3D; 1......FvNameGuid &#x3D; E54D9684-2735-43ef-A379-30F2F592BA10!include AmiTsePkg&#x2F;Core&#x2F;em&#x2F;AMITSE&#x2F;Logoffs.txt#FV Section[FV.FV_MEFW_CAPSULE]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x600FvAlignment &#x3D; 16......FvNameGuid &#x3D; 9F8B1DEF-B62B-45F3-8282-BFD7EA19801BINF RuleOverride &#x3D; SubtypeGuidUncompressedNoChecksum Build&#x2F;MeFwFid.inf......!include AmiModulePkg&#x2F;Ofbd&#x2F;Meud&#x2F;AutoMeud&#x2F;MeRegionFdfFileStatement.txt#FV Section[FV.LNV_OEM_DATA_REGION]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x20FvAlignment &#x3D; 1......#FV Section[FV.NVRAM]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x50FvAlignment &#x3D; 16......FvNameGuid &#x3D; FA4974FC-AF1D-4E5D-BDC5-DACD6D27BAEC!include AmiModulePkg&#x2F;NVRAM&#x2F;NvramFdfFileStatement.txt#FV Section[FV.LEM_FV_DATA]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x20FvAlignment &#x3D; 16......FvNameGuid &#x3D; 4f1c52d3-d824-4d2a-a2f0-ec40c23c5916INF RuleOverride &#x3D; SubtypeGuidUncompressedNoChecksum ......!include AmiTsePkg&#x2F;Core&#x2F;em&#x2F;AMITSE&#x2F;Romhole.txt#FV Section[FV.FV_CMP]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x20FvAlignment &#x3D; 16......FvNameGuid &#x3D; aea406cf-4fc8-4dc3-9796-1ee03b64c715!include LenovoModulePkg&#x2F;Universal&#x2F;ExtendedComputrace&#x2F;AbsolutePkg&#x2F;OEMSpecifiedAgentX64ProductionInstaller.txt#FV Section[FV.FV_BCP]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x10FvAlignment &#x3D; 16......FvNameGuid &#x3D; 8649FC2D-C0E6-4262-AD51-0CEABAB6429EINF RuleOverride &#x3D; Uncompressed PldmPkg&#x2F;BiosConfigPreserve&#x2F;BiosConfigPreserveBin&#x2F;BCPFlashData&#x2F;BCPFlashData.inf#FV Section[FV.FV_DATA_BACKUP]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x110FvAlignment &#x3D; 16......FvNameGuid &#x3D; E4A068F1-5EF1-4ACE-857C-7935F8A0C708!include CrbPkg&#x2F;AmiCrbIntelTopSwap&#x2F;FvDataBackupFdfFileStatement.txt#FV Section[FV.FV_DATA]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x110FvAlignment &#x3D; 16......FvNameGuid &#x3D; AFDD39F1-19D7-4501-A730-CE5A27E1154BINF RuleOverride &#x3D; UncompressedBinaryNoChecksum AmiChipsetModulePkg&#x2F;FIT&#x2F;ReserveBinary&#x2F;ReserveBootGuardSaveResigndata.inf!include AmiChipsetModulePkg&#x2F;FIT&#x2F;FitTable&#x2F;FitMicrocodeFdfFileStatement.txt#FV Section[FV.FV_BB_AFTER_MEMORY_BACKUP]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0xa0FvAlignment &#x3D; 16......FvNameGuid &#x3D; 5b08a058-784f-4938-9a49-1588aa05f4b9......#FV Section[FV.FV_FSP_S_BACKUP]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x90FvAlignment &#x3D; 16!include Intel&#x2F;CometLakeFspBinPkg&#x2F;FvFspSFdfFileStatement.txt#FV Section[FV.FV_BB_AFTER_MEMORY]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0xa0FvAlignment &#x3D; 16......#FV Section[FV.FV_FSP_S]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x90FvAlignment &#x3D; 16!include Intel&#x2F;CometLakeFspBinPkg&#x2F;FvFspSFdfFileStatement.txt......#FV Section[FV.FV_BB_BACKUP]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x90FvBaseAddress &#x3D; 0xfff70000......FvNameGuid &#x3D; 61C0F511-A691-4F54-974F-B9A42172CE53APRIORI PEI &#123;INF AmiModulePkg&#x2F;AmiStatusCode&#x2F;StatusCodePei.infINF AmiModulePkg&#x2F;IO&#x2F;NCT6686D&#x2F;NCT6686DPeiInit.inf......!include Build&#x2F;BiosGuardPubKeyhash_FdfFileStatement.txt!include AmiChipsetModulePkg&#x2F;FIT&#x2F;FitTable&#x2F;FitTableFdfFileStatement.txt!include LenovoModulePkg&#x2F;Universal&#x2F;BuildNaming&#x2F;BuildNaming.txt#FV Section[FV.FV_BB]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x90FvAlignment &#x3D; 16......FvNameGuid &#x3D; 61C0F511-A691-4F54-974F-B9A42172CE53APRIORI PEI &#123;INF AmiModulePkg&#x2F;AmiStatusCode&#x2F;StatusCodePei.infINF AmiModulePkg&#x2F;IO&#x2F;NCT6686D&#x2F;NCT6686DPeiInit.infINF LenovoModulePkg&#x2F;Universal&#x2F;AssetID&#x2F;AssetIDOnRecoveryMode&#x2F;AssetIDOnRecoveryModePei.inf......!include AmiChipsetModulePkg&#x2F;BiosGuard&#x2F;Binary&#x2F;BiosGuardBinary_FdfFileStatement.txt!include Intel&#x2F;CometLakePlatSamplePkg&#x2F;Binaries&#x2F;Pct&#x2F;PctGpioFdfFileStatements.txt!include ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>fdf文件的开头部份是关键字[fd]，它表示完整的BIOS Rom Image。还指定了BIOS的加载地址BaseAddress = 0xff00000，大小Size = 0x1000000(16M)，这与UEFITool给出的数据不谋而合：</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604389689841.png"></p><blockquote><p>根据BIOS Rom Image位于4G空间的顶部(0xFFFFFFFF)，减去Rom Image Size推算下可以推出Bios Rom加载地址(就是Fdf文件中的BaseAddress=0xff000000)</p></blockquote><blockquote><p>接下来形如下列内容，则是在FD中开辟了一段连续空间，用来存放FV/FILE等内容。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">Offset|Size[RegionType]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中Offset和Size是这段空间的相对于整个FD的偏移和大小；前面UEFITool图中”BIOS Region”中列出的每一个FFS项都可以对应到Fdf文件[FD]节中RegionType为FV的项(毕竟只有FV才会用到文件系统FFS)。如果仔细比对，可能会发现UEFITool中倒数第二和倒数第三个FFS的Size和Padding相加正好对应[FD]节中的FV_FSP：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604389914494.png"></p><pre class="line-numbers language-none"><code class="language-none">0xf00000|0x70000#FV_FSPFILE &#x3D; Build&#x2F;Fsp_Rebased_M_T.fd\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>FV_FSP项的RegionType是FILE，可以包含任意内容，自然也可以包含其他的fd文件，就如NCB_LOGO项中包含了开机Logo文件；其次，fd文件又由fv组成，UEFITool又能解析fd文件，因此造成了这种FDF和BIOS Rom image不一致。其实，我们可以用UEFITool加载Fsp_Rebuild_M_T.fd，发现其中包含两个FFS：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604390180438.png"></p><p>如果FV_FSP包含的fd文件是经过压缩操作的，那么FDF文件中RegionType为FV的项应该和UEFITool实际得到的相一致。</p><p>FDF文件[FD]节之后就是大量的[FV]节，FV的主要作用就是包含组件和模块。他们来填充[FD]节中开辟的空间。先来看一个相对简单的FV节：FV.NVRAM，它只包含一个include语句，指向NvramFdfFileStatement.txt文件:</p><pre class="line-numbers language-none"><code class="language-none">!include AmiModulePkg&#x2F;NVRAM&#x2F;NvramFdfFileStatement.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>NvramFdfFileStatement.txt文件通过FILE指令，包含binary file：</p><pre class="line-numbers language-none"><code class="language-none">FILE RAW &#x3D; CEF5B9A3-476D-497f-9FDC-E98143E0422C &#123;  $(OUTPUT_DIRECTORY)&#x2F;Nvram.bin&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>FV的主要作用就是填充[FD]节中开辟的空间，用这个FV节验证一下：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391042176.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391071513.png"></p><p>FDF中，FV.Nvram位于Bios Rom image的开头，Fv guid：FA4974FC-AF1D-4E5D-BDC5-DACD6D27BAEC，NvramFdfFileStatement.txt中指定的File Guid：CEF5B9A3-476D-497f-9FDC-E98143E0422C；用UEFITool加载Bios Rom image，第一个FFS(就是FV.Nvram)的Volume GUID: FA4974FC-AF1D-4E5D-BDC5-DACD6D27BAEC；再展开FFS，其中包含的唯一的文件的File Guid: CEF5B9A3-476D-497F-9FDC-E98143E0422C，这些值和FDF中的Fv Guid以及File Guid是一致的。<br>除了File Guid是一致的，用UEFITool解压后得到的Nvram.bin和原始的Nvram.bin的内容也是一致的：</p><p>以上是简单的FV的情况，有些复杂的FV中可以嵌套其它的FV的操作，如FDF中的FV.FV_MAIN_WRAPPER，</p><pre class="line-numbers language-none"><code class="language-none">#FV Section[FV.FV_MAIN_WRAPPER]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x870......!include AmiPkg&#x2F;Configuration&#x2F;NestedFvMainFdfFileStatement.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>FV.FV_MAIN_WRAPPER节中内容不多，仅仅含有若干条!include语句，但是FV.FV_MAIN_WRAPPER节占据BIOS Rom Image很大一块空间：BlockSize<em>NumBlocks=0x1000</em>0x870=0x870000。它占用如此多空间的原因是NestedFvMainFdfFileStatement.txt通过FILE指令包含了一块压缩的FV文件，而该FV文件是Dxe阶段的代码</p><p>NestedFvMainFdfFileStatement.txt的内容如下：</p><pre class="line-numbers language-none"><code class="language-none">#Includes FVMAIN FV imageFILE FV_IMAGE &#x3D; 9E21FD93-9C72-4c15-8C4B-E77F1DB2D792 $(FFS_FILE_CHECKSUM_KEYWORD) &#123;  SECTION $(PEI_COMPRESSION_SECTION) &#123;    SECTION FV_IMAGE &#x3D; FV_MAIN  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>FV_MAIN节内容如下：</p><pre class="line-numbers language-none"><code class="language-none">#FV Section[FV.FV_MAIN]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0x0FvAlignment &#x3D; 16......INF AmiModulePkg&#x2F;RomLayout&#x2F;RomLayoutDxe.infINF MdeModulePkg&#x2F;Core&#x2F;Dxe&#x2F;DxeMain.infINF AmiModulePkg&#x2F;Bds&#x2F;Bds.inf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前面找到Dxe阶段的代码，那Sec和Pei阶段的代码在哪？platform.fdf文件[fd]节中设定FV_BB节位于Bios Rom image的尾部，因此，我们可以猜测并验证Sec模块和Pei模块也位于FV_BB中：</p><pre class="line-numbers language-none"><code class="language-none">[FV.FV_BB]BlockSize &#x3D; 0x1000NumBlocks &#x3D; 0xa0...APRIORI PEI &#123; ;PEI阶段的APRIORI文件INF AmiModulePkg&#x2F;AmiStatusCode&#x2F;StatusCodePei.inf    ...&#125;...INF MdeModulePkg&#x2F;Core&#x2F;Pei&#x2F;PeiMain.inf ;Pei阶段入口...INF UefiCpuPkg&#x2F;SecCore&#x2F;SecCore.inf ;Sec阶段入口...INF UefiCpuPkg&#x2F;CpuIoPei&#x2F;CpuIoPei.infINF MdeModulePkg&#x2F;Universal&#x2F;PcatSingleSegmentPciCfg2Pei&#x2F;PcatSingleSegmentPciCfg2Pei.inf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然，我们已经确定Sec模块和Pei模块位于FV_BB块中，但是有个问题随之出现：SecCore.inf并不是FV_BB中最后一个模块(夹在其他模块之间)，所以一眼看去感觉开机时执行的第一条指令并不在SecCore模块中，这明显与EFI Spec相悖。更何况SecCore.inf含有ResetVector：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391678324.png" alt="SecCore.inf部分内容"></p><p>另外，UEFITool也明显显示SecCore位于Bios Rom image尾部</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391761934.png"></p><p>fdf的设定和实际现象有差异，那一定是GenFv在生成Bios Rom image时有特殊处理。和GenFv Build Bios相关的只能查看Build.log，它记录了从源码到制成Rom Image的全过程，在Build.log的结尾，记录了各个模块在Bios Rom Image的排列位置，有个特殊的Firmware Volumon:08 No.049 类型是SECC—-SecCore，属性被标记为VTF，Bios Rom Image中其他FV中任何模块都不具有该属性：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604391860137.png"></p><p>在PI spec Vol3中提到：</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604392019507.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604392038413.png"></p><p>VTF是Volume Top File的缩写，PI spec规定VTF的File Guid为EFI_FFS_VOLUME_TOP_FILE_GUID（1BA0062E-C779-4582-8566-336AE8F78F09），必须位于firmware volume的最后一个字节。而SecCore.inf的FILE_GUID = 1BA0062E-C779-4582-8566-336AE8F78F09。猜测只要某个inf指定自己FILE_GUID为EFI_FFS_VOLUME_TOP_FILE_GUID就有机会被安排在最开始执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flash, Layout, FV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OemWmi Demo</title>
      <link href="2021/08/01/OemWmi%20Demo/"/>
      <url>2021/08/01/OemWmi%20Demo/</url>
      
        <content type="html"><![CDATA[<h1 id="WMI简介"><a href="#WMI简介" class="headerlink" title="WMI简介"></a>WMI简介</h1><h2 id="WMI历史"><a href="#WMI历史" class="headerlink" title="WMI历史"></a>WMI历史</h2><p>Windows Management Instrumentation（WMI）是Microsoft基于Web的企业管理（WBEM）的实现，WBEM是一项行业倡议，旨在开发用于在企业环境中访问管理信息的标准技术。WMI使用通用信息模型（CIM）行业标准来表示系统，应用程序，网络，设备和其他托管组件。CIM由分布式管理任务组（<a href="https://www.dmtf.org/standards/wsman">DMTF</a>）开发和维护。WMI最初于1998年作为Windows NT 4.0 Service Pack 4的附加组件发布，是Windows 2000，Windows XP和Windows Server 2003家族操作系统中内置的支持核心管理的技术。(详情见微软官网<a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/about-wmi">WMI Document</a>)。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在WMI之前，可以通过编程方式访问Windows资源的唯一方法是通过Win32 API。 这种情况使Windows系统管理员无法轻松地使用流行的脚本语言来自动化常见的系统管理任务，因为大多数脚本语言无法直接调用Win32 API。 WMI通过提供一个一致的模型和框架来描述所有Windows资源并将其公开给外界，从而改变了这种状况。 WMI是一种工具和管道，通过它可以访问，配置，管理和监视所有（几乎所有）Windows资源，系统管理员可以使用WMI脚本库创建系统管理脚本，以管理通过WMI公开的任何Windows资源！</p><h2 id="BIOS与WMI的关系"><a href="#BIOS与WMI的关系" class="headerlink" title="BIOS与WMI的关系"></a>BIOS与WMI的关系</h2><p>通常，BIOS不需要为WMI做任何事情，Windows提供了Windows管理所需的所有WMI。 但是有时候，客户想要实现特殊的OEM功能，则需要BIOS通过WMI与AP / Driver配合，例如在CML 7C43&amp;P340 Project中Lenovo Module通过LenovoGameZone.mof和Lenovo.mof作为Provider，声明BIOS提供给OS的WMI接口。<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383419998.png"></p><h2 id="WMI架构图"><a href="#WMI架构图" class="headerlink" title="WMI架构图"></a>WMI架构图</h2><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383435473.png"></p><p>wmi可以使用多种方式进行调用，具体可以参考上图：<br>首先是wm使用者，比如脚本或者其他用到wm接口的应用程序。由wm使用者访问CIM对象管理器WinMgmt(即WMI服务）,后者再访问CIM(公共信息模型Common Information Model)存储库。静态或动态的信息（对象的属性）就保存在CM库中，同时保存对象的方法。比如启动一个服务，通过执行对象的方法实现，实际上是通过COM技术调用各种dll,最后由dll中封装的API完成请求。WMI是事件驱动的，操作系统、服务、应用程序、设备驱动程序等都可以作为事件源，通过COM接口生成事件通知，WinMgmt捕捉到事件，然后刷新CM库中的动态信息。这也是为什么WM服务依赖于EventLog的原因。就像注册表有Key和Value一样，CIM库也有分类，用面向对象的术语描述来说，叫做命名空间（Name Space)。</p><h1 id="OemWmi-ModulePart"><a href="#OemWmi-ModulePart" class="headerlink" title="OemWmi ModulePart"></a>OemWmi ModulePart</h1><h2 id="ModulePart说明"><a href="#ModulePart说明" class="headerlink" title="ModulePart说明"></a>ModulePart说明</h2><p>建立OemWmi ModulePart，简单的封装一个接口注册到OS下，实现向80 Port写值的动作，应用层可以通过通过VB Script或C++调用。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><ul><li>OemWmi.mof</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;****************************************************&#x2F;&#x2F;filename:MyWmi.mof&#x2F;&#x2F; MOF(Managed Object File) Sample&#x2F;&#x2F; 2020.08.05&#x2F;&#x2F; MOF comment as C++#pragma AUTORECOVER&#x2F;&#x2F;WMI checks the integrity of the WMI repository when the operating system&#x2F;&#x2F;starts WMI. If the repository is damaged, WMI automatically rebuilds the &#x2F;&#x2F;repository and recompiles it.#pragma namespace(&quot;\\root\\wmi&quot;)&#x2F;&#x2F;specify the namespace when autorecover or register.[WMI, Dynamic, Provider(&quot;WmiProv&quot;), Locale(&quot;MS\\0x409&quot;), Description(&quot;My WMI Sample Class&quot;), guid(&quot;&#123;E2E0B817-EA48-4bad-81A6-FBEB8776A7AF&#125;&quot;)]&#x2F;&#x2F;WMI Class Qualifiersclass MyClass&#123;    [key, read] string InstanceName;    [read] Boolean Active;    [WmiMethodId(1),     Implemented,     read, write,     Description(&quot;Send to Port 0x80&quot;)    ]void SendTo80([in] uint8 Data);&#125;;&#x2F;&#x2F;Required Items in WMI Class&#x2F;&#x2F;*****************************************************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>OemWmi.sdl</li></ul><pre class="line-numbers language-none"><code class="language-none"> PCIDEVICE    Title  &#x3D; &quot;OemWmi&quot;    Parent  &#x3D; &quot;PciHost (Virtual)&quot;    Attribute  &#x3D; &quot;0x0&quot;      Dev_type  &#x3D; &quot;Container&quot;    Dev  &#x3D; 00h    Fun  &#x3D; 00h    SleepNum  &#x3D; 01h    ASLfile  &#x3D; &quot;&#39;OemPkg\OemWmi\OemWmi.asl;After Pci Tree&#39;&quot;    DeviceType &#x3D; OnBoard    PCIBusSize &#x3D; 32bit    ROMMain &#x3D; No    Virtual &#x3D; YesEndTOKEN    Name  &#x3D; &quot;OemWmi_INF_SUPPORT&quot;    Value  &#x3D; &quot;1&quot;    Help  &#x3D; &quot;Main switch to enable OemWmi support in Project&quot;    TokenType &#x3D; Boolean    TargetMAK &#x3D; Yes    Master &#x3D; YesEndINFComponent    Name  &#x3D; &quot;OemWmi&quot;    File  &#x3D; &quot;OemWmi.inf&quot;    Package  &#x3D; &quot;OemWmi&quot;    Token &#x3D; &quot;OemWmi_INF_SUPPORT&quot; &quot;&#x3D;&quot; &quot;1&quot;End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>OemWmi.cif</li></ul><pre class="line-numbers language-none"><code class="language-none"> PCIDEVICE    Title  &#x3D; &quot;OemWmi&quot;    Parent  &#x3D; &quot;PciHost (Virtual)&quot;    Attribute  &#x3D; &quot;0x0&quot;      Dev_type  &#x3D; &quot;Container&quot;    Dev  &#x3D; 00h    Fun  &#x3D; 00h    SleepNum  &#x3D; 01h    ASLfile  &#x3D; &quot;&#39;OemPkg\OemWmi\OemWmi.asl;After Pci Tree&#39;&quot;    DeviceType &#x3D; OnBoard    PCIBusSize &#x3D; 32bit    ROMMain &#x3D; No    Virtual &#x3D; YesEndTOKEN    Name  &#x3D; &quot;OemWmi_INF_SUPPORT&quot;    Value  &#x3D; &quot;1&quot;    Help  &#x3D; &quot;Main switch to enable OemWmi support in Project&quot;    TokenType &#x3D; Boolean    TargetMAK &#x3D; Yes    Master &#x3D; YesEndINFComponent    Name  &#x3D; &quot;OemWmi&quot;    File  &#x3D; &quot;OemWmi.inf&quot;    Package  &#x3D; &quot;OemWmi&quot;    Token &#x3D; &quot;OemWmi_INF_SUPPORT&quot; &quot;&#x3D;&quot; &quot;1&quot;End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>OemWmi.asl</li></ul><pre class="line-numbers language-none"><code class="language-none">Scope( \_SB )&#123; Device(WMI2)&#123;        &#x2F;&#x2F; PNP0C14 is Plug and Play ID assigned to WMI mapper    Name(_HID, EISAID(&quot;PNP0C14&quot;))    Name(_UID, 2)        &#x2F;&#x2F;        &#x2F;&#x2F; _WDG evaluates to a data structure that specifies the data        &#x2F;&#x2F; blocks supported by the ACPI device.        &#x2F;&#x2F;    Name(_WDG, Buffer() &#123;         &#x2F;&#x2F;guid&#123;E2E0B817-EA48-4bad-81A6-FBEB8776A7AF&#125;        &#x2F;&#x2F; -------- Method execution for SendTo80            0x17, 0xb8, 0xe0, 0xe2, 0x48, 0xea, 0xad, 0x4b, 0x81, 0xa6,            0xfb, 0xeb, 0x87, 0x76, 0xa7, 0xaf,            69, 49,     &#x2F;&#x2F; Object ID (E1)            1,          &#x2F;&#x2F; Instance Count            0x02,       &#x2F;&#x2F; Flags WMIACPI_REGFLAG_METHOD             &#x2F;&#x2F; -------- MOF data            0x21, 0x12, 0x90, 0x05, 0x66, 0xd5, 0xd1, 0x11, 0xb2, 0xf0,            0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10,            66, 65,     &#x2F;&#x2F; Object ID (BA)            1,          &#x2F;&#x2F; Instance Count            0x00,       &#x2F;&#x2F; Flags    &#125;)       OperationRegion (DBG, SystemIO, 0x80, 0x2)   Field (DBG, WordAcc, NoLock, Preserve)   &#123;        P80H, 16   &#125;            Method(WME1, 3) &#123;    If(LEqual(Arg1,1))    &#123;      Store(Arg2,P80H)    &#125;         Return(0)        &#125;    Name(WQBA, Buffer()    &#123;    0x46, 0x4f, 0x4d, 0x42, 0x01, 0x00, 0x00, 0x00, 0x74, 0x02, 0x00, 0x00, 0x80, 0x05, 0x00, 0x00,    0x44, 0x53, 0x00, 0x01, 0x1a, 0x7d, 0xda, 0x54, 0x28, 0xd3, 0x82, 0x00, 0x01, 0x06, 0x18, 0x42,    0x20, 0xc4, 0x01, 0x89, 0xc0, 0xb2, 0x69, 0x24, 0xc2, 0x01, 0x0c, 0x46, 0x03, 0x88, 0xe4, 0x40,    0xc8, 0x05, 0x13, 0x83, 0x0b, 0x21, 0xaf, 0x02, 0x6c, 0x0a, 0x30, 0x09, 0xa2, 0xfe, 0xfd, 0x21,    0x4a, 0x82, 0x43, 0x09, 0x81, 0x90, 0x44, 0x01, 0xe6, 0x05, 0xe8, 0x16, 0x60, 0x58, 0x80, 0x6d,    0x01, 0xa6, 0x05, 0x38, 0x86, 0xa4, 0xd2, 0xc0, 0x29, 0x81, 0xa5, 0x40, 0x48, 0xa8, 0x00, 0xe5,    0x02, 0x7c, 0x0b, 0xd0, 0x8e, 0x28, 0xc9, 0x02, 0x2c, 0xc3, 0x88, 0xc0, 0xa3, 0x88, 0x6c, 0x34,    0x0e, 0x8d, 0x1d, 0x86, 0x65, 0x82, 0x69, 0x10, 0x87, 0x51, 0x36, 0xb2, 0x08, 0x3c, 0xa1, 0x4e,    0x05, 0xc8, 0x15, 0x20, 0x4c, 0x80, 0x78, 0x54, 0x61, 0x34, 0x07, 0x45, 0xf0, 0x43, 0x63, 0xc4,    0x8c, 0x89, 0xc0, 0x76, 0x8e, 0xad, 0x51, 0x9c, 0x46, 0xe1, 0x02, 0xa4, 0x63, 0x68, 0x04, 0xc7,    0x15, 0xde, 0x23, 0x2b, 0x68, 0x86, 0x14, 0xe4, 0x10, 0xce, 0xcd, 0x80, 0xa7, 0x61, 0x9c, 0x0e,    0x41, 0x04, 0x14, 0x3b, 0xc2, 0x01, 0x6b, 0x10, 0x28, 0x19, 0x10, 0xf2, 0x2c, 0xc0, 0xfa, 0xe8,    0x08, 0x81, 0xdd, 0x0b, 0xb0, 0x28, 0x40, 0x19, 0x84, 0xc6, 0x53, 0xe1, 0xf8, 0x0b, 0x30, 0x26,    0xc0, 0x9b, 0x00, 0x5b, 0x38, 0x32, 0x38, 0x27, 0xe1, 0x44, 0x89, 0x51, 0xf1, 0x0c, 0x84, 0x1a,    0x25, 0x9c, 0xb1, 0x6a, 0x43, 0x91, 0x46, 0x54, 0x21, 0xc6, 0x35, 0x6c, 0x84, 0x48, 0xb1, 0x62,    0x84, 0x88, 0xd5, 0xfe, 0x20, 0x48, 0x9c, 0xb3, 0x80, 0x24, 0x80, 0x28, 0xd2, 0x68, 0x50, 0xe3,    0x4f, 0xf0, 0x3c, 0xe0, 0x99, 0x9d, 0xdd, 0x41, 0x1d, 0xe0, 0x49, 0x04, 0x39, 0xc7, 0x33, 0xab,    0x73, 0x72, 0x64, 0xc8, 0x0c, 0x2b, 0xc1, 0xbf, 0x81, 0x4f, 0x06, 0x78, 0xd7, 0x80, 0x9a, 0xe9,    0x03, 0x01, 0x9b, 0x65, 0x38, 0xcc, 0x10, 0xfd, 0xff, 0x1f, 0x74, 0xb8, 0xf3, 0xf2, 0x48, 0x18,    0xc4, 0x11, 0x3e, 0x0b, 0x60, 0x47, 0x7c, 0x32, 0xc7, 0x5d, 0xaa, 0x00, 0xb3, 0x97, 0x00, 0x4d,    0x2e, 0xc1, 0xf1, 0xf8, 0x04, 0xe0, 0xf9, 0x9c, 0x70, 0x02, 0xcb, 0x1f, 0x04, 0x6a, 0x64, 0x86,    0xf6, 0x14, 0x4f, 0xeb, 0x45, 0xc0, 0xe7, 0x83, 0xc3, 0x62, 0x62, 0x21, 0xa4, 0x00, 0x42, 0xe3,    0x01, 0xff, 0xe0, 0x9f, 0x0e, 0x22, 0x3c, 0x17, 0x78, 0xbe, 0x3e, 0x36, 0xc0, 0x18, 0x90, 0xfd,    0x0a, 0x40, 0x08, 0xfe, 0xe2, 0x70, 0x44, 0xcf, 0x08, 0x11, 0x1e, 0x14, 0xd8, 0x11, 0x01, 0x27,    0xf0, 0xd8, 0x80, 0x86, 0xe6, 0x47, 0x80, 0xc8, 0x61, 0xcf, 0x24, 0xf4, 0xb1, 0x44, 0x89, 0x7c,    0x30, 0x3e, 0x50, 0x18, 0xe1, 0x14, 0x9f, 0x23, 0x7a, 0xbf, 0x54, 0x10, 0x02, 0xcb, 0x59, 0xa2,    0x4e, 0x1e, 0x96, 0x02, 0x22, 0x1b, 0x8b, 0xf4, 0x11, 0x83, 0x4a, 0xa1, 0x12, 0xfc, 0x69, 0x1d,    0xd6, 0x41, 0x9e, 0x5c, 0xec, 0xd7, 0x84, 0x73, 0xf4, 0x23, 0x84, 0x1d, 0x43, 0x78, 0x74, 0x08,    0x05, 0x1f, 0x0d, 0x65, 0x73, 0x54, 0x30, 0x0a, 0xe2, 0x81, 0x3b, 0x06, 0x84, 0x8c, 0x9c, 0x01,    0x50, 0x23, 0xf7, 0xf1, 0xe2, 0xf4, 0xde, 0x15, 0x7c, 0x22, 0x21, 0x07, 0x05, 0x68, 0x77, 0x02,    0x9f, 0x00, 0x38, 0x9c, 0x3f, 0x27, 0x14, 0x8e, 0x5c, 0x00, 0x4e, 0x20, 0x01, 0x97, 0x75, 0x10,    0x80, 0xf2, 0xff, 0x3f, 0x08, 0xe0, 0x2e, 0x19, 0x9e, 0xc2, 0xb9, 0x1c, 0xdf, 0xa1, 0x63, 0xcf,    0x01, 0xf0, 0x80, 0x3c, 0x77, 0x2b, 0x1d, 0x3f, 0x9d, 0x42, 0x88, 0x30, 0xd1, 0x0c, 0x8f, 0x89,    0x0d, 0xa1, 0x3f, 0x8c, 0xc7, 0xe3, 0x61, 0xf1, 0xe3, 0x80, 0x4f, 0x2a, 0x0c, 0xfb, 0xe4, 0x0f,    0xa6, 0xe8, 0xc1, 0x6b, 0xf6, 0xc7, 0xf4, 0xca, 0xe0, 0x41, 0x1b, 0xd6, 0x03, 0xe5, 0xb0, 0x46,    0x7b, 0x2a, 0xe1, 0x57, 0x0d, 0x4f, 0xcc, 0x18, 0x61, 0x7d, 0xc8, 0x00, 0x07, 0x20, 0xfe, 0x8a,    0xf0, 0x7e, 0xe1, 0x09, 0x18, 0x90, 0xcd, 0xf1, 0xd1, 0x05, 0x2c, 0xe7, 0x04, 0x3e, 0x88, 0x50,    0x91, 0x62, 0x1c, 0x6e, 0x8c, 0x90, 0x61, 0xa2, 0x3c, 0xce, 0xf8, 0xae, 0xc0, 0x14, 0xda, 0xf4,    0xa9, 0xd1, 0xa8, 0x55, 0x83, 0x32, 0x35, 0xca, 0x34, 0xa8, 0xd5, 0xa7, 0x52, 0x63, 0xc6, 0x4e,    0x28, 0x16, 0xf2, 0x4c, 0xd0, 0x70, 0x1d, 0x03, 0x84, 0x06, 0xa5, 0xd0, 0x49, 0xc1, 0xb1, 0x41,    0x04, 0xe4, 0xff, 0x3f    &#125;)&#125;&#x2F;&#x2F;End of Device(WMI2)&#125;&#x2F;&#x2F;End of Scope(\_SB)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MOF编译为BMF"><a href="#MOF编译为BMF" class="headerlink" title="MOF编译为BMF"></a>MOF编译为BMF</h2><p>Bios\Windows通过WMI相互通信需要借助MOF(经过编译后为BMF)文件，MOF描述了BIOS导出的WMI接口名字。按<a href="https://docs.microsoft.com/en-us/previous-versions/windows/hardware/design/dn614028(v=vs.85)">Windows Instrumentation: WMI and ACPI</a>的描述，MOF可能存在于2处：</p><ul><li>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WmiAcpi的MofImagePath指定；不过我在CML 7C43 Project MB中没有找到这样的设定，应该是应用层编写WMI Provider，生成dll会采取这种方式Register，所以不做讨论。</li><li>作为Buffer资源，将编译的MOF文件二进制BMF资源包进ASL Source  Code，嵌入到ACPI命名空间下。</li></ul><p>一个MOF描述文件，它经过mofcomp编译后，会生成二进制MOF资源文件。OEM厂商提取MOF资源文件中的字节流，嵌入到ACPI命名对象中。另外，WDK工具集中还提供wmimofck工具，该工具以MOF资源文件为输入，生成MOF所描述的WMI接口的测试脚本。下面两行命令将依次生成bmf文件(即MOF资源文件)和vbs接口测试脚本：<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383756674.png"></p><h2 id="ASL-Code部分逻辑"><a href="#ASL-Code部分逻辑" class="headerlink" title="ASL Code部分逻辑"></a>ASL Code部分逻辑</h2><p>BIOS在ASL Source Code中需要向WMI mapper声明设备:PNP0C14和_WDG对象。另外，OEM厂商或者IBV会在声明_WDG对象时，顺带声明嵌入式MOF对象。ACPI spec没有规定嵌入式MOF对象的名字，所以各家OEM会有不同的对象名。但是这并不是问题，它是有迹可循的：</p><ul><li>嵌入式MOF对象位于_WDG对象附近，并且具有形如”Name (WQxy, Buffer()){…”的ACPI对象定义，(其含义为：定义一个包含MOF资源的Buffer，并将该Buffer命名为WQxy。前缀WQ代表这是WMI查询接口，xy是2个16进制数值，用于标识WMI查询接口);</li><li>最重要的，该ACPI对象定义中包含了大量的16进制Byte，即BMF文件的字节流，并且开头4Byte是一个魔术字:”FOMB”，如下：<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383810323.png"><h1 id="OS下调用"><a href="#OS下调用" class="headerlink" title="OS下调用"></a>OS下调用</h1><h2 id="Related-Tool"><a href="#Related-Tool" class="headerlink" title="Related Tool"></a>Related Tool</h2>为了验证WMI功能，我们可以使用WMICodeCreator，它是Microsoft的免费工具。 下载：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=8572">WMI Code Creator v1.0</a>，使用WMI Code Creator工具可以生成VBScript，C＃和VB .NET代码，这些代码使用WMI完成管理任务，例如查询管理数据，从WMI类执行方法或使用WMI接收事件通知。<br>或者也可用第三方开源软件<a href="https://github.com/vinaypamnani/wmie2/releases">WMI Explorer</a>来对WMI进行管理查询。<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383882848.png"><h2 id="指定method调用"><a href="#指定method调用" class="headerlink" title="指定method调用"></a>指定method调用</h2>以管理员身份运行WMICodeCreator.exe，来验证和执行BIOS提供的WMI接口，先执行Query for data from a WMI class，再执行Excute a method，Namespace选择root\WMI，Classes选择MyClass。<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383902165.png"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383920078.png"><h2 id="VB-Script调用"><a href="#VB-Script调用" class="headerlink" title="VB Script调用"></a>VB Script调用</h2><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383950989.png"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604383964733.png"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MOF, ASL, VB Script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Firmware Update Guide</title>
      <link href="2021/08/01/WFU/"/>
      <url>2021/08/01/WFU/</url>
      
        <content type="html"><![CDATA[<h1 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h1><ul><li>CometLake 7C43 Project:M80T MB with UEFI Windows 10 System .</li></ul><p>- Product: Aptio 5.x.</p><h1 id="Test-Objective"><a href="#Test-Objective" class="headerlink" title="Test Objective:"></a>Test Objective:</h1><ul><li>Confirm that Firmware can be updated using Windows architecture.</li></ul><h1 id="Test-Procedures"><a href="#Test-Procedures" class="headerlink" title="Test Procedures:"></a>Test Procedures:</h1><ul><li>System With SDK and WINDDK Installed</li></ul><blockquote><p>下载并安装最新WDK和SDK到测试机</p></blockquote><p>WDK：该驱动程序开发工具包（WDK）是从软件工具集微软，使开发设备驱动程序针对微软的Windows平台。它包括用于驱动程序开发人员的文档，样本，构建环境和工具。用于驱动程序开发的完整工具集还需要以下内容：编译器Visual Studio，Windows SDK和Windows HLK。</p><p>SDK：Microsoft Windows SDK及其先前的Platform SDK和.NET Framework SDK是Microsoft的软件开发工具包（SDK），其中包含开发Microsoft Windows和.NET Framework应用程序所需的文档，头文件，库，示例和工具。Platform SDK专门开发用于Windows 2000，XP和Windows Server 2003的应用程序。.NET Framework SDK专门用于开发用于 .NET Framework 1.1和.NET Framework 2.0。Windows SDK是这两者的继承者，并支持为Windows XP和更高版本以及.NET Framework 3.0和更高版本开发应用程序。</p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369144037.png"><br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369151637.png"></p><ul><li>Create a folder C:\WFU and place *.inf and <em>.cap file in it(</em>.cap file built from project source)</li></ul><blockquote><p>*.inf文件示例如下，具体参考微软官网INF相关说明</p></blockquote><pre class="line-numbers language-none"><code class="language-none">[Version]Signature   &#x3D; &quot;$WINDOWS NT$&quot;Provider    &#x3D; %Provider%Class       &#x3D; FirmwareClassGuid   &#x3D; &#123;f2e7dd72-6468-4e36-b6f1-6488f42c1b52&#125;DriverVer   &#x3D; 07&#x2F;28&#x2F;2020,1.0.0.43CatalogFile &#x3D; M2TKT2CA.catPnpLockdown &#x3D; 1[Manufacturer]%MfgName% &#x3D; Firmware,NTamd64[Firmware.NTamd64]%FirmwareDesc% &#x3D; Firmware_Install,UEFI\RES_&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;[Firmware_Install.NT]CopyFiles &#x3D; Firmware_CopyFiles[Firmware_CopyFiles]M2TKT2CA.cap[Firmware_Install.NT.Hw]AddReg &#x3D; Firmware_AddReg[Firmware_AddReg]HKR,,FirmwareId,,&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;HKR,,FirmwareVersion,%REG_DWORD%,0x0001002CHKR,,FirmwareFilename,,&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;\M2TKT2CA.cap[SourceDisksNames]1 &#x3D; %DiskName%[SourceDisksFiles]M2TKT2CA.cap &#x3D; 1[DestinationDirs]DefaultDestDir &#x3D; %DIRID_WINDOWS%,Firmware\&#123;5deafc1a-69b6-4a95-8572-2c888cabf533&#125;[Strings]; localizableProvider     &#x3D; &quot;Lenovo Ltd.&quot;MfgName      &#x3D; &quot;Lenovo Ltd.&quot;FirmwareDesc &#x3D; &quot;ThinkCentre M90t&#x2F;s, M80t&#x2F;s, M70t&#x2F;s, M993t, M930t&#x2F;s, M737t, QT M630, YT P780 System Firmware 1.0.0.43&quot;DiskName     &#x3D; &quot;Firmware Update&quot;; non-localizableDIRID_WINDOWS &#x3D; 10REG_DWORD     &#x3D; 0x00010001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>Change related cap and cat file name  in *.inf file, make these match the prefix of your cap file name, example M2TKT2CA.cat  and M2TKT2CA.cap （如下图2、4、8、9处）<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369166799.png"></p></li><li><p>将M2TKT2CA.inf文件的GUID替换为BIOS Source Code里对应的需要更新Firmware GUID（如上图3、5、7、10处）<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604369174098.png"></p></li><li><p>Edit M2TKT2CA.inf file, find string “DriverVer=07/10/2020,1.0.0.42” and increase last two digits to 43, must increment for each flash（如上图1、11处）</p></li><li><p>Edit M2TKT2CA.inf, find string “HKR,,FirmwareVersion,%REG_DWORD%,0x0001002B and increase to 0x0001002C”， must increment for each flash.（如上图6处）<br>(Note: 0x2C is hex values of BIOS version, ex: BIOS version is 043, the hex values is 0x2C)</p></li><li><p>以管理员身份运行PowerShell，切换目录到C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x86</p></li><li><p>Run .\makecert.exe -r -pe -a sha256 -eku 1.3.6.1.5.5.7.3.3 -n CN=Foo -sv fwu.pvk fwu.cer</p></li><li><p>Password window will appear, set and verify this password: wfutest123<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370942326.png"></p></li></ul><ul><li><p>In powershell run .\pvk2pfx.exe -pvk fwu.pvk -spc fwu.cer -pi wfutest123 -spc fwu.cer -pfx fwu.pfx</p></li><li><p>If a .cat with your BIOS name, example m2tkt2ca.cat exists in the Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x86 folder delete it.</p></li><li><p>In powershell run .\Inf2Cat.exe /driver:c:\WFU /os:10_x64</p></li><li><p>In powershell run .\signtool sign /fd sha256 /f fwu.pfx /p wfutest123 C:\WFU\M2TKT2CA.cat</p></li><li><p>In powershell run .\fwu.cer<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370915317.png"></p></li></ul><ul><li><p>A Window should be displayed. Install certificate, local machine, next, browse, select Trusted Root Certification Authorities<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370903085.png"></p></li><li><p>In powershell run bcdedit.exe /set testsigning on</p></li><li><p>Right click My computer -&gt; Manage -&gt; Device Manager -&gt; Firmware -&gt; Update Driver Software -&gt; Browse -&gt; Let me Pick -&gt; Hard Disk -&gt; Select inf -&gt; restart<br><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370891225.png"></p></li></ul><ul><li>Firmware update should complete without errors.</li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370868293.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1604370603974.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> WFU, cab, 证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ventoy</title>
      <link href="2021/08/01/Ventoy/"/>
      <url>2021/08/01/Ventoy/</url>
      
        <content type="html"><![CDATA[<h1 id="Ventoy简介"><a href="#Ventoy简介" class="headerlink" title="Ventoy简介"></a>Ventoy简介</h1><p> Ventoy是一个制作可启动U盘的开源工具。有了Ventoy你就无需反复地格式化U盘，你只需要把ISO文件拷贝到U盘里面就可以启动了，无需其他操作。 你可以一次性拷贝很多个不同类型的ISO文件，在启动时Ventoy会显示一个菜单来选择(<a href="https://www.ventoy.net/cn/screenshot.html">截图</a>)。 无差异支持Legacy BIOS和UEFI模式。目前已经测试了各类超过260+ 个ISO文件(<a href="https://www.ventoy.net/cn/isolist.html">列表</a>). 同时提出了”Ventoy Compatible”的概念，若被支持则理论上可以启动任何ISO文件.</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><ul><li><p><a href="https://github.com/ventoy/Ventoy">Github开源地址</a></p><ul><li> <a href="https://www.ventoy.net/cn/download.html">下载地址</a></li></ul></li><li><p> 安装到启动盘</p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967090645.png" alt="安装到U盘"></p><h1 id="放置ISO镜像文件"><a href="#放置ISO镜像文件" class="headerlink" title="放置ISO镜像文件"></a>放置ISO镜像文件</h1><h2 id="镜像下载站点"><a href="#镜像下载站点" class="headerlink" title="镜像下载站点"></a>镜像下载站点</h2><ul><li>  <a href="https://next.itellyou.cn/">MSDN</a></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531519.png"></p><ul><li>  <a href="https://developer.aliyun.com/mirror/">阿里云镜像站</a></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531520.png"></p><h2 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h2><blockquote><p>镜像可放在根目录，也可建立文件夹管理，可按需求分类</p></blockquote><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967174941.png"></p><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967207747.png"></p><h1 id="配置json文件和主题（可忽略）"><a href="#配置json文件和主题（可忽略）" class="headerlink" title="配置json文件和主题（可忽略）"></a>配置json文件和主题（可忽略）</h1><ul><li><p>  <a href="https://www.ventoy.net/cn/plugin_entry.html">官方教程</a></p></li><li><p>  个人示例</p></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603967274942.png"></p><ul><li>  ventoy.json<pre class="line-numbers language-none"><code class="language-none">&#123; &quot;theme&quot;: &#123;        &quot;file&quot;: &quot;&#x2F;ventoy&#x2F;theme&#x2F;theme.txt&quot;,        &quot;gfxmode&quot;: &quot;1024x768&quot;,        &quot;ventoy_left&quot;: &quot;42%&quot;,        &quot;ventoy_top&quot;: &quot;100%&quot;,        &quot;ventoy_color&quot;: &quot;#000000&quot;    &#125; ,&quot;menu_alias&quot; : [        &#123;            &quot;image&quot;: &quot;&#x2F;ISO&#x2F;18363.418.191007-0143.19h2_release_svc_refresh_CLIENT_CONSUMER_x64FRE_en-us.iso&quot;,            &quot;alias&quot;: &quot;Win10 19H2英文版&quot;        &#125;,        &#123;            &quot;image&quot;: &quot;&#x2F;ISO&#x2F;19041.208.200420-2019.vb_release_svc_refresh_CLIENT_BUSINESS_VOL_x64FRE_en-us.iso&quot;,            &quot;alias&quot;: &quot;Win10 20H1英文版&quot;        &#125;,                &#123;            &quot;image&quot;: &quot;&#x2F;ISO&#x2F;cn_windows_10_business_editions_version_1909_updated_jan_2020_x64_dvd_b3e1f3a6.iso&quot;,            &quot;alias&quot;: &quot;Win10 1909中文版&quot;        &#125;,&#123;            &quot;image&quot;: &quot;&#x2F;ISO&#x2F;rhel-8.1-x86_64-dvd.iso&quot;,            &quot;alias&quot;: &quot;ReaHat 8.1&quot;        &#125;,&#123;            &quot;image&quot;: &quot;&#x2F;ISO&#x2F;ubuntu-18.04.3-desktop-amd64.iso&quot;,            &quot;alias&quot;: &quot;Ubuntu 18.04.03&quot;        &#125;,&#123;            &quot;image&quot;: &quot;&#x2F;ISO&#x2F;ubuntu-20.04-desktop-amd64.iso&quot;,            &quot;alias&quot;: &quot;Ubuntu 20.04&quot;        &#125;,&#123;            &quot;image&quot;: &quot;&#x2F;ISO&#x2F;wepe_64.iso&quot;,            &quot;alias&quot;: &quot;微PE&quot;        &#125;,&#123;            &quot;image&quot;: &quot;&#x2F;ISO&#x2F;EasyU_v3.3.iso&quot;,            &quot;alias&quot;: &quot;优启通PE&quot;        &#125;,&#123;            &quot;image&quot;: &quot;&#x2F;19H2_Bak.wim&quot;,            &quot;alias&quot;: &quot;Win10 19H2英文系统备份&quot;        &#125;,&#123;            &quot;image&quot;: &quot;&#x2F;1909_Zh_Cn_Backup.wim&quot;,            &quot;alias&quot;: &quot;Win10 19H2中文系统备份&quot;        &#125;,&#123;            &quot;image&quot;: &quot;&#x2F;ISO&#x2F;en_windows_server_2016_x64_dvd_9718492.iso&quot;,            &quot;alias&quot;: &quot;Win10 Server 2016&quot;        &#125;    ]     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>  <a href="https://www.gnome-look.org/p/1009236/">主题地址</a></li></ul><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531602.png"></p><h1 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h1><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603965531607.png"></p><blockquote><p>通过主板快捷键可以从制作的VentoyU盘启动，选择可启动镜像即可进入OS安装或PE等维护工具</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 镜像, 多系统U盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HOB</title>
      <link href="2021/08/01/HOB/"/>
      <url>2021/08/01/HOB/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="HOB简介"><a href="#HOB简介" class="headerlink" title="HOB简介"></a>HOB简介</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>HOB是Hand-Off Block的缩写。是PEI阶段向DXE传递系统信息的手段。PEI阶段构建一些HOB结构，然后将其作为参数传给DXE阶段函数，DXE Core会根据其使用平台相关资源。</p><p>HOB是系列的连续的内存结构体，可以认为其由三部分构成：第一部分，是PHIT头，它描述了HOB的起始地址以及总的内存使用；第二部分是各个Hob列表，DXE阶段会根据这一部分获取相关资源；第三部分是结束部分。</p><hr><p>   <img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603960797897.png"></p><p>  <img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603960797878.png" alt="HOB List"></p><hr><h2 id="相关Spec"><a href="#相关Spec" class="headerlink" title="相关Spec"></a>相关Spec</h2><ul><li>PI Spec(卷一 4.4 HOB Services小节，规范HOB PeiService相关的方法,Pi卷三4/5章节)</li><li><a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/unified-extensible-firmware-interface/efi-specifications-general-technology.html">EFI Spec</a>（规范HOB的数据结构）</li></ul><h1 id="HOB的数据结构表征-PiHob-h"><a href="#HOB的数据结构表征-PiHob-h" class="headerlink" title="HOB的数据结构表征(PiHob.h)"></a>HOB的数据结构表征(PiHob.h)</h1><h2 id="EFI-HOB-GENERIC-HEADER"><a href="#EFI-HOB-GENERIC-HEADER" class="headerlink" title="EFI_HOB_GENERIC_HEADER"></a>EFI_HOB_GENERIC_HEADER</h2><blockquote><p>描述HOB内部数据的格式和大小,所有HOB都必须包含此通用HOB标头,以便可以找到下一个HOB</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Describes the format and size of the data inside the HOB.&#x2F;&#x2F;&#x2F; All HOBs must contain this generic HOB header.&#x2F;&#x2F;&#x2F;typedef struct &#123;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; Identifies the HOB data structure type.  &#x2F;&#x2F;&#x2F;  UINT16    HobType;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The length in bytes of the HOB.  &#x2F;&#x2F;&#x2F;  UINT16    HobLength;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; This field must always be set to zero.  &#x2F;&#x2F;&#x2F;  UINT32    Reserved;&#125; EFI_HOB_GENERIC_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HobType"><a href="#HobType" class="headerlink" title="HobType"></a>HobType</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&#x2F;&#x2F; HobType of EFI_HOB_GENERIC_HEADER.&#x2F;&#x2F;#define EFI_HOB_TYPE_HANDOFF              0x0001#define EFI_HOB_TYPE_MEMORY_ALLOCATION    0x0002#define EFI_HOB_TYPE_RESOURCE_DESCRIPTOR  0x0003#define EFI_HOB_TYPE_GUID_EXTENSION       0x0004#define EFI_HOB_TYPE_FV                   0x0005#define EFI_HOB_TYPE_CPU                  0x0006#define EFI_HOB_TYPE_MEMORY_POOL          0x0007#define EFI_HOB_TYPE_FV2                  0x0009#define EFI_HOB_TYPE_LOAD_PEIM_UNUSED     0x000A#define EFI_HOB_TYPE_UEFI_CAPSULE         0x000B#define EFI_HOB_TYPE_FV3                  0x000C#define EFI_HOB_TYPE_UNUSED               0xFFFE#define EFI_HOB_TYPE_END_OF_HOB_LIST      0xFFFF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="PHIT-HOB"><a href="#PHIT-HOB" class="headerlink" title="PHIT HOB"></a>PHIT HOB</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Contains general state information used by the HOB producer phase.&#x2F;&#x2F;&#x2F; This HOB must be the first one in the HOB list.&#x2F;&#x2F;&#x2F;typedef struct &#123;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The HOB generic header. Header.HobType &#x3D; EFI_HOB_TYPE_HANDOFF.  &#x2F;&#x2F;&#x2F;  EFI_HOB_GENERIC_HEADER  Header;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The version number pertaining to the PHIT HOB definition.  &#x2F;&#x2F;&#x2F; This value is four bytes in length to provide an 8-byte aligned entry  &#x2F;&#x2F;&#x2F; when it is combined with the 4-byte BootMode.  &#x2F;&#x2F;&#x2F;  UINT32                  Version;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The system boot mode as determined during the HOB producer phase.  &#x2F;&#x2F;&#x2F;  EFI_BOOT_MODE           BootMode;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The highest address location of memory that is allocated for use by the HOB producer  &#x2F;&#x2F;&#x2F; phase. This address must be 4-KB aligned to meet page restrictions of UEFI.  &#x2F;&#x2F;&#x2F;  EFI_PHYSICAL_ADDRESS    EfiMemoryTop;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The lowest address location of memory that is allocated for use by the HOB producer phase.  &#x2F;&#x2F;&#x2F;  EFI_PHYSICAL_ADDRESS    EfiMemoryBottom;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The highest address location of free memory that is currently available  &#x2F;&#x2F;&#x2F; for use by the HOB producer phase.  &#x2F;&#x2F;&#x2F;  EFI_PHYSICAL_ADDRESS    EfiFreeMemoryTop;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The lowest address location of free memory that is available for use by the HOB producer phase.  &#x2F;&#x2F;&#x2F;  EFI_PHYSICAL_ADDRESS    EfiFreeMemoryBottom;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The end of the HOB list.  &#x2F;&#x2F;&#x2F;  EFI_PHYSICAL_ADDRESS    EfiEndOfHobList;&#125; EFI_HOB_HANDOFF_INFO_TABLE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-HEADER"><a href="#EFI-HOB-MEMORY-ALLOCATION-HEADER" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_HEADER"></a>EFI_HOB_MEMORY_ALLOCATION_HEADER</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; EFI_HOB_MEMORY_ALLOCATION_HEADER describes the&#x2F;&#x2F;&#x2F; various attributes of the logical memory allocation. The type field will be used for&#x2F;&#x2F;&#x2F; subsequent inclusion in the UEFI memory map.&#x2F;&#x2F;&#x2F;typedef struct &#123;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; A GUID that defines the memory allocation region&#39;s type and purpose, as well as  &#x2F;&#x2F;&#x2F; other fields within the memory allocation HOB. This GUID is used to define the  &#x2F;&#x2F;&#x2F; additional data within the HOB that may be present for the memory allocation HOB.  &#x2F;&#x2F;&#x2F; Type EFI_GUID is defined in InstallProtocolInterface() in the UEFI 2.0  &#x2F;&#x2F;&#x2F; specification.  &#x2F;&#x2F;&#x2F;  EFI_GUID              Name;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The base address of memory allocated by this HOB. Type  &#x2F;&#x2F;&#x2F; EFI_PHYSICAL_ADDRESS is defined in AllocatePages() in the UEFI 2.0  &#x2F;&#x2F;&#x2F; specification.  &#x2F;&#x2F;&#x2F;  EFI_PHYSICAL_ADDRESS  MemoryBaseAddress;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The length in bytes of memory allocated by this HOB.  &#x2F;&#x2F;&#x2F;  UINT64                MemoryLength;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; Defines the type of memory allocated by this HOB. The memory type definition  &#x2F;&#x2F;&#x2F; follows the EFI_MEMORY_TYPE definition. Type EFI_MEMORY_TYPE is defined  &#x2F;&#x2F;&#x2F; in AllocatePages() in the UEFI 2.0 specification.  &#x2F;&#x2F;&#x2F;  EFI_MEMORY_TYPE       MemoryType;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; Padding for Itanium processor family  &#x2F;&#x2F;&#x2F;  UINT8                 Reserved[4];&#125; EFI_HOB_MEMORY_ALLOCATION_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION"><a href="#EFI-HOB-MEMORY-ALLOCATION" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION"></a>EFI_HOB_MEMORY_ALLOCATION</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">///</span><span class="token comment">/// Describes all memory ranges used during the HOB producer</span><span class="token comment">/// phase that exist outside the HOB list. This HOB type</span><span class="token comment">/// describes how memory is used, not the physical attributes of memory.</span><span class="token comment">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>  <span class="token comment">///</span>  <span class="token comment">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.</span>  <span class="token comment">///</span>  EFI_HOB_GENERIC_HEADER            Header<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the</span>  <span class="token comment">/// various attributes of the logical memory allocation.</span>  <span class="token comment">///</span>  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor<span class="token punctuation">;</span>  <span class="token comment">//</span>  <span class="token comment">// Additional data pertaining to the "Name" Guid memory</span>  <span class="token comment">// may go here.</span>  <span class="token comment">//</span><span class="token punctuation">&#125;</span> EFI_HOB_MEMORY_ALLOCATION<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-STACK"><a href="#EFI-HOB-MEMORY-ALLOCATION-STACK" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_STACK"></a>EFI_HOB_MEMORY_ALLOCATION_STACK</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">///</span><span class="token comment">/// Describes the memory stack that is produced by the HOB producer</span><span class="token comment">/// phase and upon which all post-memory-installed executable</span><span class="token comment">/// content in the HOB producer phase is executing.</span><span class="token comment">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>  <span class="token comment">///</span>  <span class="token comment">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.</span>  <span class="token comment">///</span>  EFI_HOB_GENERIC_HEADER            Header<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the</span>  <span class="token comment">/// various attributes of the logical memory allocation.</span>  <span class="token comment">///</span>  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> EFI_HOB_MEMORY_ALLOCATION_STACK<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-BSP-STORE"><a href="#EFI-HOB-MEMORY-ALLOCATION-BSP-STORE" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_BSP_STORE"></a>EFI_HOB_MEMORY_ALLOCATION_BSP_STORE</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">///</span><span class="token comment">/// Defines the location of the boot-strap</span><span class="token comment">/// processor (BSP) BSPStore ("Backing Store Pointer Store").</span><span class="token comment">/// This HOB is valid for the Itanium processor family only</span><span class="token comment">/// register overflow store.</span><span class="token comment">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>  <span class="token comment">///</span>  <span class="token comment">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_ALLOCATION.</span>  <span class="token comment">///</span>  EFI_HOB_GENERIC_HEADER            Header<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the</span>  <span class="token comment">/// various attributes of the logical memory allocation.</span>  <span class="token comment">///</span>  EFI_HOB_MEMORY_ALLOCATION_HEADER  AllocDescriptor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> EFI_HOB_MEMORY_ALLOCATION_BSP_STORE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-ALLOCATION-MODULE"><a href="#EFI-HOB-MEMORY-ALLOCATION-MODULE" class="headerlink" title="EFI_HOB_MEMORY_ALLOCATION_MODULE"></a>EFI_HOB_MEMORY_ALLOCATION_MODULE</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Defines the location and entry point of the HOB consumer phase.&#x2F;&#x2F;&#x2F;typedef struct &#123;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The HOB generic header. Header.HobType &#x3D; EFI_HOB_TYPE_MEMORY_ALLOCATION.  &#x2F;&#x2F;&#x2F;  EFI_HOB_GENERIC_HEADER            Header;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; An instance of the EFI_HOB_MEMORY_ALLOCATION_HEADER that describes the  &#x2F;&#x2F;&#x2F; various attributes of the logical memory allocation.  &#x2F;&#x2F;&#x2F;  EFI_HOB_MEMORY_ALLOCATION_HEADER  MemoryAllocationHeader;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The GUID specifying the values of the firmware file system name  &#x2F;&#x2F;&#x2F; that contains the HOB consumer phase component.  &#x2F;&#x2F;&#x2F;  EFI_GUID                          ModuleName;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The address of the memory-mapped firmware volume  &#x2F;&#x2F;&#x2F; that contains the HOB consumer phase firmware file.  &#x2F;&#x2F;&#x2F;  EFI_PHYSICAL_ADDRESS              EntryPoint;&#125; EFI_HOB_MEMORY_ALLOCATION_MODULE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-RESOURCE-DESCRIPTOR"><a href="#EFI-HOB-RESOURCE-DESCRIPTOR" class="headerlink" title="EFI_HOB_RESOURCE_DESCRIPTOR"></a>EFI_HOB_RESOURCE_DESCRIPTOR</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Describes the resource properties of all fixed,&#x2F;&#x2F;&#x2F; nonrelocatable resource ranges found on the processor&#x2F;&#x2F;&#x2F; host bus during the HOB producer phase.&#x2F;&#x2F;&#x2F;typedef struct &#123;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The HOB generic header. Header.HobType &#x3D; EFI_HOB_TYPE_RESOURCE_DESCRIPTOR.  &#x2F;&#x2F;&#x2F;  EFI_HOB_GENERIC_HEADER      Header;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; A GUID representing the owner of the resource. This GUID is used by HOB  &#x2F;&#x2F;&#x2F; consumer phase components to correlate device ownership of a resource.  &#x2F;&#x2F;&#x2F;  EFI_GUID                    Owner;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The resource type enumeration as defined by EFI_RESOURCE_TYPE.  &#x2F;&#x2F;&#x2F;  EFI_RESOURCE_TYPE           ResourceType;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; Resource attributes as defined by EFI_RESOURCE_ATTRIBUTE_TYPE.  &#x2F;&#x2F;&#x2F;  EFI_RESOURCE_ATTRIBUTE_TYPE ResourceAttribute;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The physical start address of the resource region.  &#x2F;&#x2F;&#x2F;  EFI_PHYSICAL_ADDRESS        PhysicalStart;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The number of bytes of the resource region.  &#x2F;&#x2F;&#x2F;  UINT64                      ResourceLength;&#125; EFI_HOB_RESOURCE_DESCRIPTOR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-GUID-TYPE"><a href="#EFI-HOB-GUID-TYPE" class="headerlink" title="EFI_HOB_GUID_TYPE"></a>EFI_HOB_GUID_TYPE</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Allows writers of executable content in the HOB producer phase to&#x2F;&#x2F;&#x2F; maintain and manage HOBs with specific GUID.&#x2F;&#x2F;&#x2F;typedef struct &#123;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The HOB generic header. Header.HobType &#x3D; EFI_HOB_TYPE_GUID_EXTENSION.  &#x2F;&#x2F;&#x2F;  EFI_HOB_GENERIC_HEADER      Header;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; A GUID that defines the contents of this HOB.  &#x2F;&#x2F;&#x2F;  EFI_GUID                    Name;  &#x2F;&#x2F;  &#x2F;&#x2F; Guid specific data goes here  &#x2F;&#x2F;&#125; EFI_HOB_GUID_TYPE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-FIRMWARE-VOLUME"><a href="#EFI-HOB-FIRMWARE-VOLUME" class="headerlink" title="EFI_HOB_FIRMWARE_VOLUME"></a>EFI_HOB_FIRMWARE_VOLUME</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Details the location of firmware volumes that contain firmware files.&#x2F;&#x2F;&#x2F;typedef struct &#123;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The HOB generic header. Header.HobType &#x3D; EFI_HOB_TYPE_FV.  &#x2F;&#x2F;&#x2F;  EFI_HOB_GENERIC_HEADER Header;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The physical memory-mapped base address of the firmware volume.  &#x2F;&#x2F;&#x2F;  EFI_PHYSICAL_ADDRESS   BaseAddress;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The length in bytes of the firmware volume.  &#x2F;&#x2F;&#x2F;  UINT64                 Length;&#125; EFI_HOB_FIRMWARE_VOLUME;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-FIRMWARE-VOLUME2"><a href="#EFI-HOB-FIRMWARE-VOLUME2" class="headerlink" title="EFI_HOB_FIRMWARE_VOLUME2"></a>EFI_HOB_FIRMWARE_VOLUME2</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Details the location of a firmware volume that was extracted&#x2F;&#x2F;&#x2F; from a file within another firmware volume.&#x2F;&#x2F;&#x2F;typedef struct &#123;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The HOB generic header. Header.HobType &#x3D; EFI_HOB_TYPE_FV2.  &#x2F;&#x2F;&#x2F;  EFI_HOB_GENERIC_HEADER  Header;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The physical memory-mapped base address of the firmware volume.  &#x2F;&#x2F;&#x2F;  EFI_PHYSICAL_ADDRESS    BaseAddress;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The length in bytes of the firmware volume.  &#x2F;&#x2F;&#x2F;  UINT64                  Length;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The name of the firmware volume.  &#x2F;&#x2F;&#x2F;  EFI_GUID                FvName;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The name of the firmware file that contained this firmware volume.  &#x2F;&#x2F;&#x2F;  EFI_GUID                FileName;&#125; EFI_HOB_FIRMWARE_VOLUME2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-FIRMWARE-VOLUME3"><a href="#EFI-HOB-FIRMWARE-VOLUME3" class="headerlink" title="EFI_HOB_FIRMWARE_VOLUME3"></a>EFI_HOB_FIRMWARE_VOLUME3</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">///</span><span class="token comment">/// Details the location of a firmware volume that was extracted</span><span class="token comment">/// from a file within another firmware volume.</span><span class="token comment">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>  <span class="token comment">///</span>  <span class="token comment">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_FV3.</span>  <span class="token comment">///</span>  EFI_HOB_GENERIC_HEADER  Header<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// The physical memory-mapped base address of the firmware volume.</span>  <span class="token comment">///</span>  EFI_PHYSICAL_ADDRESS    BaseAddress<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// The length in bytes of the firmware volume.</span>  <span class="token comment">///</span>  UINT64                  Length<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// The authentication status.</span>  <span class="token comment">///</span>  UINT32                  AuthenticationStatus<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// TRUE if the FV was extracted as a file within another firmware volume.</span>  <span class="token comment">/// FALSE otherwise.</span>  <span class="token comment">///</span>  BOOLEAN                 ExtractedFv<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// The name of the firmware volume.</span>  <span class="token comment">/// Valid only if IsExtractedFv is TRUE.</span>  <span class="token comment">///</span>  EFI_GUID                FvName<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// The name of the firmware file that contained this firmware volume.</span>  <span class="token comment">/// Valid only if IsExtractedFv is TRUE.</span>  <span class="token comment">///</span>  EFI_GUID                FileName<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> EFI_HOB_FIRMWARE_VOLUME3<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-CPU"><a href="#EFI-HOB-CPU" class="headerlink" title="EFI_HOB_CPU"></a>EFI_HOB_CPU</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">///</span><span class="token comment">/// Describes processor information, such as address space and I/O space capabilities.</span><span class="token comment">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>  <span class="token comment">///</span>  <span class="token comment">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_CPU.</span>  <span class="token comment">///</span>  EFI_HOB_GENERIC_HEADER  Header<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// Identifies the maximum physical memory addressability of the processor.</span>  <span class="token comment">///</span>  UINT8                   SizeOfMemorySpace<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// Identifies the maximum physical I/O addressability of the processor.</span>  <span class="token comment">///</span>  UINT8                   SizeOfIoSpace<span class="token punctuation">;</span>  <span class="token comment">///</span>  <span class="token comment">/// This field will always be set to zero.</span>  <span class="token comment">///</span>  UINT8                   Reserved<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> EFI_HOB_CPU<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-MEMORY-POOL"><a href="#EFI-HOB-MEMORY-POOL" class="headerlink" title="EFI_HOB_MEMORY_POOL"></a>EFI_HOB_MEMORY_POOL</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">///</span><span class="token comment">/// Describes pool memory allocations.</span><span class="token comment">///</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>  <span class="token comment">///</span>  <span class="token comment">/// The HOB generic header. Header.HobType = EFI_HOB_TYPE_MEMORY_POOL.</span>  <span class="token comment">///</span>  EFI_HOB_GENERIC_HEADER  Header<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> EFI_HOB_MEMORY_POOL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-HOB-UEFI-CAPSULE"><a href="#EFI-HOB-UEFI-CAPSULE" class="headerlink" title="EFI_HOB_UEFI_CAPSULE"></a>EFI_HOB_UEFI_CAPSULE</h2><pre class="line-numbers language-c///" data-language="c///"><code class="language-c///">&#x2F;&#x2F;&#x2F; Each UEFI capsule HOB details the location of a UEFI capsule. It includes a base address and length&#x2F;&#x2F;&#x2F; which is based upon memory blocks with a EFI_CAPSULE_HEADER and the associated&#x2F;&#x2F;&#x2F; CapsuleImageSize-based payloads. These HOB&#39;s shall be created by the PEI PI firmware&#x2F;&#x2F;&#x2F; sometime after the UEFI UpdateCapsule service invocation with the&#x2F;&#x2F;&#x2F; CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE flag set in the EFI_CAPSULE_HEADER.&#x2F;&#x2F;&#x2F;typedef struct &#123;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The HOB generic header where Header.HobType &#x3D; EFI_HOB_TYPE_UEFI_CAPSULE.  &#x2F;&#x2F;&#x2F;  EFI_HOB_GENERIC_HEADER Header;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The physical memory-mapped base address of an UEFI capsule. This value is set to  &#x2F;&#x2F;&#x2F; point to the base of the contiguous memory of the UEFI capsule.  &#x2F;&#x2F;&#x2F; The length of the contiguous memory in bytes.  &#x2F;&#x2F;&#x2F;  EFI_PHYSICAL_ADDRESS   BaseAddress;  UINT64                 Length;&#125; EFI_HOB_UEFI_CAPSULE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="EFI-PEI-HOB-POINTERS"><a href="#EFI-PEI-HOB-POINTERS" class="headerlink" title="EFI_PEI_HOB_POINTERS"></a>EFI_PEI_HOB_POINTERS</h2><blockquote><p>使用union最大的好处是提高源码的可读性和间接性。利用该类型中所有域的取值均一样的特点，在不同的使用方法下，可以使用不同的变量名字，一方面可以省去强制类型转换的麻烦，另一方面可以直接体现出当前的使用需求。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">///</span><span class="token comment">/// Union of all the possible HOB Types.</span><span class="token comment">///</span><span class="token keyword">typedef</span> <span class="token keyword">union</span> <span class="token punctuation">&#123;</span>  EFI_HOB_GENERIC_HEADER              <span class="token operator">*</span>Header<span class="token punctuation">;</span>  EFI_HOB_HANDOFF_INFO_TABLE          <span class="token operator">*</span>HandoffInformationTable<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION           <span class="token operator">*</span>MemoryAllocation<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION_BSP_STORE <span class="token operator">*</span>MemoryAllocationBspStore<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION_STACK     <span class="token operator">*</span>MemoryAllocationStack<span class="token punctuation">;</span>  EFI_HOB_MEMORY_ALLOCATION_MODULE    <span class="token operator">*</span>MemoryAllocationModule<span class="token punctuation">;</span>  EFI_HOB_RESOURCE_DESCRIPTOR         <span class="token operator">*</span>ResourceDescriptor<span class="token punctuation">;</span>  EFI_HOB_GUID_TYPE                   <span class="token operator">*</span>Guid<span class="token punctuation">;</span>  EFI_HOB_FIRMWARE_VOLUME             <span class="token operator">*</span>FirmwareVolume<span class="token punctuation">;</span>  EFI_HOB_FIRMWARE_VOLUME2            <span class="token operator">*</span>FirmwareVolume2<span class="token punctuation">;</span>  EFI_HOB_FIRMWARE_VOLUME3            <span class="token operator">*</span>FirmwareVolume3<span class="token punctuation">;</span>  EFI_HOB_CPU                         <span class="token operator">*</span>Cpu<span class="token punctuation">;</span>  EFI_HOB_MEMORY_POOL                 <span class="token operator">*</span>Pool<span class="token punctuation">;</span>  EFI_HOB_UEFI_CAPSULE                <span class="token operator">*</span>Capsule<span class="token punctuation">;</span>  UINT8                               <span class="token operator">*</span>Raw<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> EFI_PEI_HOB_POINTERS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="HOB相关方法的声明（HobLib-h）"><a href="#HOB相关方法的声明（HobLib-h）" class="headerlink" title="HOB相关方法的声明（HobLib.h）"></a>HOB相关方法的声明（HobLib.h）</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><ul><li>BuildModuleHob</li><li>BuildResourceDescriptorWithOwnerHob</li><li>BuildResourceDescriptorHob</li><li>BuildGuidHob</li><li>BuildGuidDataHob</li><li>BuildFvHob</li><li>BuildFv2Hob</li><li>BuildFv3Hob</li><li>BuildCvHob</li><li>BuildCpuHob</li><li>BuildStackHob</li><li>BuildBspStoreHob</li><li>BuildMemoryAllocationHob</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**  Builds a HOB for a loaded PE32 module.  This function builds a HOB for a loaded PE32 module.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If ModuleName is NULL, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  @param  ModuleName              The GUID File Name of the module.  @param  MemoryAllocationModule  The 64 bit physical address of the module.  @param  ModuleLength            The length of the module in bytes.  @param  EntryPoint              The 64 bit physical address of the module entry point.**/</span>VOIDEFIAPI<span class="token function">BuildModuleHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID         <span class="token operator">*</span>ModuleName<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS   MemoryAllocationModule<span class="token punctuation">,</span>  IN UINT64                 ModuleLength<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS   EntryPoint  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a HOB that describes a chunk of system memory with Owner GUID.  This function builds a HOB that describes a chunk of system memory.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  ResourceType        The type of resource described by this HOB.  @param  ResourceAttribute   The resource attributes of the memory described by this HOB.  @param  PhysicalStart       The 64 bit physical address of memory described by this HOB.  @param  NumberOfBytes       The length of the memory described by this HOB in bytes.  @param  OwnerGUID           GUID for the owner of this resource.**/</span>VOIDEFIAPI<span class="token function">BuildResourceDescriptorWithOwnerHob</span> <span class="token punctuation">(</span>  IN EFI_RESOURCE_TYPE            ResourceType<span class="token punctuation">,</span>  IN EFI_RESOURCE_ATTRIBUTE_TYPE  ResourceAttribute<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS         PhysicalStart<span class="token punctuation">,</span>  IN UINT64                       NumberOfBytes<span class="token punctuation">,</span>  IN EFI_GUID                     <span class="token operator">*</span>OwnerGUID  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a HOB that describes a chunk of system memory.  This function builds a HOB that describes a chunk of system memory.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  ResourceType        The type of resource described by this HOB.  @param  ResourceAttribute   The resource attributes of the memory described by this HOB.  @param  PhysicalStart       The 64 bit physical address of memory described by this HOB.  @param  NumberOfBytes       The length of the memory described by this HOB in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildResourceDescriptorHob</span> <span class="token punctuation">(</span>  IN EFI_RESOURCE_TYPE            ResourceType<span class="token punctuation">,</span>  IN EFI_RESOURCE_ATTRIBUTE_TYPE  ResourceAttribute<span class="token punctuation">,</span>  IN EFI_PHYSICAL_ADDRESS         PhysicalStart<span class="token punctuation">,</span>  IN UINT64                       NumberOfBytes  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a customized HOB tagged with a GUID for identification and returns  the start address of GUID HOB data.  This function builds a customized HOB tagged with a GUID for identification  and returns the start address of GUID HOB data so that caller can fill the customized data.  The HOB Header and Name field is already stripped.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If Guid is NULL, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  If DataLength > (0xFFF8 - sizeof (EFI_HOB_GUID_TYPE)), then ASSERT().  HobLength is UINT16 and multiples of 8 bytes, so the max HobLength is 0xFFF8.  @param  Guid          The GUID to tag the customized HOB.  @param  DataLength    The size of the data payload for the GUID HOB.  @retval  NULL         The GUID HOB could not be allocated.  @retval  others       The start address of GUID HOB data.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">BuildGuidHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID              <span class="token operator">*</span>Guid<span class="token punctuation">,</span>  IN UINTN                       DataLength  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a customized HOB tagged with a GUID for identification, copies the input data to the HOB  data field, and returns the start address of the GUID HOB data.  This function builds a customized HOB tagged with a GUID for identification and copies the input  data to the HOB data field and returns the start address of the GUID HOB data.  It can only be  invoked during PEI phase; for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  The HOB Header and Name field is already stripped.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If Guid is NULL, then ASSERT().  If Data is NULL and DataLength > 0, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  If DataLength > (0xFFF8 - sizeof (EFI_HOB_GUID_TYPE)), then ASSERT().  HobLength is UINT16 and multiples of 8 bytes, so the max HobLength is 0xFFF8.  @param  Guid          The GUID to tag the customized HOB.  @param  Data          The data to be copied into the data field of the GUID HOB.  @param  DataLength    The size of the data payload for the GUID HOB.  @retval  NULL         The GUID HOB could not be allocated.  @retval  others       The start address of GUID HOB data.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">BuildGuidDataHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID              <span class="token operator">*</span>Guid<span class="token punctuation">,</span>  IN VOID                        <span class="token operator">*</span>Data<span class="token punctuation">,</span>  IN UINTN                       DataLength  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a Firmware Volume HOB.  This function builds a Firmware Volume HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  If the FvImage buffer is not at its required alignment, then ASSERT().  @param  BaseAddress   The base address of the Firmware Volume.  @param  Length        The size of the Firmware Volume in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildFvHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a EFI_HOB_TYPE_FV2 HOB.  This function builds a EFI_HOB_TYPE_FV2 HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  If the FvImage buffer is not at its required alignment, then ASSERT().  @param  BaseAddress   The base address of the Firmware Volume.  @param  Length        The size of the Firmware Volume in bytes.  @param  FvName        The name of the Firmware Volume.  @param  FileName      The name of the file.**/</span>VOIDEFIAPI<span class="token function">BuildFv2Hob</span> <span class="token punctuation">(</span>  IN          EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN          UINT64                      Length<span class="token punctuation">,</span>  IN CONST    EFI_GUID                    <span class="token operator">*</span>FvName<span class="token punctuation">,</span>  IN CONST    EFI_GUID                    <span class="token operator">*</span>FileName  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a EFI_HOB_TYPE_FV3 HOB.  This function builds a EFI_HOB_TYPE_FV3 HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  If the FvImage buffer is not at its required alignment, then ASSERT().  @param BaseAddress            The base address of the Firmware Volume.  @param Length                 The size of the Firmware Volume in bytes.  @param AuthenticationStatus   The authentication status.  @param ExtractedFv            TRUE if the FV was extracted as a file within                                another firmware volume. FALSE otherwise.  @param FvName                 The name of the Firmware Volume.                                Valid only if IsExtractedFv is TRUE.  @param FileName               The name of the file.                                Valid only if IsExtractedFv is TRUE.**/</span>VOIDEFIAPI<span class="token function">BuildFv3Hob</span> <span class="token punctuation">(</span>  IN          EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN          UINT64                      Length<span class="token punctuation">,</span>  IN          UINT32                      AuthenticationStatus<span class="token punctuation">,</span>  IN          BOOLEAN                     ExtractedFv<span class="token punctuation">,</span>  IN CONST    EFI_GUID                    <span class="token operator">*</span>FvName<span class="token punctuation">,</span> OPTIONAL  IN CONST    EFI_GUID                    <span class="token operator">*</span>FileName OPTIONAL  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a Capsule Volume HOB.  This function builds a Capsule Volume HOB.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If the platform does not support Capsule Volume HOBs, then ASSERT().  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The base address of the Capsule Volume.  @param  Length        The size of the Capsule Volume in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildCvHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a HOB for the CPU.  This function builds a HOB for the CPU.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  SizeOfMemorySpace   The maximum physical memory addressability of the processor.  @param  SizeOfIoSpace       The maximum physical I/O addressability of the processor.**/</span>VOIDEFIAPI<span class="token function">BuildCpuHob</span> <span class="token punctuation">(</span>  IN UINT8                       SizeOfMemorySpace<span class="token punctuation">,</span>  IN UINT8                       SizeOfIoSpace  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a HOB for the Stack.  This function builds a HOB for the stack.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The 64 bit physical address of the Stack.  @param  Length        The length of the stack in bytes.**/</span>VOIDEFIAPI<span class="token function">BuildStackHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a HOB for the BSP store.  This function builds a HOB for BSP store.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The 64 bit physical address of the BSP.  @param  Length        The length of the BSP store in bytes.  @param  MemoryType    Type of memory allocated by this HOB.**/</span>VOIDEFIAPI<span class="token function">BuildBspStoreHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length<span class="token punctuation">,</span>  IN EFI_MEMORY_TYPE             MemoryType  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Builds a HOB for the memory allocation.  This function builds a HOB for the memory allocation.  It can only be invoked during PEI phase;  for DXE phase, it will ASSERT() since PEI HOB is read-only for DXE phase.  If there is no additional space for HOB creation, then ASSERT().  @param  BaseAddress   The 64 bit physical address of the memory.  @param  Length        The length of the memory allocation in bytes.  @param  MemoryType    Type of memory allocated by this HOB.**/</span>VOIDEFIAPI<span class="token function">BuildMemoryAllocationHob</span> <span class="token punctuation">(</span>  IN EFI_PHYSICAL_ADDRESS        BaseAddress<span class="token punctuation">,</span>  IN UINT64                      Length<span class="token punctuation">,</span>  IN EFI_MEMORY_TYPE             MemoryType  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><blockquote><p>无此方法</p></blockquote><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><ul><li>GetHobList</li><li>GetNextHob</li><li>GetFirstHob</li><li>GetFirstGuidHob</li><li>GetNextGuidHob</li><li>GetBootModeHob</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**  Returns the pointer to the HOB list.  This function returns the pointer to first HOB in the list.  For PEI phase, the PEI service GetHobList() can be used to retrieve the pointer  to the HOB list.  For the DXE phase, the HOB list pointer can be retrieved through  the EFI System Table by looking up theHOB list GUID in the System Configuration Table.  Since the System Configuration Table does not exist that the time the DXE Core is  launched, the DXE Core uses a global variable from the DXE Core Entry Point Library  to manage the pointer to the HOB list.  If the pointer to the HOB list is NULL, then ASSERT().  @return The pointer to the HOB list.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetHobList</span> <span class="token punctuation">(</span>  VOID  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Returns the next instance of a HOB type from the starting HOB.  This function searches the first instance of a HOB type from the starting HOB pointer.  If there does not exist such HOB type from the starting HOB pointer, it will return NULL.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.  If HobStart is NULL, then ASSERT().  @param  Type          The HOB type to return.  @param  HobStart      The starting HOB pointer to search from.  @return The next instance of a HOB type from the starting HOB.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetNextHob</span> <span class="token punctuation">(</span>  IN UINT16                 Type<span class="token punctuation">,</span>  IN CONST VOID             <span class="token operator">*</span>HobStart  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Returns the first instance of a HOB type among the whole HOB list.  This function searches the first instance of a HOB type among the whole HOB list.  If there does not exist such HOB type in the HOB list, it will return NULL.  If the pointer to the HOB list is NULL, then ASSERT().  @param  Type          The HOB type to return.  @return The next instance of a HOB type from the starting HOB.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetFirstHob</span> <span class="token punctuation">(</span>  IN UINT16                 Type  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Returns the next instance of the matched GUID HOB from the starting HOB.  This function searches the first instance of a HOB from the starting HOB pointer.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size info respectively.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.  If Guid is NULL, then ASSERT().  If HobStart is NULL, then ASSERT().  @param  Guid          The GUID to match with in the HOB list.  @param  HobStart      A pointer to a Guid.  @return The next instance of the matched GUID HOB from the starting HOB.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetNextGuidHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID         <span class="token operator">*</span>Guid<span class="token punctuation">,</span>  IN CONST VOID             <span class="token operator">*</span>HobStart  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Returns the first instance of the matched GUID HOB among the whole HOB list.  This function searches the first instance of a HOB among the whole HOB list.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size info respectively.  If the pointer to the HOB list is NULL, then ASSERT().  If Guid is NULL, then ASSERT().  @param  Guid          The GUID to match with in the HOB list.  @return The first instance of the matched GUID HOB among the whole HOB list.**/</span>VOID <span class="token operator">*</span>EFIAPI<span class="token function">GetFirstGuidHob</span> <span class="token punctuation">(</span>  IN CONST EFI_GUID         <span class="token operator">*</span>Guid  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**  Get the system boot mode from the HOB list.  This function returns the system boot mode information from the  PHIT HOB in HOB list.  If the pointer to the HOB list is NULL, then ASSERT().  @param  VOID  @return The Boot Mode.**/</span>EFI_BOOT_MODEEFIAPI<span class="token function">GetBootModeHob</span> <span class="token punctuation">(</span>  VOID  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><blockquote><p>未提供方法，一般是先找到感兴趣的Hob，再修改Block中的数据</p></blockquote><hr><h1 id="HOB相关接口的实现"><a href="#HOB相关接口的实现" class="headerlink" title="HOB相关接口的实现"></a>HOB相关接口的实现</h1><ul><li>HobLib.h </li><li>MdePkg\Library\PeiHobLib\HobLib.c </li><li>MdePkg\Library\DxeHobLib\HobLib.c </li><li>MdePkg\Library\DxeCoreHobLib\HobLib.c </li><li>IntelFrameworkPkg\Library\PeiHobLibFramework\HobLib.c </li></ul><h2 id="相关宏函数"><a href="#相关宏函数" class="headerlink" title="相关宏函数"></a>相关宏函数</h2><ul><li>GET_HOB_TYPE</li><li>GET_HOB_LENGTH</li><li>GET_NEXT_HOB</li><li>END_OF_HOB_LIST</li><li>GET_GUID_HOB_DATAET_GUID_HOB_DATA</li><li>GET_GUID_HOB_DATA_SIZE</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  Returns the type of a HOB.  This macro returns the HobType field from the HOB header for the  HOB specified by HobStart.  @param  HobStart   A pointer to a HOB.  @return HobType.**&#x2F;#define GET_HOB_TYPE(HobStart) \  ((*(EFI_HOB_GENERIC_HEADER **)&amp;(HobStart))-&gt;HobType)&#x2F;**  Returns the length, in bytes, of a HOB.  This macro returns the HobLength field from the HOB header for the  HOB specified by HobStart.  @param  HobStart   A pointer to a HOB.  @return HobLength.**&#x2F;#define GET_HOB_LENGTH(HobStart) \  ((*(EFI_HOB_GENERIC_HEADER **)&amp;(HobStart))-&gt;HobLength)&#x2F;**  Returns a pointer to the next HOB in the HOB list.  This macro returns a pointer to HOB that follows the  HOB specified by HobStart in the HOB List.  @param  HobStart   A pointer to a HOB.  @return A pointer to the next HOB in the HOB list.**&#x2F;#define GET_NEXT_HOB(HobStart) \  (VOID *)(*(UINT8 **)&amp;(HobStart) + GET_HOB_LENGTH (HobStart))&#x2F;**  Determines if a HOB is the last HOB in the HOB list.  This macro determine if the HOB specified by HobStart is the  last HOB in the HOB list.  If HobStart is last HOB in the HOB list,  then TRUE is returned.  Otherwise, FALSE is returned.  @param  HobStart   A pointer to a HOB.  @retval TRUE       The HOB specified by HobStart is the last HOB in the HOB list.  @retval FALSE      The HOB specified by HobStart is not the last HOB in the HOB list.**&#x2F;#define END_OF_HOB_LIST(HobStart)  (GET_HOB_TYPE (HobStart) &#x3D;&#x3D; (UINT16)EFI_HOB_TYPE_END_OF_HOB_LIST)&#x2F;**  Returns a pointer to data buffer from a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  This macro returns a pointer to the data buffer in a HOB specified by HobStart.  HobStart is assumed to be a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  @param   GuidHob   A pointer to a HOB.  @return  A pointer to the data buffer in a HOB.**&#x2F;#define GET_GUID_HOB_DATA(HobStart) \  (VOID *)(*(UINT8 **)&amp;(HobStart) + sizeof (EFI_HOB_GUID_TYPE))&#x2F;**  Returns the size of the data buffer from a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  This macro returns the size, in bytes, of the data buffer in a HOB specified by HobStart.  HobStart is assumed to be a HOB of type EFI_HOB_TYPE_GUID_EXTENSION.  @param   GuidHob   A pointer to a HOB.  @return  The size of the data buffer.**&#x2F;#define GET_GUID_HOB_DATA_SIZE(HobStart) \  (UINT16)(GET_HOB_LENGTH (HobStart) - sizeof (EFI_HOB_GUID_TYPE))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="CreateHob-仅PEI阶段有效"><a href="#CreateHob-仅PEI阶段有效" class="headerlink" title="CreateHob(仅PEI阶段有效)"></a>CreateHob(仅PEI阶段有效)</h2><ul><li>MdeModulePkg\Core\Pei\PeiMain.h</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  Add a new HOB to the HOB List.   @param PeiServices        An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param Type               Type of the new HOB.  @param Length             Length of the new HOB to allocate.  @param Hob                Pointer to the new HOB.   @return  EFI_SUCCESS           Success to create hob.  @retval  EFI_INVALID_PARAMETER if Hob is NULL  @retval  EFI_NOT_AVAILABLE_YET if HobList is still not available.  @retval  EFI_OUT_OF_RESOURCES  if there is no more memory to grow the Hoblist. **&#x2F;EFI_STATUSEFIAPIPeiCreateHob (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN UINT16            Type,  IN UINT16            Length,  IN OUT VOID          **Hob  );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>MdeModulePkg\Core\Pei\Hob\Hob.c</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  Add a new HOB to the HOB List.   @param PeiServices      An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param Type             Type of the new HOB.  @param Length           Length of the new HOB to allocate.  @param Hob              Pointer to the new HOB.   @return  EFI_SUCCESS           Success to create hob.  @retval  EFI_INVALID_PARAMETER if Hob is NULL  @retval  EFI_NOT_AVAILABLE_YET if HobList is still not available.  @retval  EFI_OUT_OF_RESOURCES  if there is no more memory to grow the Hoblist. **&#x2F;EFI_STATUSEFIAPIPeiCreateHob (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN UINT16            Type,  IN UINT16            Length,  IN OUT VOID          **Hob  )&#123;  EFI_STATUS                           Status;  EFI_HOB_HANDOFF_INFO_TABLE           *HandOffHob;  EFI_HOB_GENERIC_HEADER               *HobEnd;  EFI_PHYSICAL_ADDRESS                 FreeMemory;    Status &#x3D; PeiGetHobList (PeiServices, Hob);  if (EFI_ERROR(Status)) &#123;    return Status;  &#125;   HandOffHob &#x3D; *Hob;   &#x2F;&#x2F;  &#x2F;&#x2F; Check Length to avoid data overflow.  &#x2F;&#x2F;  if (0x10000 - Length &lt;&#x3D; 0x7) &#123;    return EFI_INVALID_PARAMETER;  &#125;  Length     &#x3D; (UINT16)((Length + 0x7) &amp; (~0x7));   FreeMemory &#x3D; HandOffHob-&gt;EfiFreeMemoryTop -               HandOffHob-&gt;EfiFreeMemoryBottom;   if (FreeMemory &lt; Length) &#123;    DEBUG ((EFI_D_ERROR, &quot;PeiCreateHob fail: Length - 0x%08x\n&quot;, (UINTN)Length));    DEBUG ((EFI_D_ERROR, &quot;  FreeMemoryTop    - 0x%08x\n&quot;, (UINTN)HandOffHob-&gt;EfiFreeMemoryTop));    DEBUG ((EFI_D_ERROR, &quot;  FreeMemoryBottom - 0x%08x\n&quot;, (UINTN)HandOffHob-&gt;EfiFreeMemoryBottom));    return EFI_OUT_OF_RESOURCES;  &#125;   *Hob &#x3D; (VOID*) (UINTN) HandOffHob-&gt;EfiEndOfHobList;  ((EFI_HOB_GENERIC_HEADER*) *Hob)-&gt;HobType   &#x3D; Type;  ((EFI_HOB_GENERIC_HEADER*) *Hob)-&gt;HobLength &#x3D; Length;  ((EFI_HOB_GENERIC_HEADER*) *Hob)-&gt;Reserved  &#x3D; 0;   HobEnd &#x3D; (EFI_HOB_GENERIC_HEADER*) ((UINTN) *Hob + Length);  HandOffHob-&gt;EfiEndOfHobList &#x3D; (EFI_PHYSICAL_ADDRESS) (UINTN) HobEnd;   HobEnd-&gt;HobType   &#x3D; EFI_HOB_TYPE_END_OF_HOB_LIST;  HobEnd-&gt;HobLength &#x3D; (UINT16) sizeof (EFI_HOB_GENERIC_HEADER);  HobEnd-&gt;Reserved  &#x3D; 0;  HobEnd++;  HandOffHob-&gt;EfiFreeMemoryBottom &#x3D; (EFI_PHYSICAL_ADDRESS) (UINTN) HobEnd;   return EFI_SUCCESS;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>MdePkg\Include\Pi\PiPeiCis.h</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  This service, published by the PEI Foundation, abstracts the creation of a Hand-Off Block&#39;s (HOB&#39;s) headers.   @param  PeiServices      An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param  Type             The type of HOB to be installed.  @param  Length           The length of the HOB to be added.  @param  Hob              The address of a pointer that will contain the HOB header.   @retval EFI_SUCCESS           The HOB was successfully created.  @retval EFI_OUT_OF_RESOURCES  There is no additional space for HOB creation. **&#x2F;typedefEFI_STATUS(EFIAPI *EFI_PEI_CREATE_HOB)(  IN CONST EFI_PEI_SERVICES            **PeiServices,  IN UINT16                            Type,  IN UINT16                            Length,  IN OUT VOID                          **Hob  ); &#x2F;&#x2F;&#x2F; EFI_PEI_SERVICES is a collection of functions whose implementation is provided by the PEI&#x2F;&#x2F;&#x2F; Foundation. These services fall into various classes, including the following:&#x2F;&#x2F;&#x2F; - Managing the boot mode&#x2F;&#x2F;&#x2F; - Allocating both early and permanent memory&#x2F;&#x2F;&#x2F; - Supporting the Firmware File System (FFS)&#x2F;&#x2F;&#x2F; - Abstracting the PPI database abstraction&#x2F;&#x2F;&#x2F; - Creating Hand-Off Blocks (HOBs).&#x2F;&#x2F;&#x2F;struct _EFI_PEI_SERVICES &#123;  &#x2F;&#x2F;&#x2F;  &#x2F;&#x2F;&#x2F; The table header for the PEI Services Table.  &#x2F;&#x2F;&#x2F;  EFI_TABLE_HEADER                Hdr;   &#x2F;&#x2F;  &#x2F;&#x2F; PPI Functions  &#x2F;&#x2F;  EFI_PEI_INSTALL_PPI             InstallPpi;  EFI_PEI_REINSTALL_PPI           ReInstallPpi;  EFI_PEI_LOCATE_PPI              LocatePpi;  EFI_PEI_NOTIFY_PPI              NotifyPpi;   &#x2F;&#x2F;  &#x2F;&#x2F; Boot Mode Functions  &#x2F;&#x2F;  EFI_PEI_GET_BOOT_MODE           GetBootMode;  EFI_PEI_SET_BOOT_MODE           SetBootMode;   &#x2F;&#x2F;  &#x2F;&#x2F; HOB Functions  &#x2F;&#x2F;  EFI_PEI_GET_HOB_LIST            GetHobList;  EFI_PEI_CREATE_HOB              CreateHob;   &#x2F;&#x2F;  &#x2F;&#x2F; Firmware Volume Functions  &#x2F;&#x2F;  EFI_PEI_FFS_FIND_NEXT_VOLUME2   FfsFindNextVolume;  EFI_PEI_FFS_FIND_NEXT_FILE2     FfsFindNextFile;  EFI_PEI_FFS_FIND_SECTION_DATA2  FfsFindSectionData;   &#x2F;&#x2F;  &#x2F;&#x2F; PEI Memory Functions  &#x2F;&#x2F;  EFI_PEI_INSTALL_PEI_MEMORY      InstallPeiMemory;  EFI_PEI_ALLOCATE_PAGES          AllocatePages;  EFI_PEI_ALLOCATE_POOL           AllocatePool;  EFI_PEI_COPY_MEM                CopyMem;  EFI_PEI_SET_MEM                 SetMem;   &#x2F;&#x2F;  &#x2F;&#x2F; Status Code  &#x2F;&#x2F;  EFI_PEI_REPORT_STATUS_CODE      ReportStatusCode;   &#x2F;&#x2F;  &#x2F;&#x2F; Reset  &#x2F;&#x2F;  EFI_PEI_RESET_SYSTEM            ResetSystem;   &#x2F;&#x2F;  &#x2F;&#x2F; (the following interfaces are installed by publishing PEIM)  &#x2F;&#x2F; I&#x2F;O Abstractions  &#x2F;&#x2F;  EFI_PEI_CPU_IO_PPI              *CpuIo;  EFI_PEI_PCI_CFG2_PPI            *PciCfg;   &#x2F;&#x2F;  &#x2F;&#x2F; Future Installed Services  &#x2F;&#x2F;  EFI_PEI_FFS_FIND_BY_NAME        FfsFindFileByName;  EFI_PEI_FFS_GET_FILE_INFO       FfsGetFileInfo;  EFI_PEI_FFS_GET_VOLUME_INFO     FfsGetVolumeInfo;  EFI_PEI_REGISTER_FOR_SHADOW     RegisterForShadow;  EFI_PEI_FFS_FIND_SECTION_DATA3  FindSectionData3;  EFI_PEI_FFS_GET_FILE_INFO2      FfsGetFileInfo2;  EFI_PEI_RESET2_SYSTEM           ResetSystem2;  EFI_PEI_FREE_PAGES              FreePages;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>MdeModulePkg\Core\Pei\PeiMain\PeiMain.c</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;&#x2F; Pei service instance&#x2F;&#x2F;&#x2F;EFI_PEI_SERVICES  gPs &#x3D; &#123;  &#123;    PEI_SERVICES_SIGNATURE,    PEI_SERVICES_REVISION,    sizeof (EFI_PEI_SERVICES),    0,    0  &#125;,  PeiInstallPpi,  PeiReInstallPpi,  PeiLocatePpi,  PeiNotifyPpi,   PeiGetBootMode,  PeiSetBootMode,   PeiGetHobList,  PeiCreateHob,   PeiFfsFindNextVolume,  PeiFfsFindNextFile,  PeiFfsFindSectionData,   PeiInstallPeiMemory,  PeiAllocatePages,  PeiAllocatePool,  (EFI_PEI_COPY_MEM)CopyMem,  (EFI_PEI_SET_MEM)SetMem,   PeiReportStatusCode,  PeiResetSystem,   &amp;gPeiDefaultCpuIoPpi,  &amp;gPeiDefaultPciCfg2Ppi,   PeiFfsFindFileByName,  PeiFfsGetFileInfo,  PeiFfsGetVolumeInfo,  PeiRegisterForShadow,  PeiFfsFindSectionData3,  PeiFfsGetFileInfo2,  PeiResetSystem2,  PeiFreePages,&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="GetHobList-PEI阶段实现"><a href="#GetHobList-PEI阶段实现" class="headerlink" title="GetHobList(PEI阶段实现)"></a>GetHobList(PEI阶段实现)</h2><ul><li>MdeModulePkg\Core\Pei\PeiMain.h</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;**   Gets the pointer to the HOB List.    @param PeiServices                   An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param HobList                       Pointer to the HOB List.   @retval EFI_SUCCESS                  Get the pointer of HOB List  @retval EFI_NOT_AVAILABLE_YET        the HOB List is not yet published  @retval EFI_INVALID_PARAMETER        HobList is NULL (in debug mode) **&#x2F;EFI_STATUSEFIAPIPeiGetHobList (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN OUT VOID          **HobList  );  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>MdeModulePkg\Core\Pei\Hob\Hob.c</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;**   Gets the pointer to the HOB List.   @param PeiServices                   An indirect pointer to the EFI_PEI_SERVICES table published by the PEI Foundation.  @param HobList                       Pointer to the HOB List.   @retval EFI_SUCCESS                  Get the pointer of HOB List  @retval EFI_NOT_AVAILABLE_YET        the HOB List is not yet published  @retval EFI_INVALID_PARAMETER        HobList is NULL (in debug mode) **&#x2F;EFI_STATUSEFIAPIPeiGetHobList (  IN CONST EFI_PEI_SERVICES  **PeiServices,  IN OUT VOID          **HobList  )&#123;  PEI_CORE_INSTANCE *PrivateData;   &#x2F;&#x2F;  &#x2F;&#x2F; Only check this parameter in debug mode  &#x2F;&#x2F;   DEBUG_CODE_BEGIN ();    if (HobList &#x3D;&#x3D; NULL) &#123;      return EFI_INVALID_PARAMETER;    &#125;  DEBUG_CODE_END ();   PrivateData &#x3D; PEI_CORE_INSTANCE_FROM_PS_THIS(PeiServices);   *HobList    &#x3D; PrivateData-&gt;HobList.Raw;   return EFI_SUCCESS;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>PeiMain.h</li></ul><blockquote><p>这个宏的作用是根据一个结构体成员变量的的地址获得该结构体基地址</p></blockquote><p>定义形式：<br>#define _CR(Record, TYPE, Field) <br>((TYPE *) ((CHAR8 *) (Record) - (CHAR8 *) &amp;(((TYPE *) 0)-&gt;Field)))<br>功能是：找出TYPE类型结构体成员Field所在结构体的地址,Record是Field的地址。</p><p>具体实现：<br>1.(CHAR8 *) (Record)：Field的地址以CHAR8 *类型进行运算。</p><p>2.(CHAR8 *) &amp;(((TYPE *) 0)-&gt;Field))：重点就是(TYPE *) 0)了，ANSI C标准允许值为0的常量被强制转换成任何一种类型的指针，并且转换结果是一个NULL指针，因此((type *)0)的结果就是一个类型为type *的NULL指针。如果利用这NULL指针来访问type的成员当然是非法的，但&amp;( ((type *)0)-&gt;field )的意图仅仅是计算field字段的地址。聪明的编译器根本就不生成访问type的代码，而仅仅是根据type的内存布局和结构体实例首址在编译期计算这个（常量）地址，这样就完全避免了通过NULL指针访问内存的问题。又因为首址为0，所以这个地址的值就是字段相对于结构体基址的偏移。以上方法避免了实例化一个type对象，并且求值在编译期进行，没有运行期负担。这样，就得到了Field在它的结构体中的偏移地址并同样以CHAR8 *类型进行运算。</p><p>3.((TYPE *) ：最后求得的地址转成原有结构体类型。<br>用1得到的变量地址减去2得到的变量偏移地址，得到的基地址通过3转换回原来的类型。大功告成！<br>重点就是  ((TYPE *) 0)-&gt;Field)。</p><pre class="line-numbers language-none"><code class="language-none"> &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Pei Core Instance Data Macros&#x2F;&#x2F;&#x2F;#define PEI_CORE_INSTANCE_FROM_PS_THIS(a) \  CR(a, PEI_CORE_INSTANCE, Ps, PEI_CORE_HANDLE_SIGNATURE)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="GetHobList-DXE阶段实现"><a href="#GetHobList-DXE阶段实现" class="headerlink" title="GetHobList(DXE阶段实现)"></a>GetHobList(DXE阶段实现)</h2><ul><li>MdePkg\Library\DxeHobLib\HobLib.c</li></ul><pre class="line-numbers language-none"><code class="language-none">VOID  *mHobList &#x3D; NULL; &#x2F;**  Returns the pointer to the HOB list.   This function returns the pointer to first HOB in the list.  For PEI phase, the PEI service GetHobList() can be used to retrieve the pointer  to the HOB list.  For the DXE phase, the HOB list pointer can be retrieved through  the EFI System Table by looking up theHOB list GUID in the System Configuration Table.  Since the System Configuration Table does not exist that the time the DXE Core is  launched, the DXE Core uses a global variable from the DXE Core Entry Point Library  to manage the pointer to the HOB list.   If the pointer to the HOB list is NULL, then ASSERT().   This function also caches the pointer to the HOB list retrieved.   @return The pointer to the HOB list. **&#x2F;VOID *EFIAPIGetHobList (  VOID  )&#123;  EFI_STATUS  Status;   if (mHobList &#x3D;&#x3D; NULL) &#123;    Status &#x3D; EfiGetSystemConfigurationTable (&amp;gEfiHobListGuid, &amp;mHobList);    ASSERT_EFI_ERROR (Status);    ASSERT (mHobList !&#x3D; NULL);  &#125;  return mHobList;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  Retrieves a pointer to the system configuration table from the EFI System Table  based on a specified GUID.   This function searches the list of configuration tables stored in the EFI System Table  for a table with a GUID that matches TableGuid.  If a match is found, then a pointer to  the configuration table is returned in Table., and EFI_SUCCESS is returned. If a matching GUID  is not found, then EFI_NOT_FOUND is returned.  If TableGuid is NULL, then ASSERT().  If Table is NULL, then ASSERT().   @param  TableGuid       The pointer to table&#39;s GUID type.  @param  Table           The pointer to the table associated with TableGuid in the EFI System Table.   @retval EFI_SUCCESS     A configuration table matching TableGuid was found.  @retval EFI_NOT_FOUND   A configuration table matching TableGuid could not be found. **&#x2F;EFI_STATUSEFIAPIEfiGetSystemConfigurationTable (  IN  EFI_GUID  *TableGuid,  OUT VOID      **Table  )&#123;  EFI_SYSTEM_TABLE  *SystemTable;  UINTN             Index;   ASSERT (TableGuid !&#x3D; NULL);  ASSERT (Table !&#x3D; NULL);   SystemTable &#x3D; gST;  *Table &#x3D; NULL;  for (Index &#x3D; 0; Index &lt; SystemTable-&gt;NumberOfTableEntries; Index++) &#123;    if (CompareGuid (TableGuid, &amp;(SystemTable-&gt;ConfigurationTable[Index].VendorGuid))) &#123;      *Table &#x3D; SystemTable-&gt;ConfigurationTable[Index].VendorTable;      return EFI_SUCCESS;    &#125;  &#125;   return EFI_NOT_FOUND;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="GetNextHob"><a href="#GetNextHob" class="headerlink" title="GetNextHob"></a>GetNextHob</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  Returns the next instance of a HOB type from the starting HOB.   This function searches the first instance of a HOB type from the starting HOB pointer.  If there does not exist such HOB type from the starting HOB pointer, it will return NULL.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.   If HobStart is NULL, then ASSERT().   @param  Type          The HOB type to return.  @param  HobStart      The starting HOB pointer to search from.   @return The next instance of a HOB type from the starting HOB. **&#x2F;VOID *EFIAPIGetNextHob (  IN UINT16                 Type,  IN CONST VOID             *HobStart  )&#123;  EFI_PEI_HOB_POINTERS  Hob;   ASSERT (HobStart !&#x3D; NULL);   Hob.Raw &#x3D; (UINT8 *) HobStart;  &#x2F;&#x2F;  &#x2F;&#x2F; Parse the HOB list until end of list or matching type is found.  &#x2F;&#x2F;  while (!END_OF_HOB_LIST (Hob)) &#123;    if (Hob.Header-&gt;HobType &#x3D;&#x3D; Type) &#123;      return Hob.Raw;    &#125;    Hob.Raw &#x3D; GET_NEXT_HOB (Hob);  &#125;  return NULL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="GetFirstHob"><a href="#GetFirstHob" class="headerlink" title="GetFirstHob"></a>GetFirstHob</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  Returns the first instance of a HOB type among the whole HOB list.   This function searches the first instance of a HOB type among the whole HOB list.  If there does not exist such HOB type in the HOB list, it will return NULL.   If the pointer to the HOB list is NULL, then ASSERT().   @param  Type          The HOB type to return.   @return The next instance of a HOB type from the starting HOB. **&#x2F;VOID *EFIAPIGetFirstHob (  IN UINT16                 Type  )&#123;  VOID      *HobList;   HobList &#x3D; GetHobList ();  return GetNextHob (Type, HobList);&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="GetNextGuidHob"><a href="#GetNextGuidHob" class="headerlink" title="GetNextGuidHob"></a>GetNextGuidHob</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  Returns the next instance of the matched GUID HOB from the starting HOB.   This function searches the first instance of a HOB from the starting HOB pointer.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size information, respectively.  In contrast with macro GET_NEXT_HOB(), this function does not skip the starting HOB pointer  unconditionally: it returns HobStart back if HobStart itself meets the requirement;  caller is required to use GET_NEXT_HOB() if it wishes to skip current HobStart.   If Guid is NULL, then ASSERT().  If HobStart is NULL, then ASSERT().   @param  Guid          The GUID to match with in the HOB list.  @param  HobStart      A pointer to a Guid.   @return The next instance of the matched GUID HOB from the starting HOB. **&#x2F;VOID *EFIAPIGetNextGuidHob (  IN CONST EFI_GUID         *Guid,  IN CONST VOID             *HobStart  )&#123;  EFI_PEI_HOB_POINTERS  GuidHob;   GuidHob.Raw &#x3D; (UINT8 *) HobStart;  while ((GuidHob.Raw &#x3D; GetNextHob (EFI_HOB_TYPE_GUID_EXTENSION, GuidHob.Raw)) !&#x3D; NULL) &#123;    if (CompareGuid (Guid, &amp;GuidHob.Guid-&gt;Name)) &#123;      break;    &#125;    GuidHob.Raw &#x3D; GET_NEXT_HOB (GuidHob);  &#125;  return GuidHob.Raw;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="GetFirstGuidHob"><a href="#GetFirstGuidHob" class="headerlink" title="GetFirstGuidHob"></a>GetFirstGuidHob</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  Returns the first instance of the matched GUID HOB among the whole HOB list.   This function searches the first instance of a HOB among the whole HOB list.  Such HOB should satisfy two conditions:  its HOB type is EFI_HOB_TYPE_GUID_EXTENSION and its GUID Name equals to the input Guid.  If there does not exist such HOB from the starting HOB pointer, it will return NULL.  Caller is required to apply GET_GUID_HOB_DATA () and GET_GUID_HOB_DATA_SIZE ()  to extract the data section and its size information, respectively.   If the pointer to the HOB list is NULL, then ASSERT().  If Guid is NULL, then ASSERT().   @param  Guid          The GUID to match with in the HOB list.   @return The first instance of the matched GUID HOB among the whole HOB list. **&#x2F;VOID *EFIAPIGetFirstGuidHob (  IN CONST EFI_GUID         *Guid  )&#123;  VOID      *HobList;   HobList &#x3D; GetHobList ();  return GetNextGuidHob (Guid, HobList);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="HOB生产消费流程"><a href="#HOB生产消费流程" class="headerlink" title="HOB生产消费流程"></a>HOB生产消费流程</h1><h2 id="PHIT-HOB的建立"><a href="#PHIT-HOB的建立" class="headerlink" title="PHIT HOB的建立"></a>PHIT HOB的建立</h2><ul><li> MdeModulePkg\Core\Pei\Hob\Hob.c</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;**   Builds a Handoff Information Table HOB   @param BootMode        - Current Bootmode  @param MemoryBegin     - Start Memory Address.  @param MemoryLength    - Length of Memory.   @return EFI_SUCCESS Always success to initialize HOB. **&#x2F;EFI_STATUSPeiCoreBuildHobHandoffInfoTable (  IN EFI_BOOT_MODE         BootMode,  IN EFI_PHYSICAL_ADDRESS  MemoryBegin,  IN UINT64                MemoryLength  )&#123;  EFI_HOB_HANDOFF_INFO_TABLE   *Hob;  EFI_HOB_GENERIC_HEADER       *HobEnd;   Hob                      &#x3D; (VOID *)(UINTN)MemoryBegin;  HobEnd                   &#x3D; (EFI_HOB_GENERIC_HEADER*) (Hob+1);  Hob-&gt;Header.HobType      &#x3D; EFI_HOB_TYPE_HANDOFF;  Hob-&gt;Header.HobLength    &#x3D; (UINT16) sizeof (EFI_HOB_HANDOFF_INFO_TABLE);  Hob-&gt;Header.Reserved     &#x3D; 0;   HobEnd-&gt;HobType          &#x3D; EFI_HOB_TYPE_END_OF_HOB_LIST;  HobEnd-&gt;HobLength        &#x3D; (UINT16) sizeof (EFI_HOB_GENERIC_HEADER);  HobEnd-&gt;Reserved         &#x3D; 0;   Hob-&gt;Version             &#x3D; EFI_HOB_HANDOFF_TABLE_VERSION;  Hob-&gt;BootMode            &#x3D; BootMode;   Hob-&gt;EfiMemoryTop        &#x3D; MemoryBegin + MemoryLength;  Hob-&gt;EfiMemoryBottom     &#x3D; MemoryBegin;  Hob-&gt;EfiFreeMemoryTop    &#x3D; MemoryBegin + MemoryLength;  Hob-&gt;EfiFreeMemoryBottom &#x3D; (EFI_PHYSICAL_ADDRESS) (UINTN) (HobEnd + 1);  Hob-&gt;EfiEndOfHobList     &#x3D; (EFI_PHYSICAL_ADDRESS) (UINTN) HobEnd;   return EFI_SUCCESS;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>头和尾HOB建立后，CreateHob会覆盖尾HOB，再将尾HOB后移，此时PEI阶段的模块会相继创建各种类型的HOB，我们可以在PEI阶段自己创建HOB传递一些数据，也可以在PEI和DXE阶段找到感兴趣的HOB块，对其BLOCK数据块进行操作，但是理论上在DXE阶段使用Get方法，不建议在PEI阶段使用，是因为不确定Get的HOB是否已经建立，即无法判断两个Pei ModulePart的执行顺序，当然也可以通过Deepx来限定ModulePart跑的顺序</p></blockquote><h1 id="作业Demo"><a href="#作业Demo" class="headerlink" title="作业Demo"></a>作业Demo</h1><p><img src="http://tc.holychen.cn/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1603960797904.png" alt="HOB Homework"></p><ul><li>OemHob.h</li></ul><pre class="line-numbers language-none"><code class="language-none">#ifndef __OEM_HOB_H__#define __OEM_HOB_H__#ifdef __cplusplusextern &quot;C&quot; &#123;#endif#define OEM_HOB_GUID \    &#123;0xe73e6c2b, 0xaa9a, 0x4b51, 0x94, 0x56, 0x50, 0xd2, 0x8b, 0xcc, 0x57, 0xf3&#125;typedef struct _OEM_HOB&#123;           EFI_HOB_GUID_TYPE GuidExtension;    CHAR8 OemString[10];    UINT16 MemorySpace;      &#125; OEM_HOB;&#x2F;****** DO NOT WRITE BELOW THIS LINE *******&#x2F;#ifdef __cplusplus&#125;#endif#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>PeiCreateHob.c</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;AmiPeiLib.h&gt;#include &lt;Library&#x2F;PeiServicesLib.h&gt;#include &lt;Library&#x2F;HobLib.h&gt;#include &lt;OemHob.h&gt;#include &lt;MemInfoHob.h&gt;extern EFI_GUID gSiMemoryInfoDataGuid;EFI_STATUS PeiCreateHobEntryPoint(   IN EFI_PEI_FILE_HANDLE   FileHandle,   IN CONST EFI_PEI_SERVICES  **PeiServices)&#123;    EFI_STATUS    Status &#x3D; EFI_SUCCESS;    OEM_HOB       *pHob     &#x3D; NULL;    VOID          *Memory_Hob  &#x3D; NULL;    EFI_GUID      OemHobGuid &#x3D; OEM_HOB_GUID;    EFI_GUID      MemoryInfoDataGuid &#x3D; gSiMemoryInfoDataGuid;    &#x2F;&#x2F;CHAR8         BIOSVersion[] &#x3D; CONVERT_TO_STRING(PLATFORM_NAME);    CHAR8         BIOSVersion[10]&#x3D;&quot;kabylake&quot;;    UINT16        MemorySize &#x3D; 0;    &#x2F;&#x2F; Get physical address bits supported.    Memory_Hob &#x3D; GetFirstGuidHob(&amp;MemoryInfoDataGuid);    if (Memory_Hob !&#x3D; NULL) &#123;        MemorySize &#x3D; ((MEMORY_INFO_DATA_HOB *) Memory_Hob)-&gt;TotalPhysicalMemorySize;        DEBUG((-1,&quot;\nElder has been got MemoryInfoDataHob in Pei Phase!&quot;));        DEBUG((-1,&quot;\nMemoryInfoDataHob Address : %p&quot;,Memory_Hob));      &#125;             &#x2F;&#x2F;create HOB for DXE    Status &#x3D; (*PeiServices)-&gt;CreateHob (PeiServices,                                        EFI_HOB_TYPE_GUID_EXTENSION,                                         sizeof(OEM_HOB),                                         &amp;pHob);    if (!EFI_ERROR(Status))&#123;                      pHob-&gt;GuidExtension.Name &#x3D; OemHobGuid;           Strcpy(pHob-&gt;OemString,BIOSVersion);           pHob-&gt;MemorySpace &#x3D; MemorySize;                      DEBUG((-1,&quot;\nElder has been Created OemHob Success in Pei Phase!&quot;));                  &#125;        return EFI_SUCCESS;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>DxeFindHob.c</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;AmiDxeLib.h&gt;#include &lt;Library&#x2F;HobLib.h&gt;#include &lt;OemHob.h&gt;EFI_STATUS DxeFindHobEntryPoint(IN EFI_HANDLE ImageHandle,IN EFI_SYSTEM_TABLE *SystemTable)&#123;    EFI_STATUS      Status &#x3D; EFI_SUCCESS;    EFI_GUID        OemHobGuid &#x3D; OEM_HOB_GUID;    OEM_HOB         *pHob &#x3D; NULL;           InitAmiLib (ImageHandle , SystemTable) ;    pHob &#x3D; (OEM_HOB*)GetFirstGuidHob (&amp;OemHobGuid);                   if (pHob &#x3D;&#x3D; NULL)        &#123;            DEBUG((-1,&quot;\n Elder Dxe Phase return OemHob Data Error!\n&quot;));        &#125;    else        &#123;            DEBUG((-1,&quot;\n Elder OemHob Address &#x3D; %p\n&quot;,pHob));                DEBUG((-1,&quot;\n Elder Dxe Phase has been got HobData OemString &#x3D; %s\n&quot;,pHob-&gt;OemString));            DEBUG((-1,&quot;\n Elder Dxe Phase has been got HobData MemorySpace &#x3D; %d MB\n&quot;,pHob-&gt;MemorySpace));        &#125;     return EFI_SUCCESS;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构, 线性表, 接口, 实现 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
